<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>訪廠問題表格｜填寫＋PPT 匯出</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;600;700&display=swap');
    :root { --font: 'Noto Sans TC','Microsoft JhengHei',system-ui,-apple-system,Segoe UI,Arial,sans-serif; }
    body { font-family: var(--font); }

    /* 單張圖片：不縮放顯示（可捲動） */
    .one-image-wrap { overflow: auto; }
    .one-image-wrap img { max-width: none; height: auto; }

    /* Tabs scroll (mobile-friendly) */
    .tabs-scroll { -webkit-overflow-scrolling: touch; }

    /* Handwriting canvas: avoid browser touch gestures while drawing */
    canvas.notesCanvas { touch-action: none; }
  
    /* Notes tool button active state */
    .notesEraserBtn.is-eraser {
      background: #0f172a; /* slate-900 */
      color: #ffffff;
      border-color: #0f172a;
    }
    .notesCanvasBox { box-sizing: border-box; }

    /* Notes tool button (pen/eraser) active state */
    .notesToolBtn.is-active {
      background: #0f172a; /* slate-900 */
      color: #ffffff;
      border-color: #0f172a;
    }


    /* Generic tool button active/disabled state (used by PDF annotation tools) */
    .pdfToolBtn.is-active {
      background: #0f172a; /* slate-900 */
      color: #ffffff;
      border-color: #0f172a;
    }
    .btn-disabled {
      opacity: 0.45;
      pointer-events: none;
      filter: grayscale(0.15);
    }
/* Tablet-friendly resize handle (acts like textarea corner) */
.notesResizeHandle{
  position:absolute;
  right:6px;
  bottom:6px;
  width:18px;
  height:18px;
  cursor: ns-resize;
  border-radius:6px;
  background:
    linear-gradient(135deg, transparent 0 50%, rgba(148,163,184,.55) 50% 52%, transparent 52% 60%, rgba(148,163,184,.55) 60% 62%, transparent 62% 70%, rgba(148,163,184,.55) 70% 72%, transparent 72% 100%);
}

    .processStepsPreviewWrap{display:none !important;}
    .processRefreshBtn{display:none !important;}
  

    /* PDF 全螢幕（不依賴 Fullscreen API） */
    body.pdf-fs-lock { overflow: hidden; }

    .pdfInlineWrap.is-fullscreen {
      position: fixed !important;
      inset: 0 !important;
      z-index: 9999 !important;
      width: 100vw !important;
      height: 100vh !important;
      margin: 0 !important;
      border-radius: 0 !important;
      border-left: 0 !important;
      border-right: 0 !important;
      border-top: 0 !important;
      border-bottom: 0 !important;
      display: flex !important;
      flex-direction: column !important;
      background: #ffffff;
    }

    .pdfInlineWrap.is-fullscreen > .pdfFsDock {
      position: relative;
      flex: 1 1 auto;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }

    .pdfInlineWrap.is-fullscreen .pdfInlineRender {
      max-height: none !important;
      min-height: 0 !important;
      height: auto !important;
      flex: 1 1 auto !important;
      overflow: auto !important;
      -webkit-overflow-scrolling: touch;
    }

    /* iPad / mobile：讓容器本身具備慣性滾動（非全螢幕也適用） */
    .pdfInlineRender {
      -webkit-overflow-scrolling: touch;
    }

    .pdfInlineWrap.is-fullscreen .pdfHeaderBar {
      position: sticky;
      top: 0;
      z-index: 20;
      background: rgba(248,250,252,0.96);
      backdrop-filter: blur(6px);
    }

    /* 全螢幕模式：把原本 header 上的標註工具隱藏，改用左下角浮動工具列 */
    .pdfInlineWrap.is-fullscreen .pdfAnnoToggle,
    .pdfInlineWrap.is-fullscreen .pdfPenSizeBtn,
    .pdfInlineWrap.is-fullscreen .pdfPenColorBtn,
    .pdfInlineWrap.is-fullscreen .pdfAnnoEraser,
    .pdfInlineWrap.is-fullscreen .pdfAnnoClear,
    .pdfInlineWrap.is-fullscreen .pdfPenSettings {
      display: none !important;
    }

    /* 右下角：關閉全螢幕（YouTube-like） */
    .pdfFsCloseBtn {
      position: absolute;
      right: 16px;
      bottom: 16px;
      z-index: 40;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 46px;
      height: 46px;
      border-radius: 9999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(15,23,42,0.82);
      color: #ffffff;
      box-shadow: 0 12px 26px rgba(15,23,42,0.35);
    }
    .pdfFsCloseBtn:hover { background: rgba(15,23,42,0.92); }

    /* 左下角：浮動工具列按鈕 */
    .pdfFsToolFab {
      position: absolute;
      left: 16px;
      bottom: 16px;
      z-index: 40;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 50px;
      height: 50px;
      border-radius: 9999px;
      border: 1px solid rgba(15,23,42,0.08);
      background: rgba(255,255,255,0.92);
      box-shadow: 0 12px 26px rgba(15,23,42,0.18);
      color: #0f172a;
    }

    .pdfFsToolPanel {
      position: absolute;
      left: 16px;
      bottom: 76px;
      z-index: 41;
      width: 260px;
      padding: 12px;
      border-radius: 16px;
      border: 1px solid rgba(15,23,42,0.10);
      background: rgba(255,255,255,0.96);
      backdrop-filter: blur(8px);
      box-shadow: 0 16px 34px rgba(15,23,42,0.18);
    }

    .pdfFsToolPanel .row { display: flex; align-items: center; gap: 8px; }
    .pdfFsToolPanel .row + .row { margin-top: 10px; }
    .pdfFsToolPanel .toolBtn {
      flex: 1 1 auto;
      border: 1px solid #e2e8f0;
      background: #ffffff;
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 700;
      color: #0f172a;
    }
    .pdfFsToolPanel .toolBtn.is-active {
      background: #0f172a;
      color: #ffffff;
      border-color: #0f172a;
    }
    .pdfFsToolPanel .miniBtn {
      border: 1px solid #e2e8f0;
      background: #ffffff;
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 700;
      color: #0f172a;
      white-space: nowrap;
    }
    .pdfFsToolPanel .label { font-size: 12px; font-weight: 700; color: #334155; }
    .pdfFsToolPanel input[type="range"] { width: 140px; }
    .pdfFsToolPanel .fsColorSwatch { width: 18px; height: 18px; border-radius: 9999px; border: 1px solid #cbd5e1; }
    .pdfFsToolPanel .fsColorSwatch.is-active { outline: 2px solid #0f172a; outline-offset: 2px; }
    .pdfFsToolPanel .fsColorPicker { height: 32px; width: 44px; border-radius: 10px; border: 1px solid #cbd5e1; background: #fff; padding: 0; }



  </style>

  <script>
    // --- Robust loader for PptxGenJS (fix "download button does nothing" when CDN is blocked) ---
    async function loadScriptOnce(src) {
      return new Promise((resolve, reject) => {
        const existing = document.querySelector('script[data-src="' + src + '"]');
        if (existing) { resolve(); return; }

        const s = document.createElement('script');
        s.src = src;
        s.async = true;
        s.setAttribute('data-src', src);
        s.onload = () => resolve();
        s.onerror = () => reject(new Error('Failed to load: ' + src));
        document.head.appendChild(s);
      });
    }

    async function ensurePptxGenLoaded() {
      // Already loaded
      if (window.PptxGenJS) return true;

      const candidates = [
        // Primary (jsDelivr GitHub)
        'https://cdn.jsdelivr.net/gh/gitbrent/pptxgenjs@3.12.0/dist/pptxgen.bundle.js',
        // Fallback (unpkg)
        'https://unpkg.com/pptxgenjs@3.12.0/dist/pptxgen.bundle.js',
        // Local fallback (place pptxgen.bundle.js next to this HTML if you want offline mode)
        './pptxgen.bundle.js'
      ];

      for (const url of candidates) {
        try {
          await loadScriptOnce(url);
          if (window.PptxGenJS) return true;
        } catch (e) {
          // continue
          console.warn(e);
        }
      }
      return false;
    }
  

    async function ensureJsPdfLoaded() {
      if (window.jspdf && window.jspdf.jsPDF) return true;

      const candidates = [
        'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js',
        'https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js',
        './jspdf.umd.min.js'
      ];

      for (const url of candidates) {
        try {
          await loadScriptOnce(url);
          if (window.jspdf && window.jspdf.jsPDF) return true;
        } catch (e) {
          console.warn(e);
        }
      }
      return false;
    }
</script>

  <script>
    // --- PDF.js loader (for extracting product name from 排關圖 PDF) ---

    async function ensureXlsxLoaded() {
      if (window.XLSX) return true;

      const candidates = [
        'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js',
        'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js',
        'https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js',
        // Local fallback (place xlsx.full.min.js next to this HTML if you want offline mode)
        './xlsx.full.min.js'
      ];

      for (const src of candidates) {
        try {
          await loadScriptOnce(src);
          if (window.XLSX) return true;
        } catch (e) { /* try next */ }
      }
      return false;
    }

    // ExcelJS loader (better style/print-area support for XLSX -> PDF rendering)
    async function ensureExcelJsLoaded() {
      if (window.ExcelJS) return true;

      const candidates = [
        'https://cdn.jsdelivr.net/npm/exceljs@4.4.0/dist/exceljs.min.js',
        'https://unpkg.com/exceljs@4.4.0/dist/exceljs.min.js',
        // Local fallback (place exceljs.min.js next to this HTML if you want offline mode)
        './exceljs.min.js'
      ];

      for (const src of candidates) {
        try {
          await loadScriptOnce(src);
          if (window.ExcelJS) return true;
        } catch (e) { /* try next */ }
      }
      return false;
    }

    function captureProcessStepsFromDOM(idx) {
      const rec = (state.records && state.records[idx]) ? state.records[idx] : null;

      const panel = document.querySelector(`.panel[data-idx="${idx}"]`);
      const wrap = panel ? panel.querySelector('.processStepsTable') : null;
      const rowsEls = wrap ? wrap.querySelectorAll('.procRow') : null;

      // If UI not rendered yet, fall back to stored rows
      if (!rowsEls || rowsEls.length === 0) {
        return (rec && Array.isArray(rec.processStepsRows)) ? rec.processStepsRows : [];
      }

      const out = [];
      rowsEls.forEach((rowEl) => {
        const no = (rowEl.querySelector('[data-col="no"]')?.textContent || rowEl.getAttribute('data-no') || '').trim();
        const step = (rowEl.querySelector('[data-col="step"]')?.textContent || '').trim();

        const man = (rowEl.querySelector('[data-col="man"]')?.textContent || '').trim();
        const manOk = !!rowEl.querySelector('[data-col="manOk"]')?.checked;
        const manActual = (rowEl.querySelector('[data-col="manActual"]')?.value || '').trim();

        const time = (rowEl.querySelector('[data-col="time"]')?.textContent || '').trim();
        const timeOk = !!rowEl.querySelector('[data-col="timeOk"]')?.checked;
        const timeActual = (rowEl.querySelector('[data-col="timeActual"]')?.value || '').trim();

        // NOTE: v9 原本未同步「紀錄」欄位，導致非首個分頁匯出時 note 會遺失。
        const note = (rowEl.querySelector('[data-col="note"]')?.value || '').trim();

        // 只要該列有任一欄位有值（含 note），就寫回 state
        if (no || step || man || manActual || time || timeActual || note || manOk || timeOk) {
          out.push({ no, step, man, manOk, manActual, time, timeOk, timeActual, note });
        }
      });

      if (rec) {
        rec.processStepsRows = out;

        // recompute derived summary (keeps existing values if already set)
        const toInt = (v) => {
          const n = parseInt(String(v ?? '').replace(/[^\d\-]/g, ''), 10);
          return Number.isFinite(n) ? n : 0;
        };
        const toFloat = (v) => {
          const n = parseFloat(String(v ?? '').replace(/[^\d\.\-]/g, ''));
          return Number.isFinite(n) ? n : 0;
        };

        const req = out.reduce((acc, r) => acc + toInt(r.man), 0);
        const tSum = out.reduce((acc, r) => acc + toFloat(r.time), 0);

        const prev = rec.processStepsSummary || {};
        rec.processStepsSummary = {
          requiredPeople: (prev.requiredPeople != null ? prev.requiredPeople : req),
          totalPeople: (prev.totalPeople != null ? prev.totalPeople : req),
          totalTime: (prev.totalTime != null ? prev.totalTime : tSum),
        };

        try { saveState(); } catch (e) {}
      }

      return out;
    }

    async function exportProcessExcel() {
      const ok = await ensureXlsxLoaded();
      if (!ok || !window.XLSX) {
        alert('無法載入 Excel 匯出元件（SheetJS）。\n請確認網路可正常連線，或稍後再試。');
        return;
      }

      // 先把「目前畫面」作業工程的最新輸入同步回 state（避免只改畫面未寫回）
      try {
        const idx = state.active || 0;
        const live = captureProcessStepsFromDOM(idx);
        if (Array.isArray(live) && live.length) {
          state.records[idx] = state.records[idx] || {};
          state.records[idx].processStepsRows = live;
        }
        // 同步 summary（若 UI 有在算）
        if (typeof computeProcessSummary === 'function') {
          state.records[idx].processStepsSummary = computeProcessSummary(live);
        }
        saveState();
      } catch (e) {
        // ignore
      }

      const wb = XLSX.utils.book_new();
      const used = new Set();

      function sanitizeSheetName(name) {
        let n = String(name || '').trim();
        if (!n) n = '分頁';
        // Excel sheet name restrictions
        n = n.replace(/[\[\]\:\*\?\/\\]/g, '_');
        if (n.length > 31) n = n.slice(0, 31);
        const base = n;
        let k = 2;
        while (used.has(n)) {
          const suf = '_' + k++;
          n = base.slice(0, Math.max(0, 31 - suf.length)) + suf;
        }
        used.add(n);
        return n;
      }

      function toNum(v) {
        if (v === null || v === undefined) return null;
        const s = String(v).trim();
        if (!s) return null;
        const n = Number(s);
        return Number.isFinite(n) ? n : null;
      }

      function sumOf(arr, pick) {
        let s = 0;
        let has = false;
        (arr || []).forEach(r => {
          const n = toNum(pick(r));
          if (n !== null) { s += n; has = true; }
        });
        return has ? s : '';
      }

      const records = Array.isArray(state.records) ? state.records : [];
      let appended = 0;

      records.forEach((rec, i) => {
        const rows = Array.isArray(rec?.processStepsRows) ? rec.processStepsRows : [];
        if (!rows.length) return;

        const product = rec.name || rec.productName || rec.product || rec.item || rec.title || ('分頁' + (i + 1));
        const sheetName = sanitizeSheetName(product);

        const yn = (b) => (b ? 'Y' : '');
        const aoa = [];
        // Row 1: 商品名稱（比照範例：A1=商品名稱:、B1=商品名）
        aoa.push(['商品名稱:', product, null, null, null, null, null, null, null]);

        // Row 2: 表頭（比照範例）
        aoa.push(['項次', '工程', '人數-標準', '人數-符合', '人數-實際', '作業時間-標準', '作業時間-符合', '作業時間-實際', '紀錄']);

        rows.forEach((r, idx) => {
          aoa.push([
            String(r.no ?? (idx + 1)),
            r.step ?? '',
            r.man ?? '',
            yn(!!r.manOk),
            r.manActual ?? '',
            r.time ?? '',
            yn(!!r.timeOk),
            r.timeActual ?? '',
            r.note ?? ''
          ]);
        });

        // summary（若已有就用；沒有就用 rows 推算）
        const summary = rec.processStepsSummary || {};
        const requiredPeople = (summary.requiredPeople ?? summary.needPeople ?? summary.reqPeople ?? '') !== ''
          ? (summary.requiredPeople ?? summary.needPeople ?? summary.reqPeople)
          : sumOf(rows, r => r.man);
        const totalPeople = (summary.totalPeople ?? summary.sumPeople ?? '') !== ''
          ? (summary.totalPeople ?? summary.sumPeople)
          : sumOf(rows, r => (String(r.manActual ?? '').trim() ? r.manActual : r.man));
        const totalTime = (summary.totalTime ?? summary.totalSeconds ?? summary.sumTime ?? '') !== ''
          ? (summary.totalTime ?? summary.totalSeconds ?? summary.sumTime)
          : sumOf(rows, r => r.time);

        // 空白行（比照範例）
        aoa.push([null, null, null, null, null, null, null, null, null]);

        // 底部摘要（比照範例：A 欄標籤、B 欄數值）
        aoa.push(['所需人數', requiredPeople ?? '', null, null, null, null, null, null, null]);
        aoa.push(['總計人數', totalPeople ?? '', null, null, null, null, null, null, null]);
        aoa.push(['總作業時間(S)', totalTime ?? '', null, null, null, null, null, null, null]);

        const ws = XLSX.utils.aoa_to_sheet(aoa);
        XLSX.utils.book_append_sheet(wb, ws, sheetName);
        appended += 1;
      });

      if (!appended) {
        alert('目前沒有可匯出的作業工程資料。\n請先匯入排關圖並擷取作業工程。');
        return;
      }

      const today = new Date();
      const y = today.getFullYear();
      const m = String(today.getMonth() + 1).padStart(2, '0');
      const d = String(today.getDate()).padStart(2, '0');
      const filename = `作業工程_${y}${m}${d}.xlsx`;

      try {
        XLSX.writeFile(wb, filename);
      } catch (e) {
        console.error(e);
        alert('匯出失敗：瀏覽器阻擋下載或寫入失敗。\n建議改用 Chrome / Edge 重新嘗試。');
      }
    }

    async function ensurePdfJsLoaded() {
      // pdf.js must be available as window.pdfjsLib (UMD build)
      if (window.pdfjsLib && window.pdfjsLib.getDocument) return true;

      const candidates = [
        // Prefer stable UMD builds that expose window.pdfjsLib reliably
        'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js',
        'https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/pdf.min.js',
        'https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.min.js',
        './pdf.min.js'
      ];

      const workerCandidates = [
        'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js',
        'https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/pdf.worker.min.js',
        'https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.worker.min.js',
        './pdf.worker.min.js'
      ];

      for (let i = 0; i < candidates.length; i++) {
        const url = candidates[i];
        try {
          await loadScriptOnce(url);

          // Some builds attach to a different global; normalize to pdfjsLib
          const lib = window.pdfjsLib || window['pdfjs-dist/build/pdf'];
          if (lib && lib.getDocument) {
            window.pdfjsLib = lib;

            // Best-effort worker configuration; if worker fails, we will fallback to disableWorker at runtime.
            try {
              window.pdfjsLib.GlobalWorkerOptions.workerSrc = workerCandidates[i] || workerCandidates[0];
            } catch (e) {}

            return true;
          }
        } catch (e) {
          console.warn('[pdfjs] load failed:', url, e);
        }
      }
      return false;
    }
  </script>

</head>

<body class="bg-slate-50 text-slate-800">
  <!-- Floating catalog button (left-top, slightly lower to avoid covering title) -->
  <button id="catalogBtn"
          class="fixed z-40 rounded-xl border bg-white/90 backdrop-blur px-3 py-2 text-sm font-semibold shadow hover:bg-slate-50" style="left: 0; top: 0;">
    商品目錄
  </button>

  <header class="sticky top-0 z-30 border-b bg-white/80 backdrop-blur">
    <div class="mx-auto max-w-6xl px-4 py-3 flex items-center justify-between gap-3">
      <div class="min-w-0 flex items-center gap-2">
        <h1 class="text-lg font-bold truncate">訪廠問題表格</h1>
      </div>
      <div class="flex flex-wrap items-center gap-2 justify-end">
        <button id="clearFormBtnHeader" class="rounded-xl border border-rose-200 bg-rose-50 px-3 py-2 text-sm font-semibold text-rose-700 hover:bg-rose-100">清空表單</button>
        <button id="importPdfBtnHeader" class="rounded-xl border px-3 py-2 text-sm font-semibold hover:bg-slate-50">匯入排關圖(離線用)</button>
        <button id="openDriveFolderBtn" class="rounded-xl border px-3 py-2 text-sm font-semibold hover:bg-slate-50">開啟雲端</button>
        <button id="driveImportBtn" class="rounded-xl border px-3 py-2 text-sm font-semibold hover:bg-slate-50">從雲端匯入</button>
        
        <button id="exportProcessBtn"
                class="rounded-xl bg-emerald-600 px-3 py-2 text-sm font-semibold text-white hover:bg-emerald-500">
          下載作業工程
        </button>
<button id="exportBtn"
                class="rounded-xl bg-orange-500 px-3 py-2 text-sm font-semibold text-white hover:bg-orange-400">
          下載 PPT
        </button>
      </div>
    </div>
  </header>

  <!-- Tabs bar -->
  <div id="tabsBar" class="sticky top-[57px] z-20 border-b bg-white">
    <div class="mx-auto max-w-6xl px-4 py-2">
      <div class="flex items-center gap-2">
        <div id="tabs" class="tabs-scroll flex-1 overflow-auto whitespace-nowrap"></div>
        <div class="shrink-0 hidden sm:flex items-center gap-2">
          <!-- 新增表單：放在「複製目前」左邊 -->
<button id="addRowBtn"
                  class="rounded-xl bg-slate-900 px-3 py-1.5 text-xs font-semibold text-white hover:bg-slate-800">
            新增表單
          </button>
          <button id="dupActiveBtn" class="rounded-xl border px-3 py-1.5 text-xs font-semibold hover:bg-slate-50">複製目前</button>
          <button id="delActiveBtn"
                  class="rounded-xl border border-rose-200 bg-rose-50 px-3 py-1.5 text-xs font-semibold text-rose-700 hover:bg-rose-100">
            刪除目前
          </button>
        </div>
      </div>
    </div>
  </div>

  <main class="mx-auto max-w-6xl px-4 py-6">
    <section aria-label="records">
      <div id="panels"></div>
    </section>
  </main>

  <!-- Catalog modal -->
  <div id="catalogModal" class="fixed inset-0 z-50 hidden">
    <div class="absolute inset-0 bg-black/40" data-close="true"></div>
    <div class="absolute bottom-0 left-0 right-0 sm:inset-0 sm:flex sm:items-center sm:justify-center">
      <div class="w-full sm:max-w-lg rounded-t-2xl sm:rounded-2xl bg-white shadow-xl">
        <div class="flex items-center justify-between px-4 py-3 border-b">
          <div>
            <div class="text-sm font-semibold">商品目錄</div>
            <div class="text-xs text-slate-500">點選可跳轉到對應表單</div>
          </div>
          <button id="closeCatalogBtn" class="rounded-xl border px-3 py-1.5 text-xs font-semibold hover:bg-slate-50">關閉</button>
        </div>
        <div id="catalogList" class="max-h-[70vh] overflow-auto p-2"></div>
      </div>
    </div>
  </div>

  <template id="panelTpl">
    <article class="rounded-2xl border bg-white p-4 shadow-sm">
      <div class="flex items-start justify-between gap-3">
        <div class="min-w-0">
          <h2 class="text-sm font-semibold text-slate-700">
            <span class="panelTitle">表單</span>
          </h2>
        </div>
        <!-- Mobile actions (same position on every form) -->
        <div class="flex shrink-0 items-center gap-2 sm:hidden">
          <button class="addBtn rounded-xl border px-3 py-1.5 text-xs font-semibold hover:bg-slate-50">新增</button>
          <button class="dupBtn rounded-xl border px-3 py-1.5 text-xs font-semibold hover:bg-slate-50">複製</button>
          <button class="delBtn rounded-xl border border-rose-200 bg-rose-50 px-3 py-1.5 text-xs font-semibold text-rose-700 hover:bg-rose-100">刪除</button>
        </div>
      </div>

      <div class="mt-4 grid grid-cols-1 gap-4 md:grid-cols-12">
        <div class="md:col-span-12 rounded-2xl border bg-slate-50 p-4">
          <div class="grid grid-cols-1 gap-4 md:grid-cols-12">
        <label class="md:col-span-4">
          <span class="text-xs font-semibold text-slate-600">類型</span>
          <select class="typeInput mt-1 w-full rounded-xl border px-3 py-2 text-sm focus:outline-none focus:ring">
            <option value="">請選擇</option>
            <option value="生產面">生產面</option>
            <option value="衛生面">衛生面</option>
          </select>
        </label>

        <label class="md:col-span-8">
          <span class="text-xs font-semibold text-slate-600">商品名</span>
          <div class="mt-1 flex items-center gap-2">
            <div class="relative flex-1">
              <input class="nameInput w-full rounded-xl border px-3 py-2 text-sm focus:outline-none focus:ring" placeholder="" autocomplete="off" />
              <div class="suggestBox hidden absolute left-0 right-0 mt-1 rounded-xl border bg-white shadow-lg overflow-hidden z-20"></div>
            </div>
            
            <button type="button" class="processExtractBtn shrink-0 rounded-xl border px-3 py-2 text-sm font-semibold hover:bg-slate-50">
              作業工程
            </button>
<button type="button" class="showPdfBtn shrink-0 rounded-xl border px-3 py-2 text-sm font-semibold hover:bg-slate-50">
              顯示排關圖
            </button>
          </div>
            <div class="processLoading mt-1 text-xs text-slate-500 hidden">載入中…</div>
        </label>

        <!-- KPI（排關圖自動帶入） -->
        <div class="md:col-span-12">
          <div class="mt-3 rounded-2xl border bg-white p-3">
            <div class="grid grid-cols-1 gap-3 md:grid-cols-12">
              <label class="md:col-span-6">
                <span class="text-xs font-semibold text-slate-600">預計產量(hr)</span>
                <div class="mt-1 flex items-center gap-2">
                  <input class="kpiPlannedOutputInput w-full rounded-xl border px-3 py-2 text-sm bg-slate-100 text-slate-700 focus:outline-none focus:ring" readonly aria-readonly="true" placeholder="—" autocomplete="off" />
                  <span class="text-xs font-semibold text-slate-500 whitespace-nowrap">個/hr</span>
                </div>
              </label>

              <label class="md:col-span-6">
                <span class="text-xs font-semibold text-slate-600">人時生產性</span>
                <div class="mt-1 flex items-center gap-2">
                  <input class="kpiManHourInput w-full rounded-xl border px-3 py-2 text-sm bg-slate-100 text-slate-700 focus:outline-none focus:ring" readonly aria-readonly="true" placeholder="—" autocomplete="off" />
                  <span class="text-xs font-semibold text-slate-500 whitespace-nowrap">個/時</span>
                </div>
              </label>

              <label class="md:col-span-6">
                <span class="text-xs font-semibold text-slate-600">包裝機台產能(hr)</span>
                <div class="mt-1 flex items-center gap-2">
                  <input class="kpiPackCapInput w-full rounded-xl border px-3 py-2 text-sm bg-slate-100 text-slate-700 focus:outline-none focus:ring" readonly aria-readonly="true" placeholder="—" autocomplete="off" />
                  <span class="text-xs font-semibold text-slate-500 whitespace-nowrap">個/hr</span>
                </div>
              </label>



              <label class="md:col-span-6">
                <span class="text-xs font-semibold text-slate-600">包裝設備</span>
                <input class="kpiPackEquipInput mt-1 w-full rounded-xl border px-3 py-2 text-sm bg-slate-100 text-slate-700 focus:outline-none focus:ring" readonly aria-readonly="true" placeholder="—" autocomplete="off" />
              </label>

              <div class="md:col-span-12">
                <div class="kpiHint text-xs text-slate-500 mt-1 hidden"></div>
              </div>
            </div>
          </div>
        </div>

          </div>
        </div>

        
<!-- 排關圖（內嵌顯示｜取代跳出視窗） -->
<div class="pdfInlineWrap hidden mt-4 col-span-full md:col-span-12 md:col-start-1 w-full rounded-2xl border bg-white overflow-hidden"><div class="pdfFsDock">
  <div class="pdfHeaderBar flex flex-wrap items-center justify-between gap-2 px-4 py-3 border-b bg-slate-50">
    <div class="text-sm font-semibold text-slate-700">排關圖</div>
    <div class="flex flex-wrap items-center gap-2">
      <div class="inline-flex items-center overflow-hidden rounded-lg border bg-white">
        <button type="button" class="pdfZoomOut px-3 py-1.5 text-sm font-semibold hover:bg-slate-50">－</button>
        <button type="button" class="pdfFit border-x px-3 py-1.5 text-sm font-semibold hover:bg-slate-50" title="全螢幕">全螢幕</button>
        <button type="button" class="pdfZoomIn px-3 py-1.5 text-sm font-semibold hover:bg-slate-50">＋</button>
      </div>
      <button type="button" class="pdfAnnoToggle pdfToolBtn rounded-lg border bg-white px-3 py-1.5 text-sm font-semibold hover:bg-slate-50">畫筆</button>
      <button type="button" class="pdfPenSizeBtn rounded-lg border bg-white px-3 py-1.5 text-sm font-semibold hover:bg-slate-50">粗細</button>
      <button type="button" class="pdfPenColorBtn rounded-lg border bg-white px-3 py-1.5 text-sm font-semibold hover:bg-slate-50">顏色</button>
      <button type="button" class="pdfAnnoEraser pdfToolBtn rounded-lg border bg-white px-3 py-1.5 text-sm font-semibold hover:bg-slate-50">橡皮擦</button>
      <button type="button" class="pdfAnnoClear rounded-lg border bg-white px-3 py-1.5 text-sm font-semibold hover:bg-slate-50">清除標註</button>
      <button type="button" class="closePdfInlineBtn rounded-lg border bg-white px-3 py-1.5 text-sm font-semibold hover:bg-slate-50">收合</button>
      <button type="button" class="pdfDownloadBtn rounded-lg border bg-white px-3 py-1.5 text-sm font-semibold hover:bg-slate-50">下載排關圖</button>
    </div>
  </div>
  <div class="pdfPenSettings hidden border-b bg-white px-4 py-2">
    <div class="flex flex-wrap items-center gap-4">
      <div class="flex items-center gap-2">
        <span class="text-xs font-semibold text-slate-600">畫筆粗細</span>
        <input type="range" min="1" max="12" step="1" class="pdfPenSizeRange w-40" />
        <span class="pdfPenSizeValue w-6 text-right text-xs font-semibold text-slate-700">3</span>
      </div>

      <div class="flex flex-wrap items-center gap-2">
        <span class="text-xs font-semibold text-slate-600">顏色</span>
        <div class="flex items-center gap-1">
          <button type="button" class="pdfPenColorSwatch h-6 w-6 rounded-full border" data-color="#f97316" style="background:#f97316"></button>
          <button type="button" class="pdfPenColorSwatch h-6 w-6 rounded-full border" data-color="#ef4444" style="background:#ef4444"></button>
          <button type="button" class="pdfPenColorSwatch h-6 w-6 rounded-full border" data-color="#3b82f6" style="background:#3b82f6"></button>
          <button type="button" class="pdfPenColorSwatch h-6 w-6 rounded-full border" data-color="#22c55e" style="background:#22c55e"></button>
          <button type="button" class="pdfPenColorSwatch h-6 w-6 rounded-full border" data-color="#111827" style="background:#111827"></button>
        </div>
        <input type="color" class="pdfPenColorPicker h-8 w-10 rounded-lg border bg-white p-0" />
        <span class="pdfPenColorValue text-xs font-mono text-slate-500">#f97316</span>
      </div>

      <button type="button" class="pdfPenSettingsClose ml-auto rounded-lg border bg-white px-3 py-1.5 text-xs font-semibold hover:bg-slate-50">關閉設定</button>
    </div>
  </div>
  <div class="pdfInlineRender w-full max-h-[82vh] min-h-[55vh] overflow-auto bg-slate-50"></div>
</div>
</div>

<div class="md:col-span-12">

        <!-- 作業工程（從排關圖擷取 -> 轉成可編輯表格） -->
        <div class="md:col-span-12 md:col-start-1 col-span-1 w-full processStepsWrap hidden">
          <div class="flex items-center justify-between gap-2">
            <span class="text-xs font-semibold text-slate-600">作業工程</span>
            <div class="flex items-center gap-2">
              <button type="button" class="processRefreshBtn rounded-xl border px-3 py-1.5 text-xs font-semibold hover:bg-slate-50 hidden">重新擷取</button>
            </div>
          </div>
          <div class="processStepsHint mt-1 text-xs text-slate-500"></div>
          <div class="mt-2 rounded-xl border bg-white overflow-auto w-full max-w-none">
            <div class="processStepsTable w-full text-sm">
              <!-- JS render -->
            </div>
          </div>
        </div>
      <!-- 內容記錄 -->
      <div class="mt-1">
        <div class="mb-1 text-xs font-semibold text-slate-500">內容記錄</div>
        <textarea class="notesTextInput w-full rounded-xl border px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-slate-300"
          style="height: 380px; resize: vertical;"
          placeholder="可直接打字記錄（例如：現況、觀察重點、原因假設、與廠方確認內容等）"></textarea>
      </div>



        <label class="md:col-span-12">
          <span class="text-xs font-semibold text-slate-600">問題說明</span>
          <textarea class="descInput mt-1 w-full rounded-xl border px-3 py-2 text-sm focus:outline-none focus:ring" rows="10" placeholder="" style="min-height: 220px; resize: vertical;"></textarea>
        </label>
      </div>

      <div class="mt-4 col-span-full md:col-span-12 rounded-2xl border bg-slate-50 p-4">
        <div class="flex flex-wrap items-center justify-between gap-3">
          <div>
            <p class="text-sm font-semibold">圖片上傳（支援手機、多張）</p>
            <p class="text-xs text-slate-600">一次可選多張；PPT 每頁最多放 2 張，超過會自動續頁。</p>
          </div>
          <div class="flex items-center gap-2">
            <label class="rounded-xl bg-slate-900 px-3 py-2 text-sm font-semibold text-white hover:bg-slate-800 cursor-pointer">
              選擇圖片
              <input class="imgInput hidden" type="file" accept="image/*" multiple />
            </label>
            <button class="clearImgsBtn rounded-xl border px-3 py-2 text-sm font-semibold hover:bg-white">清除圖片</button>
          </div>
        </div>

        <div class="mt-4">
          <div class="imgHint text-xs text-slate-500">尚未選擇圖片。</div>
          <div class="imgPreview mt-3"></div>
        </div>
      </div>
    </article>
  </template>

  <input id="pdfInput" type="file" accept="application/pdf,.pdf,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-excel,.xlsx,.xls" multiple class="hidden" />


  <script>
    const $ = (sel, root) => (root || document).querySelector(sel);
    const $$ = (sel, root) => Array.from((root || document).querySelectorAll(sel));

    const tabsEl = $('#tabs');
    const panelsEl = $('#panels');
    const panelTpl = $('#panelTpl');

    const state = { records: [], active: 0 };

    // ---------------- 狀態保存（避免渲染階段因缺少 saveState() 當掉） ----------------
    const STATE_STORAGE_KEY = 'visit_form_state_v1';

    // ---------------- 雲端 PDF 離線快取（IndexedDB） ----------------
    // 目的：從雲端匯入後，把 PDF 下載並暫存在瀏覽器（IndexedDB），即使中途離線仍可擷取作業工程。
    // 注意：不同瀏覽器/無痕模式可能會限制容量；此處採取「可用就用，不可用就略過」策略。
    const PDF_CACHE_DB = 'visit_factory_pdf_cache_v1';
    const PDF_CACHE_STORE = 'pdfs';
    const DRIVE_IMPORTED_KEY = 'visit_drive_imported_pdfs_v1'; // 存已匯入的雲端PDF清單（供重整後復原）
    const CURRENT_IMPORTED_KEY = 'visit_current_imported_pdfs_v1'; // 本次匯入的排關圖清單（本機/雲端共用；A模式：每次匯入覆蓋）
    const ANNO_CACHE_STORE = 'annos'; // 排關圖畫筆/標註快取（IndexedDB）

    function idbOpen_() {
      return new Promise((resolve, reject) => {
        try {
          const req = indexedDB.open(PDF_CACHE_DB, 2);
          req.onupgradeneeded = () => {
            const db = req.result;
            if (!db.objectStoreNames.contains(PDF_CACHE_STORE)) {
              db.createObjectStore(PDF_CACHE_STORE, { keyPath: 'id' });
            }
            if (!db.objectStoreNames.contains(ANNO_CACHE_STORE)) {
              db.createObjectStore(ANNO_CACHE_STORE, { keyPath: 'id' });
            }
          };
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error || new Error('IndexedDB open failed'));
        } catch (e) {
          reject(e);
        }
      });
    }

    async function cachePutPdf_(id, arrayBuffer, meta) {
      if (!id || !arrayBuffer) return;
      if (!('indexedDB' in window)) return;
      try {
        const db = await idbOpen_();
        const tx = db.transaction(PDF_CACHE_STORE, 'readwrite');
        const store = tx.objectStore(PDF_CACHE_STORE);
        const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
        store.put({
          id: String(id),
          meta: meta || {},
          blob: blob,
          savedAt: Date.now()
        });
        await new Promise((res, rej) => {
          tx.oncomplete = () => res(true);
          tx.onerror = () => rej(tx.error || new Error('tx error'));
          tx.onabort = () => rej(tx.error || new Error('tx abort'));
        });
        try { db.close(); } catch (e) {}
      } catch (e) {
        console.warn('cachePutPdf_ failed:', e);
      }
    }

    async function cacheGetPdf_(id) {
      if (!id) return null;
      if (!('indexedDB' in window)) return null;
      try {
        const db = await idbOpen_();
        const tx = db.transaction(PDF_CACHE_STORE, 'readonly');
        const store = tx.objectStore(PDF_CACHE_STORE);
        const row = await new Promise((res, rej) => {
          const req = store.get(String(id));
          req.onsuccess = () => res(req.result || null);
          req.onerror = () => rej(req.error || new Error('get error'));
        });
        try { db.close(); } catch (e) {}
        if (!row || !row.blob) return null;
        const ab = await row.blob.arrayBuffer();
        return { ab, meta: row.meta || {}, savedAt: row.savedAt || 0 };
      } catch (e) {
        console.warn('cacheGetPdf_ failed:', e);
        return null;
      }
    }

    
    // List all cached PDFs (metadata only) from IndexedDB.
    // Used as a fallback restore path when localStorage is unavailable / cleared (common on iOS memory reclaim).
    async function cacheListAllPdfs_() {
      if (!('indexedDB' in window)) return [];
      try {
        const db = await idbOpen_();
        const tx = db.transaction(PDF_CACHE_STORE, 'readonly');
        const store = tx.objectStore(PDF_CACHE_STORE);
        const out = [];
        await new Promise((res, rej) => {
          const req = store.openCursor();
          req.onsuccess = (ev) => {
            const cur = ev.target.result;
            if (cur) {
              const v = cur.value || {};
              out.push({
                id: String(v.id || cur.key || ''),
                meta: v.meta || {},
                sizeBytes: Number(v.sizeBytes || 0),
                savedAt: Number(v.savedAt || 0)
              });
              cur.continue();
            } else {
              res(true);
            }
          };
          req.onerror = () => rej(req.error || new Error('cursor error'));
        });
        await new Promise((res, rej) => {
          tx.oncomplete = () => res(true);
          tx.onerror = () => rej(tx.error || new Error('tx error'));
          tx.onabort = () => rej(tx.error || new Error('tx abort'));
        });
        try { db.close(); } catch (e) {}
        return out;
      } catch (e) {
        console.warn('cacheListAllPdfs_ failed:', e);
        return [];
      }
    }

    // Fallback hydration: if imported-list in localStorage is missing, try rebuild pdfStore from cached PDFs.
    async function hydratePdfStoreFromCacheIndex_() {
      try {
        if (pdfStore && pdfStore.size) return false;
        const rows = await cacheListAllPdfs_();
        if (!rows || !rows.length) return false;

        let added = 0;
        for (const row of rows) {
          const meta = row.meta || {};
          const name = (meta.name != null) ? String(meta.name).trim() : '';
          if (!name) continue;

          const key = normalizeKey(name);
          if (!key) continue;
          if (pdfStore.has(key)) continue;

          const fileName = (meta.fileName != null) ? String(meta.fileName) : (name.endsWith('.pdf') ? name : (name + '.pdf'));
          const pdfItem = {
            displayName: name,
            id: String(row.id),
            fileName: fileName,
            blobUrl: '',      // on-demand
            openUrl: '',
            sizeBytes: Number(meta.sizeBytes || row.sizeBytes || 0),
            updatedAt: String(meta.updatedAt || ''),
            source: 'cache'
          };
          pdfStore.set(key, pdfItem);
          try { upsertCurrentImported_(pdfItem); } catch (e) {}
          added++;
        }

        if (added && !lastImportedPdfKey) {
          try { lastImportedPdfKey = Array.from(pdfStore.keys())[0] || ''; } catch (e) {}
        }
        return added > 0;
      } catch (e) {
        console.warn('hydratePdfStoreFromCacheIndex_ failed:', e);
        return false;
      }
    }

async function cacheClearAllPdfs_() {
      if (!('indexedDB' in window)) return;
      try {
        const db = await idbOpen_();
        const tx = db.transaction(PDF_CACHE_STORE, 'readwrite');
        const store = tx.objectStore(PDF_CACHE_STORE);
        store.clear();
        await new Promise((res, rej) => {
          tx.oncomplete = () => res(true);
          tx.onerror = () => rej(tx.error || new Error('tx error'));
          tx.onabort = () => rej(tx.error || new Error('tx abort'));
        });
        try { db.close(); } catch (e) {}
      } catch (e) {
        console.warn('cacheClearAllPdfs_ failed:', e);
      }
    }

    async function cachePutAnno_(id, annoStore) {
      if (!id) return;
      if (!('indexedDB' in window)) return;
      try {
        const db = await idbOpen_();
        const tx = db.transaction(ANNO_CACHE_STORE, 'readwrite');
        const store = tx.objectStore(ANNO_CACHE_STORE);
        store.put({
          id: String(id),
          store: annoStore || {},
          savedAt: Date.now()
        });
        await new Promise((res, rej) => {
          tx.oncomplete = () => res(true);
          tx.onerror = () => rej(tx.error || new Error('tx error'));
          tx.onabort = () => rej(tx.error || new Error('tx abort'));
        });
        try { db.close(); } catch (e) {}
      } catch (e) {
        console.warn('cachePutAnno_ failed:', e);
      }
    }

    async function cacheGetAnno_(id) {
      if (!id) return null;
      if (!('indexedDB' in window)) return null;
      try {
        const db = await idbOpen_();
        const tx = db.transaction(ANNO_CACHE_STORE, 'readonly');
        const store = tx.objectStore(ANNO_CACHE_STORE);
        const row = await new Promise((res, rej) => {
          const req = store.get(String(id));
          req.onsuccess = () => res(req.result || null);
          req.onerror = () => rej(req.error || new Error('get error'));
        });
        try { db.close(); } catch (e) {}
        if (!row) return null;
        return { store: row.store || {}, savedAt: row.savedAt || 0 };
      } catch (e) {
        console.warn('cacheGetAnno_ failed:', e);
        return null;
      }
    }

    async function cacheClearAllAnnos_() {
      if (!('indexedDB' in window)) return;
      try {
        const db = await idbOpen_();
        const tx = db.transaction(ANNO_CACHE_STORE, 'readwrite');
        const store = tx.objectStore(ANNO_CACHE_STORE);
        store.clear();
        await new Promise((res, rej) => {
          tx.oncomplete = () => res(true);
          tx.onerror = () => rej(tx.error || new Error('tx error'));
          tx.onabort = () => rej(tx.error || new Error('tx abort'));
        });
        try { db.close(); } catch (e) {}
      } catch (e) {
        console.warn('cacheClearAllAnnos_ failed:', e);
      }
    }


    // ---------------- Excel -> PDF 離線快取（IndexedDB） ----------------
    // 目的：同一份 Excel 排關圖重複點選『顯示排關圖』時，不必每次都重新轉檔。
    // 策略：用檔名 + byteLength + 快速雜湊（抽樣）組成 key；可用就用、不可用就略過。
    function __fnv1a32_(u8) {
      let h = 0x811c9dc5;
      for (let i = 0; i < u8.length; i++) {
        h ^= u8[i];
        h = (h * 0x01000193) >>> 0;
      }
      return h >>> 0;
    }

    function __fastHashExcelAb_(ab) {
      try {
        const u8 = new Uint8Array(ab);
        const n = u8.length;
        if (!n) return '0';
        const take = Math.min(32768, n);
        const head = u8.subarray(0, take);
        const tail = (n > take) ? u8.subarray(Math.max(0, n - take), n) : new Uint8Array();
        let h = __fnv1a32_(head);
        if (tail.length) h = (__fnv1a32_(tail) ^ ((h << 1) >>> 0)) >>> 0;
        return h.toString(16).padStart(8, '0');
      } catch (e) {
        return '0';
      }
    }

    function __excelPdfCacheIdForItem_(pdfItem) {
      try {
        const name = String((pdfItem && pdfItem.fileName) ? pdfItem.fileName : 'excel').slice(0, 180);
        const ab = pdfItem && pdfItem.excelAb;
        const len = (ab && ab.byteLength) ? Number(ab.byteLength) : 0;
        const h = (ab && len) ? __fastHashExcelAb_(ab) : '0';
        return `excelpdf:${name}:${len}:${h}`;
      } catch (e) {
        return null;
      }
    }

    function saveDriveImportedList_(arr) {
      try {
        localStorage.setItem(DRIVE_IMPORTED_KEY, JSON.stringify(arr || []));
      } catch (e) {}
    }

    function loadDriveImportedList_() {
      try {
        const raw = localStorage.getItem(DRIVE_IMPORTED_KEY);
        if (!raw) return [];
        const arr = JSON.parse(raw);
        return Array.isArray(arr) ? arr : [];
      } catch (e) {
        return [];
      }
    }

    function upsertDriveImported_(item) {
      if (!item || !item.id) return;
      const arr = loadDriveImportedList_();
      const id = String(item.id);
      const idx = arr.findIndex(x => String(x.id) === id);
      const payload = {
        id: id,
        displayName: item.displayName || '',
        fileName: item.fileName || '',
        previewUrl: item.previewUrl || '',
        openUrl: item.openUrl || '',
        sizeBytes: Number(item.sizeBytes || 0),
        updatedAt: item.updatedAt || ''
      };
      if (idx >= 0) arr[idx] = payload;
      else arr.push(payload);
      saveDriveImportedList_(arr);
    }

    function hydratePdfStoreFromImportedDrive_() {
      try {
        const arr = loadDriveImportedList_();
        if (!arr.length) return;
        arr.forEach(it => {
          const productName = it.displayName || guessNameFromFilename(it.fileName || '');
          const key = normalizeKey(productName);
          if (!key) return;
          if (pdfStore.has(key)) return;
          pdfStore.set(key, {
            displayName: productName,
            id: it.id,
            fileName: it.fileName || (productName + '.pdf'),
            blobUrl: it.previewUrl || '',
            openUrl: it.openUrl || '',
            sizeBytes: it.sizeBytes || 0,
            updatedAt: it.updatedAt || '',
            source: 'drive'
          });
        });
      } catch (e) {
        console.warn('hydratePdfStoreFromImportedDrive_ failed:', e);
      }
    }

    // ---------------- 本次匯入清單（A 模式：每次匯入覆蓋） ----------------
    function loadCurrentImportedList_() {
      try {
        const raw = localStorage.getItem(CURRENT_IMPORTED_KEY);
        if (!raw) return [];
        const arr = JSON.parse(raw);
        return Array.isArray(arr) ? arr : [];
      } catch (e) { return []; }
    }
    function saveCurrentImportedList_(arr) {
      try { localStorage.setItem(CURRENT_IMPORTED_KEY, JSON.stringify(arr || [])); } catch (e) {}
    }
    function clearCurrentImportedList_() {
      try { localStorage.removeItem(CURRENT_IMPORTED_KEY); } catch (e) {}
    }

    function upsertCurrentImported_(pdfItem) {
      if (!pdfItem) return;
      const productName = (pdfItem.displayName || guessNameFromFilename(pdfItem.fileName || '') || '').trim();
      const key = normalizeKey(productName);
      if (!key) return;

      const list = loadCurrentImportedList_();
      const id = String(pdfItem.id || '');
      const source = String(pdfItem.source || '');
      const fileName = pdfItem.fileName || (productName ? (productName + '.pdf') : '');
      const sizeBytes = Number(pdfItem.sizeBytes || 0);
      const updatedAt = pdfItem.updatedAt || '';

      const entry = { key, id, source, displayName: productName, fileName, sizeBytes, updatedAt, driveKind: pdfItem.driveKind || '' };

      const idx = list.findIndex(x => x && x.key === key);
      if (idx >= 0) list[idx] = entry;
      else list.push(entry);
      saveCurrentImportedList_(list);
    }

    function resetImportContext_() {
      // A 模式：每次匯入覆蓋「本次匯入」資料來源，避免商品名混入舊工廠。
      try { pdfStore.clear(); } catch (e) {}
      lastImportedPdfKey = '';
      try { kpiStore.clear(); } catch (e) {}
      clearCurrentImportedList_();
      // 也清掉舊版 Drive-only 清單，避免混用
      try { localStorage.removeItem(DRIVE_IMPORTED_KEY); } catch (e) {}
      try { clearInlinePdf(); } catch (e) {}
      try { closePdfModal(); } catch (e) {}
    }

    function hydratePdfStoreFromImportedList_() {
      try {
        let arr = loadCurrentImportedList_();
        // Backward-compat: 若新版清單沒有但舊版 Drive-only 有，則遷移一次
        if ((!arr || !arr.length)) {
          const old = loadDriveImportedList_();
          if (old && old.length) {
            arr = old.map(it => ({
              key: normalizeKey(it.displayName || guessNameFromFilename(it.fileName || '') || ''),
              id: String(it.id || ''),
              source: 'drive',
              displayName: it.displayName || guessNameFromFilename(it.fileName || ''),
              fileName: it.fileName || '',
              sizeBytes: Number(it.sizeBytes || 0),
              updatedAt: it.updatedAt || '',
              driveKind: it.driveKind || ''
            })).filter(x => x.key);
            saveCurrentImportedList_(arr);
          }
        }
        if (!arr || !arr.length) return;

        arr.forEach(it => {
          const productName = (it.displayName || guessNameFromFilename(it.fileName || '') || '').trim();
          const key = normalizeKey(productName || it.key || '');
          if (!key) return;
          if (pdfStore.has(key)) return;

          const isDrive = (it.source === 'drive');
          const fileIdOrCacheId = String(it.id || '');
          const fileName = it.fileName || (productName + '.pdf');

          const item = {
            displayName: productName,
            id: fileIdOrCacheId,
            fileName,
            source: isDrive ? 'drive' : 'cache',
            sizeBytes: Number(it.sizeBytes || 0),
            updatedAt: it.updatedAt || ''
          };

          if (isDrive) {
            item.driveKind = it.driveKind || 'pdf';
            item.previewUrl = buildDrivePreviewUrl_(fileIdOrCacheId);
            item.openUrl = buildDriveOpenUrl_(fileIdOrCacheId);
            item.blobUrl = item.previewUrl || '';
          } else {
            item.blobUrl = ''; // on-demand
          }

          pdfStore.set(key, item);
          if (!lastImportedPdfKey) lastImportedPdfKey = key;
        });
      } catch (e) {
        console.warn('hydratePdfStoreFromImportedList_ failed:', e);
      }
    }



    
function saveState() {
      try {
        // 只保存可序列化的表單資料；PDF bytes/Blob URL/排關圖畫筆（pdfAnnoStore）不寫入 localStorage（改存 IndexedDB）
        const payload = {
          active: state.active || 0,
          records: (state.records || []).map(r => ({
            rid: r.rid || '',
            type: r.type || '',
            name: r.name || '',
            productName: r.productName || r.name || '',
            date: r.date || '',
            notesText: r.notesText || '',
            notesInk: r.notesInk || '',
            desc: r.desc || '',
            plannedOutputHr: r.plannedOutputHr || '',
            manHourProductivity: r.manHourProductivity || '',
            packagingEquip: r.packagingEquip || '',
            packagingCapacityHr: r.packagingCapacityHr || '',
            _kpiLastKey: r._kpiLastKey || '',
            images: r.images || [],
            drivePick: r.drivePick || null,
            processStepsRows: r.processStepsRows || [],
            // PDF inline prefs
            pdfZoomFactor: Number(r.pdfZoomFactor || 1),
            pdfAnnoMode: !!r.pdfAnnoMode,
            pdfAnnoTool: r.pdfAnnoTool || 'pen',
            pdfAnnoPenColor: r.pdfAnnoPenColor || '#f97316',
            pdfAnnoPenWidth: Number(r.pdfAnnoPenWidth || 3),
            _activePdfKey: r._activePdfKey || ''
          }))
        };
        localStorage.setItem(STATE_STORAGE_KEY, JSON.stringify(payload));
      } catch (e) {
        console.warn('saveState failed:', e);
      }
    }


    function loadState() {
      try {
        const raw = localStorage.getItem(STATE_STORAGE_KEY);
        if (!raw) return false;
        const payload = JSON.parse(raw);
        if (!payload || !Array.isArray(payload.records)) return false;
        state.records = payload.records;
        state.active = Math.max(0, Math.min(payload.active || 0, state.records.length - 1));
        return true;
      } catch (e) {
        console.warn('loadState failed:', e);
        return false;
      }
    }

    function normalizeState_() {
      if (!state.records || !state.records.length) {
        state.records = [ makeEmptyRecord() ];
        state.active = 0;
        return;
      }
      state.records.forEach(r => {
        if (!r.rid) r.rid = genRid_();
        if (typeof r.pdfZoomFactor !== 'number') r.pdfZoomFactor = Number(r.pdfZoomFactor || 1);
        if (typeof r.pdfAnnoPenWidth !== 'number') r.pdfAnnoPenWidth = Number(r.pdfAnnoPenWidth || 3);
        if (typeof r.pdfAnnoMode !== 'boolean') r.pdfAnnoMode = !!r.pdfAnnoMode;
        if (!r.pdfAnnoTool) r.pdfAnnoTool = 'pen';
        if (!r.pdfAnnoPenColor) r.pdfAnnoPenColor = '#f97316';
        if (!r.productName && r.name) r.productName = r.name;
        if (!r.processStepsRows) r.processStepsRows = [];
        if (!r.images) r.images = [];
        if (!r.pdfAnnoStore) r.pdfAnnoStore = {};
        if (!r._annoLoadedForKey) r._annoLoadedForKey = '';
        if (!r._activePdfKey) r._activePdfKey = '';
        if (!r.notesInk) r.notesInk = '';
        if (!r.notesText) r.notesText = '';
      });
      state.active = Math.max(0, Math.min(state.active || 0, state.records.length - 1));
    }




    // ---------------- 排關圖（PDF）管理 ----------------
    const pdfStore = new Map(); // key: normalized product name -> { displayName, fileName, blobUrl }
    let lastImportedPdfKey = '';


    // ---------------- 自動保存（避免 iOS/行動裝置閒置回收後資料遺失） ----------------
    let _saveStateTimer = null;
    function scheduleSaveState_() {
      try {
        if (_saveStateTimer) clearTimeout(_saveStateTimer);
        _saveStateTimer = setTimeout(() => {
          _saveStateTimer = null;
          saveState();
        }, 250);
      } catch (e) {}
    }

    // ---------------- 排關圖畫筆（IndexedDB，依「表單 rid + 排關圖 key」保存） ----------------
    const _annoSaveTimers = new Map();
    function _annoCacheId_(rid, pdfKey) {
      return String(rid || '') + '::' + String(pdfKey || '');
    }

    async function ensureAnnoLoadedForRecord_(rec, pdfKey) {
      if (!rec || !rec.rid || !pdfKey) return;
      if (rec._annoLoadedForKey === pdfKey && rec.pdfAnnoStore && typeof rec.pdfAnnoStore === 'object') return;
      const id = _annoCacheId_(rec.rid, pdfKey);
      const row = await cacheGetAnno_(id);
      rec.pdfAnnoStore = (row && row.store) ? row.store : {};
      rec._annoLoadedForKey = pdfKey;
    }

    function scheduleAnnoSaveForRecord_(rec, pdfKey) {
      if (!rec || !rec.rid || !pdfKey) return;
      const id = _annoCacheId_(rec.rid, pdfKey);
      if (_annoSaveTimers.has(id)) clearTimeout(_annoSaveTimers.get(id));
      _annoSaveTimers.set(id, setTimeout(async () => {
        _annoSaveTimers.delete(id);
        try {
          await cachePutAnno_(id, rec.pdfAnnoStore || {});
        } catch (e) {}
      }, 600));
    }


    // ---------------- KPI（排關圖欄位）快取 ----------------
    // key: normalizeKey(商品名) -> { plannedOutputHr, manHourProductivity, packagingEquip, packagingCapacityHr, source, updatedAt }
    const kpiStore = new Map();


    
async function importPdfFiles_v2(files) {
      if (!files || !files.length) return;

      // A 模式：本次匯入覆蓋
      resetImportContext_();

      let importedPdf = 0;
      let importedExcel = 0;
      let failedExcel = 0;

      const isPdf = (f) => {
        const name = (f && f.name) ? String(f.name).toLowerCase() : '';
        const t = (f && f.type) ? String(f.type).toLowerCase() : '';
        return t === 'application/pdf' || name.endsWith('.pdf');
      };
      const isExcel = (f) => {
        const name = (f && f.name) ? String(f.name).toLowerCase() : '';
        const t = (f && f.type) ? String(f.type).toLowerCase() : '';
        return name.endsWith('.xlsx') || name.endsWith('.xls') ||
               t === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' ||
               t === 'application/vnd.ms-excel';
      };

      for (const f of files) {
        try {
          const ab = await f.arrayBuffer();

          if (isPdf(f)) {
            const extracted = await extractProductNameFromPdf(ab);
            const displayName = (extracted || guessNameFromFilename(f.name) || '').trim() || '（未命名）';
            const key = normalizeKey(displayName);

            // Use stable cacheId so reload/offline can restore without re-import
            const cacheId = 'localpdf:' + fnv1a32_((f.name || '') + '|' + String(f.size || 0) + '|' + String(f.lastModified || 0));

            // Cache into IndexedDB for offline + reload recovery
            try {
              await cachePutPdf_(cacheId, ab, { name: displayName, sizeBytes: Number(f.size || ab.byteLength || 0), updatedAt: '' });
            } catch (e) {}

            const blobUrl = URL.createObjectURL(new Blob([ab], { type: 'application/pdf' }));
            const prev = pdfStore.get(key);
            if (prev && prev.blobUrl) { try { URL.revokeObjectURL(prev.blobUrl); } catch (e) {} }

            const pdfItem = { displayName, id: cacheId, fileName: f.name, blobUrl, ab, source: 'cache', sizeBytes: Number(f.size || ab.byteLength || 0), updatedAt: '' };
            pdfStore.set(key, pdfItem);

            upsertCurrentImported_(pdfItem);

            // KPI cache (best effort)
            try {
              const kpi = await extractKpiFromPdf(ab);
              if (kpi) kpiStore.set(key, { ...kpi, source: 'pdf', updatedAt: Date.now() });
            } catch (e) {
              console.warn('KPI extract (PDF) failed:', e);
            }

            lastImportedPdfKey = key;
            importedPdf += 1;
            continue;
          }

          if (isExcel(f)) {
            // Excel 版本：優先在「有網路時」就先轉成 PDF 並寫入 IndexedDB（避免離線/刷新後無法再轉）
            const displayName0 = (guessNameFromFilename(f.name) || '').trim();
            const displayName = displayName0 ? displayName0 : '（Excel→PDF）';
            const key = normalizeKey(displayName);

            const cacheId = 'localexcelpdf:' + fnv1a32_((f.name || '') + '|' + String(f.size || ab.byteLength || 0) + '|' + String(f.lastModified || 0));

            let pdfAb = null;
            try {
              pdfAb = await __excelArrayBufferToPdf_(ab, { title: displayName });
            } catch (e) {
              failedExcel += 1;
              console.warn('Excel -> PDF 轉換失敗：', e);
            }

            if (pdfAb) {
              try {
                await cachePutPdf_(cacheId, pdfAb, { name: displayName, sizeBytes: Number(pdfAb.byteLength || 0), updatedAt: '' });
              } catch (e) {}
              const blobUrl = URL.createObjectURL(new Blob([pdfAb], { type: 'application/pdf' }));
              const prev = pdfStore.get(key);
              if (prev && prev.blobUrl) { try { URL.revokeObjectURL(prev.blobUrl); } catch (e) {} }
              const pdfItem = { displayName, id: cacheId, fileName: f.name, blobUrl, ab: pdfAb, source: 'cache', sizeBytes: Number(pdfAb.byteLength || 0), updatedAt: '' };
              pdfStore.set(key, pdfItem);
              upsertCurrentImported_(pdfItem);
              lastImportedPdfKey = key;
              importedExcel += 1;
            } else {
              // Fallback: keep as excel in-memory (reload/offline may not work)
              pdfStore.set(key, { displayName: displayName + '（Excel→PDF）', fileName: f.name, excelAb: ab, source: 'excel' });
              lastImportedPdfKey = key;
              importedExcel += 1;
            }

            // KPI cache (best effort)
            try {
              const kpi = await extractKpiFromExcel(ab);
              if (kpi) {
                kpiStore.set(key, { ...kpi, source: 'excel', updatedAt: Date.now() });
                if (kpi.productName) {
                  const k2 = normalizeKey(kpi.productName);
                  if (k2 && k2 !== key) kpiStore.set(k2, { ...kpi, source: 'excel', updatedAt: Date.now() });
                }
              }
            } catch (e) {
              console.warn('KPI extract (Excel) failed:', e);
            }
            continue;
          }

          // Unknown file type: ignore silently
        } catch (e) {
          console.warn('import schedule failed:', f && f.name, e);
        }
      }

      alert(`已匯入排關圖：PDF ${importedPdf} 份、Excel ${importedExcel} 份` + (failedExcel ? `（其中 ${failedExcel} 份 Excel 轉檔失敗，刷新/離線可能無法顯示）` : ''));
      try { refreshAllProcessStrips(); } catch (e) {}
      try { refreshAllKpiPanels(); } catch (e) {}

      scheduleSaveState_();
    }


    function fnv1a32_(str) {
      str = String(str || '');
      let h = 0x811c9dc5;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        // h *= 16777619 (FNV prime) with overflow
        h = (h + ((h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24))) >>> 0;
      }
      return ('00000000' + h.toString(16)).slice(-8);
    }




    // ---------------- 內容記錄：手寫畫布（支援觸控筆） ----------------
    function getCanvasCssSize(canvas) {
      const rect = canvas.getBoundingClientRect();
      // IMPORTANT: allow 0 when hidden/not mounted.
      // We must not clamp to 1 here; otherwise hidden panels may be resized to 1x1 and effectively wipe ink.
      const w = Math.round(rect.width);
      const h = Math.round(rect.height);
      return { w, h };
    }

    function prepareCanvasContext(canvas) {
      const ctx = canvas.getContext('2d', { willReadFrequently: false });
      // Default pen style
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = '#111111';
      ctx.lineWidth = 2.2;
      return ctx;
    }

    function resizeCanvas(canvas, preservedDataUrl) {
      const dpr = window.devicePixelRatio || 1;
      const { w: cssW, h: cssH } = getCanvasCssSize(canvas);

      // If hidden/unmounted, defer resizing/restoring to avoid shrinking to 1x1.
      if (!cssW || !cssH || cssW < 2 || cssH < 2) {
        if (preservedDataUrl) canvas._pendingInk = preservedDataUrl;
        return;
      }

      const pxW = Math.max(1, Math.round(cssW * dpr));
      const pxH = Math.max(1, Math.round(cssH * dpr));

      if (canvas.width === pxW && canvas.height === pxH) {
        // Even if size unchanged, we may still need to apply pending ink when becoming visible.
        if (!preservedDataUrl && canvas._pendingInk) {
          const pending = canvas._pendingInk;
          canvas._pendingInk = '';
          restoreCanvasFromDataUrl(canvas, pending);
        }
        return;
      }

      canvas.width = pxW;
      canvas.height = pxH;

      const ctx = prepareCanvasContext(canvas);
      // Map drawing coordinates to CSS pixels
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // White background (so exported PNG won't be transparent)
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(0, 0, cssW, cssH);

      const ink = preservedDataUrl || canvas._pendingInk || '';
      if (ink) {
        canvas._pendingInk = '';
        restoreCanvasFromDataUrl(canvas, ink);
      }
    }

    function restoreCanvasFromDataUrl(canvas, dataUrl) {
      if (!dataUrl) return;
      const dpr = window.devicePixelRatio || 1;

      // Mark restoring to avoid observers capturing a half-painted canvas.
      canvas._isRestoringInk = true;

      const img = new Image();
      img.onload = () => {
        try {
          const { w: cssW, h: cssH } = getCanvasCssSize(canvas);
          // If still hidden, keep it pending and draw later.
          if (!cssW || !cssH || cssW < 2 || cssH < 2) {
            canvas._pendingInk = dataUrl;
            canvas._isRestoringInk = false;
            return;
          }

          const ctx = prepareCanvasContext(canvas);
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          // Ensure background is white
          ctx.fillStyle = '#FFFFFF';
          ctx.fillRect(0, 0, cssW, cssH);
          ctx.drawImage(img, 0, 0, cssW, cssH);
        } finally {
          canvas._isRestoringInk = false;
        }
      };
      img.onerror = () => { canvas._isRestoringInk = false; };
      img.src = dataUrl;
    }

    function clearNotesCanvas(canvas, opts = {}) {
      const dpr = window.devicePixelRatio || 1;
      const { w: cssW, h: cssH } = getCanvasCssSize(canvas);
      const ctx = prepareCanvasContext(canvas);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(0, 0, cssW, cssH);

      if (opts && opts.save && typeof opts.idx === 'number') {
        state.records[opts.idx].notesInk = canvas.toDataURL('image/png');
      }
    }


    // Registry: avoid leaking multiple window resize listeners after re-render
    const _notesCanvasRegistry = new Set();
    let _notesResizeHooked = false;

    function _ensureNotesResizeHook() {
      if (_notesResizeHooked) return;
      _notesResizeHooked = true;

      let t = null;
      window.addEventListener('resize', () => {
        if (t) clearTimeout(t);
        t = setTimeout(() => {
          for (const cv of Array.from(_notesCanvasRegistry)) {
            // Remove stale nodes
            if (!document.body.contains(cv)) {
              _notesCanvasRegistry.delete(cv);
              continue;
            }
            const i = Number(cv.dataset.notesIdx || '');
            const keep = (state.records[i] && state.records[i].notesInk) ? state.records[i].notesInk : '';
            resizeCanvas(cv, keep);
          }
        }, 120);
      });
    }

    function initNotesCanvas(canvas, idx) {
      // Prevent duplicate binding (in case of accidental re-init)
      if (canvas.dataset.inkBound === '1') return;
      canvas.dataset.inkBound = '1';

      // Ensure correct bitmap size
      const preserved = state.records[idx] && state.records[idx].notesInk ? state.records[idx].notesInk : '';
      requestAnimationFrame(() => resizeCanvas(canvas, preserved));

      // Keep canvas crisp on resize (single global listener)
      canvas.dataset.notesIdx = String(idx);
      _notesCanvasRegistry.add(canvas);
      _ensureNotesResizeHook();

      // Observe element resize (e.g., user drags the resizer on the canvas box)
      const boxEl = canvas.closest('.notesCanvasBox') || canvas.parentElement;

      // Custom resize handle (drag to change height) — avoids conflict with drawing on the canvas
      if (boxEl && !boxEl._notesResizeHandleBound) {
        const handle = boxEl.querySelector('.notesResizeHandle');
        if (handle) {
          let startY = 0;
          let startH = 0;
          const onMove = (e) => {
            const dy = (e.clientY - startY);
            let next = startH + dy;
            const minH = 260;
            const maxH = Math.round(window.innerHeight * 0.8);
            if (next < minH) next = minH;
            if (next > maxH) next = maxH;
            boxEl.style.height = next + 'px';
          };
          const onUp = () => {
            window.removeEventListener('pointermove', onMove);
            window.removeEventListener('pointerup', onUp);
          };
          handle.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            startY = e.clientY;
            startH = Math.round(boxEl.getBoundingClientRect().height || 0);
            try { handle.setPointerCapture(e.pointerId); } catch (err) {}
            window.addEventListener('pointermove', onMove);
            window.addEventListener('pointerup', onUp);
          });
        }
        boxEl._notesResizeHandleBound = true;
      }

      if (boxEl && typeof ResizeObserver !== 'undefined' && !canvas._notesResizeObserver) {
        let roT = null;
        const ro = new ResizeObserver(() => {
          if (canvas._isDrawing) return; // do not resize/repaint while user is drawing (prevents tool glitches)
          if (roT) clearTimeout(roT);
          roT = setTimeout(() => {
            // When panel is hidden (display:none), the canvas box size becomes 0.
            // Resizing at that time would shrink the canvas to 1x1 and effectively wipe the drawing.
            // Therefore, skip resize/persist until the element is visible again.
            const _sz = getCanvasCssSize(canvas);
            if (!_sz || !_sz.w || !_sz.h || _sz.w < 2 || _sz.h < 2) return;

            const i = Number(canvas.dataset.notesIdx || idx);

            // If an async restore is in progress, do not snapshot toDataURL (can be blank/partial).
            if (canvas._isRestoringInk) {
              const keep = (state.records[i] && state.records[i].notesInk) ? state.records[i].notesInk : (canvas._pendingInk || '');
              resizeCanvas(canvas, keep);
            } else {
              // Preserve current ink if visible; otherwise fall back to stored ink.
              let inkNow = '';
              try {
                if (canvas.width > 20 && canvas.height > 20) inkNow = canvas.toDataURL('image/png');
              } catch (err) {}
              const keep = inkNow || ((state.records[i] && state.records[i].notesInk) ? state.records[i].notesInk : (canvas._pendingInk || ''));
              resizeCanvas(canvas, keep);
            }
            // NOTE: Do NOT persist notesInk here. During mount/re-render the image restore is async;
            // persisting toDataURL at this moment can overwrite existing ink with a blank canvas.
            // Save box height so it persists per item
            try {
              const h = Math.round((boxEl.getBoundingClientRect().height || 0));
              if (h > 0 && state.records[i]) state.records[i].notesBoxH = h;
            } catch (err) {}
          }, 120);
        });
        ro.observe(boxEl);
        canvas._notesResizeObserver = ro;
      }
const ctx = prepareCanvasContext(canvas);

      let drawing = false;
      canvas._isDrawing = false;
      let lastX = 0;
      let lastY = 0;
      let activePointerId = null;

      const getPos = (e) => {
        const rect = canvas.getBoundingClientRect();
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
      };

      canvas.addEventListener('pointerdown', (e) => {
        // Mouse: only left button; Pen/Touch: allow
        if (e.pointerType === 'mouse' && e.button !== 0) return;

        e.preventDefault();
        drawing = true;
        canvas._isDrawing = true;
        activePointerId = e.pointerId;
        try { canvas.setPointerCapture(activePointerId); } catch (err) {}

        // Tool mode: pen / eraser
        // - pen: normal ink
        // - eraser: removes ink (destination-out) so it works regardless of background color
        const tool = (canvas.dataset.notesTool || ((state.records[idx] && state.records[idx].notesTool) ? state.records[idx].notesTool : 'pen'));
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        if (tool === 'eraser') {
          ctx.globalCompositeOperation = 'destination-out';
          ctx.lineWidth = 22;
        } else {
          ctx.globalCompositeOperation = 'source-over';
          ctx.strokeStyle = '#111111';
          ctx.lineWidth = 2.2;
        }
// Make sure we are using current DPR transform
        const dpr = window.devicePixelRatio || 1;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        const p = getPos(e);
        lastX = p.x;
        lastY = p.y;

        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
      });

      canvas.addEventListener('pointermove', (e) => {
        if (!drawing) return;
        if (activePointerId !== null && e.pointerId !== activePointerId) return;

        e.preventDefault();
        const p = getPos(e);

        ctx.lineTo(p.x, p.y);
        ctx.stroke();

        // Start new segment to reduce long path memory
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);

        lastX = p.x;
        lastY = p.y;
      });

      const end = (e) => {
        if (!drawing) return;
        if (activePointerId !== null && e.pointerId !== activePointerId) return;

        drawing = false;
        canvas._isDrawing = false;
        try { canvas.releasePointerCapture(activePointerId); } catch (err) {}
        activePointerId = null;

        // Persist to record only once per stroke
        if (state.records[idx]) {
          state.records[idx].notesInk = canvas.toDataURL('image/png');
        }
      };

      canvas.addEventListener('pointerup', end);
      canvas.addEventListener('pointercancel', end);
      canvas.addEventListener('pointerleave', (e) => {
        // Do not end drawing on leave if pointer is captured
      });
    }

    function guessNameFromFilename(fileName) {
      const base = (fileName || '').replace(/\.pdf$/i, '');
      // 例： "1.義式番茄起司義大利麵" -> "義式番茄起司義大利麵"
      return base.replace(/^\s*\d+\s*[\.\-、_ ]\s*/,'').trim() || base.trim();
    }

    function normalizeKey(s) {
      const t = (s || '').toString().trim();
      return t
        .replace(/\s+/g, '')
        .replace(/[()（）【】\[\]{}「」『』"“”'’`·•‧,，.。:：;；!！?？\/\\|｜\-—_]/g, '')
        .toLowerCase();
    }


    

// ------------------------------
// PDF text helpers (for product name extraction)
// ------------------------------
function __normPdfStr_(s){
  return String(s || "")
    .replace(/\s+/g, "")
    .replace(/（/g, "(").replace(/）/g, ")")
    .replace(/：/g, ":")
    .trim();
}

/**
 * Group PDF.js text items into lines based on Y coordinate.
 * items: [{str,x,y}]
 * return: [{y, tokens:[...], text, norm}]
 */
function groupTextItemsByLine_(items, yTol){
  const Y_TOL = (typeof yTol === "number") ? yTol : 2.6;
  const arr = Array.isArray(items) ? items.slice() : [];
  arr.sort((a,b)=> (b.y - a.y) || (a.x - b.x));

  const lines = [];
  for (const it of arr){
    let line = null;
    for (const l of lines){
      if (Math.abs(l.y - it.y) <= Y_TOL){ line = l; break; }
    }
    if (!line){
      line = { y: it.y, tokens: [] };
      lines.push(line);
    }
    line.tokens.push(it);
  }
  for (const l of lines){
    l.tokens.sort((a,b)=> a.x - b.x);
    l.text = l.tokens.map(t=>String(t.str||"").trim()).join("");
    l.norm = __normPdfStr_(l.text);
  }
  lines.sort((a,b)=> b.y - a.y);
  return lines;
}

/**
 * Pick value to the right of a label from grouped lines.
 * labels: array of label strings, e.g. ['商品名稱']
 * mode: 'text' (default) - returns concatenated string after label
 */
function pickValueRightOfLabel_(lines, labels, mode){
  const lbs = (labels || []).map(__normPdfStr_).filter(Boolean);
  if (!lbs.length) return "";

  const stopHeaders = new Set([
    __normPdfStr_("生產列數"),
    __normPdfStr_("作成日"),
    __normPdfStr_("產線配置圖"),
    __normPdfStr_("主食"),
  ]);

  for (let idx=0; idx<(lines||[]).length; idx++){
    const line = lines[idx];
    const toks = (line && line.tokens) ? line.tokens : [];
    if (!toks.length) continue;

    // build per-token normalized string
    const tNorm = toks.map(t=>__normPdfStr_(t.str));
    const joined = tNorm.join("");

    for (const lb of lbs){
      if (!joined.includes(lb)) continue;

      // find label span [i..j] across tokens
      let found = null;
      for (let i=0; i<tNorm.length; i++){
        let acc = "";
        for (let j=i; j<Math.min(i+10, tNorm.length); j++){
          acc += tNorm[j];
          if (acc === lb || acc.includes(lb)){
            // ensure lb starts within acc; accept
            found = { i, j };
            break;
          }
        }
        if (found) break;
      }
      if (!found) continue;

      // collect tokens after label
      const out = [];
      for (let k=found.j+1; k<toks.length; k++){
        const raw = String(toks[k].str || "").trim();
        const n = __normPdfStr_(raw);
        if (!raw) continue;
        if (raw === ":" || raw === "：" || raw === "-" ) continue;
        if (stopHeaders.has(n)) break;
        // if we hit another known label, stop
        if (n.includes(__normPdfStr_("生產列數"))) break;
        out.push(raw);
      }

      let val = out.join("").trim();
      if (!val){
        // fallback: sometimes value is on next line, take first non-empty token
        const next = lines[idx+1];
        if (next && next.tokens && next.tokens.length){
          for (const tk of next.tokens){
            const raw = String(tk.str || "").trim();
            if (raw){ val = raw; break; }
          }
        }
      }

      if (mode === "text" || !mode) return val;
      return val;
    }
  }
  return "";
}

async function extractProductNameFromPdf(arrayBuffer) {
  const ok = await ensurePdfJsLoaded();
  if (!ok || !window.pdfjsLib) return '';

  try {
    const loadingTask = window.pdfjsLib.getDocument({ data: arrayBuffer });
    const pdf = await loadingTask.promise;
    const page = await pdf.getPage(1);
    const tc = await page.getTextContent();
    const items = (tc.items || []).map(it => ({
      str: (it.str || '').toString(),
      x: (it.transform && it.transform[4]) ? Number(it.transform[4]) : 0,
      y: (it.transform && it.transform[5]) ? Number(it.transform[5]) : 0
    })).filter(it => it.str && it.str.trim());

    const lines = groupTextItemsByLine_(items);
    let name = pickValueRightOfLabel_(lines, ['商品名稱'], 'text') || '';
    name = String(name || '').trim();

    // avoid accidentally attaching other header fields
    name = name.replace(/生產列數.*$/,'').trim();

    // Some PDFs may include trailing digits or symbols; keep readable Chinese/English/numbers
    name = name.replace(/\s+/g,' ').trim();

    return name;
  } catch (e) {
    console.warn('extractProductNameFromPdf failed', e);
    return '';
  }
}

// ------------------------------
// KPI extraction helpers (from schedule PDF / Excel)
// ------------------------------
function __cleanNumText_(s) {
  return String(s ?? '').replace(/,/g, '').trim();
}

function __firstNumberText_(s) {
  const t = String(s ?? '');
  const m = t.match(/-?\d+(?:,\d{3})*(?:\.\d+)?/);
  return m ? __cleanNumText_(m[0]) : '';
}

function __findLabelInLines_(lines, label) {
  const lb = __normPdfStr_(label);
  if (!lb) return null;
  for (let li = 0; li < (lines || []).length; li++) {
    const line = lines[li];
    const toks = (line && line.tokens) ? line.tokens : [];
    if (!toks.length) continue;
    const tNorm = toks.map(t => __normPdfStr_(t.str));
    const joined = tNorm.join('');
    if (!joined.includes(lb)) continue;

    // locate token span that contains label
    let found = null;
    for (let i = 0; i < tNorm.length; i++) {
      let acc = '';
      for (let j = i; j < Math.min(i + 12, tNorm.length); j++) {
        acc += tNorm[j];
        if (acc === lb || acc.includes(lb)) {
          found = { i, j };
          break;
        }
      }
      if (found) break;
    }
    if (!found) continue;

    const xs = toks.slice(found.i, found.j + 1).map(t => Number(t.x || 0));
    const xMin = xs.length ? Math.min(...xs) : Number(toks[0].x || 0);
    const xMax = xs.length ? Math.max(...xs) : Number(toks[toks.length - 1].x || 0);
    const xCenter = (xMin + xMax) / 2;
    return { lineIndex: li, xCenter, y: Number(line.y || 0) };
  }
  return null;
}

function __pickNearestTokenBelow_(items, anchor, predicate, opts = {}) {
  if (!anchor || !items || !items.length) return null;
  const yMaxGap = Number(opts.yMaxGap ?? 220);  // how far below we search
  const xMaxGap = Number(opts.xMaxGap ?? 260);
  const wX = Number(opts.wX ?? 0.22);          // x distance weight

  const ax = Number(anchor.xCenter || 0);
  const ay = Number(anchor.y || 0);

  let best = null;
  let bestScore = Infinity;

  for (const it of items) {
    const x = Number(it.x || 0);
    const y = Number(it.y || 0);
    const dy = (ay - y);
    if (!(dy > 0 && dy <= yMaxGap)) continue; // must be below
    const dx = Math.abs(x - ax);
    if (dx > xMaxGap) continue;
    if (predicate && !predicate(it)) continue;

    const score = dy + (dx * wX);
    if (score < bestScore) {
      bestScore = score;
      best = it;
    }
  }
  return best;
}

function __pickNearestTokenRight_(items, anchor, predicate, opts = {}) {
  if (!anchor || !items || !items.length) return null;
  const yTol = Number(opts.yTol ?? 10);
  const xMaxGap = Number(opts.xMaxGap ?? 520);
  const minDx = Number(opts.minDx ?? 8);
  const ax = Number(anchor.xCenter || 0);
  const ay = Number(anchor.y || 0);

  let best = null;
  let bestScore = Infinity;

  for (const it of items) {
    const x = Number(it.x || 0);
    const y = Number(it.y || 0);
    const dy = Math.abs(y - ay);
    if (dy > yTol) continue;
    const dx = x - ax;
    if (dx <= minDx) continue;
    if (dx > xMaxGap) continue;
    if (predicate && !predicate(it)) continue;

    // score prioritizes horizontal closeness, then vertical alignment
    const score = dx + dy * 0.15;
    if (score < bestScore) {
      bestScore = score;
      best = it;
    }
  }
  return best;
}

function __toNum_(s) {
  const n = parseFloat(__cleanNumText_(s));
  return Number.isFinite(n) ? n : NaN;
}

function __isValidPlannedOut_(s) {
  const n = __toNum_(s);
  return Number.isFinite(n) && n >= 50;
}

function __isValidManHour_(s) {
  const n = __toNum_(s);
  return Number.isFinite(n) && n >= 10;
}

async function extractKpiFromPdf(arrayBuffer) {
  const ok = await ensurePdfJsLoaded();
  if (!ok || !window.pdfjsLib) return null;

  try {
    const loadingTask = window.pdfjsLib.getDocument({ data: arrayBuffer });
    const pdf = await loadingTask.promise;
    const page = await pdf.getPage(1);
    const tc = await page.getTextContent();

    const items = (tc.items || []).map(it => ({
      str: (it.str || '').toString(),
      x: (it.transform && it.transform[4]) ? Number(it.transform[4]) : 0,
      y: (it.transform && it.transform[5]) ? Number(it.transform[5]) : 0
    })).filter(it => it.str && it.str.trim());

    const lines = groupTextItemsByLine_(items);

    // Anchors (labels) — some tables place numeric values on the next line and in different columns.
    const aPlanned = __findLabelInLines_(lines, '預計產量(1小時)') || __findLabelInLines_(lines, '預計產量');
    const aManHour = __findLabelInLines_(lines, '人時生產性') || __findLabelInLines_(lines, '人時產能');
    const aPackEq  = __findLabelInLines_(lines, '包裝設備');
    const aPackCap = __findLabelInLines_(lines, '包裝機台產能(hr)') || __findLabelInLines_(lines, '包裝機台產能');

    const isNumericTok = (it) => /\d/.test(String(it.str || ''));

    // Planned output: prefer value to the right on the same row; fallback to nearest-right token; last resort nearest-below
    let planned = '';
    planned = __firstNumberText_(pickValueRightOfLabel_(lines, ['預計產量(1小時)', '預計產量'], 'text'));
    if (!__isValidPlannedOut_(planned) && aPlanned) {
      const tokR = __pickNearestTokenRight_(items, aPlanned, isNumericTok, { yTol: 12, xMaxGap: 560, minDx: 10 });
      planned = tokR ? __firstNumberText_(tokR.str) : planned;
    }
    if (!__isValidPlannedOut_(planned) && aPlanned) {
      const tokB = __pickNearestTokenBelow_(items, aPlanned, isNumericTok, { yMaxGap: 260, xMaxGap: 360, wX: 0.30 });
      planned = tokB ? __firstNumberText_(tokB.str) : planned;
    }
    if (!__isValidPlannedOut_(planned)) planned = '';

    // Man-hour productivity: prefer value to the right on the same row; fallback to nearest-right token; last resort nearest-below
    let manHour = '';
    manHour = __firstNumberText_(pickValueRightOfLabel_(lines, ['人時生產性', '人時產能'], 'text'));
    if (!__isValidManHour_(manHour) && aManHour) {
      const tokR = __pickNearestTokenRight_(items, aManHour, isNumericTok, { yTol: 12, xMaxGap: 560, minDx: 10 });
      manHour = tokR ? __firstNumberText_(tokR.str) : manHour;
    }
    if (!__isValidManHour_(manHour) && aManHour) {
      const tokB = __pickNearestTokenBelow_(items, aManHour, isNumericTok, { yMaxGap: 260, xMaxGap: 360, wX: 0.34 });
      manHour = tokB ? __firstNumberText_(tokB.str) : manHour;
    }
    if (!__isValidManHour_(manHour)) manHour = '';

    // Packaging equipment (text)
    let packEq = '';
    if (aPackEq) {
      packEq = (pickValueRightOfLabel_(lines, ['包裝設備'], 'text') || '').trim();
    } else {
      packEq = (pickValueRightOfLabel_(lines, ['包裝設備'], 'text') || '').trim();
    }

    // Packaging machine capacity: right-of label, else nearest numeric below
    let packCap = __firstNumberText_(pickValueRightOfLabel_(lines, ['包裝機台產能(hr)', '包裝機台產能'], 'text'));
    if (!packCap && aPackCap) {
      const tok = __pickNearestTokenBelow_(items, aPackCap, isNumericTok, { yMaxGap: 260, xMaxGap: 320, wX: 0.28 });
      packCap = tok ? __firstNumberText_(tok.str) : '';
    }

    const out = {
      plannedOutputHr: planned || '',
      manHourProductivity: manHour || '',
      packagingEquip: packEq || '',
      packagingCapacityHr: packCap || ''
    };

    // If all empty, treat as not found
    if (!out.plannedOutputHr && !out.manHourProductivity && !out.packagingEquip && !out.packagingCapacityHr) {
      return null;
    }

    return out;
  } catch (e) {
    console.warn('extractKpiFromPdf failed', e);
    return null;
  }
}

async function extractKpiFromExcel(arrayBuffer) {
  const ok = await ensureXlsxLoaded();
  if (!ok || !window.XLSX) return null;

  try {
    const wb = window.XLSX.read(arrayBuffer, { type: 'array' });
    const sheetName = wb.SheetNames && wb.SheetNames.length ? wb.SheetNames[0] : null;
    if (!sheetName) return null;
    const ws = wb.Sheets[sheetName];
    if (!ws) return null;

    const aoa = window.XLSX.utils.sheet_to_json(ws, { header: 1, raw: false, defval: '' });

    const norm = (s) => String(s ?? '')
      .replace(/\s+/g, '')
      .replace(/（/g, '(').replace(/）/g, ')')
      .replace(/：/g, ':')
      .trim();

    const findRightValue = (labels) => {
      const lbs = (labels || []).map(norm).filter(Boolean);
      if (!lbs.length) return '';
      for (const row of (aoa || [])) {
        if (!Array.isArray(row)) continue;
        for (let c = 0; c < row.length; c++) {
          const cell = norm(row[c]);
          if (!cell) continue;
          const hit = lbs.some(lb => lb && cell.includes(lb));
          if (!hit) continue;

          for (let j = c + 1; j < Math.min(c + 10, row.length); j++) {
            const v = String(row[j] ?? '').trim();
            if (v) return v;
          }
        }
      }
      return '';
    };

    const productName = (findRightValue(['商品名稱', '品名']) || '').trim();
    const plannedText = findRightValue(['預計產量(1小時)', '預計產量(1小時)', '預計產量']);
    const manHourText = findRightValue(['人時生產性', '人時產能']);
    const packEqText  = findRightValue(['包裝設備']);
    const packCapText = findRightValue(['包裝機台產能(hr)', '包裝機台產能']);

    const planned = __firstNumberText_(plannedText);
    const manHour = __firstNumberText_(manHourText);
    const packCap = __firstNumberText_(packCapText);

    const out = {
      productName: productName || '',
      plannedOutputHr: planned || '',
      manHourProductivity: manHour || '',
      packagingEquip: (packEqText || '').trim(),
      packagingCapacityHr: packCap || ''
    };

    if (!out.productName && !out.plannedOutputHr && !out.manHourProductivity && !out.packagingEquip && !out.packagingCapacityHr) {
      return null;
    }

    return out;
  } catch (e) {
    console.warn('extractKpiFromExcel failed', e);
    return null;
  }
}



function pdfListText() {
      const names = Array.from(pdfStore.values()).map(v => v.displayName).filter(Boolean);
      return names.length ? names.join('、') : '（無）';
    }

    async function importPdfFiles(files) {
      return await importPdfFiles_v2(files);
    }

    function refreshAllProcessStrips() {
      try {
        const panels = document.querySelectorAll('#panels .panel');
        panels.forEach(p => {
          if (p && typeof p.__refreshProcessStrip === 'function') {
            try { p.__refreshProcessStrip(); } catch (e) {}
          }
        });
      } catch (e) {}
    }

    function refreshAllKpiPanels() {
      try {
        const panels = document.querySelectorAll('#panels .panel');
        panels.forEach(p => {
          if (p && typeof p.__refreshKpiPanel === 'function') {
            try { p.__refreshKpiPanel(true); } catch (e) {}
          }
        });
      } catch (e) {}
    }



    function findPdfForProductName(productName) {
      const name = (productName || '').toString().trim();
      const key = normalizeKey(name);

      // Exact
      if (key && pdfStore.has(key)) return pdfStore.get(key);

      // Fuzzy include
      if (key) {
        for (const [k, v] of pdfStore.entries()) {
          if (k && (k.includes(key) || key.includes(k))) return v;
        }
      }

      // If only one PDF exists, use it (avoid name mismatch / empty name causing false "no data")
      if (pdfStore.size === 1) return Array.from(pdfStore.values())[0];

      // Prefer the most recently imported PDF as a fallback
      if (lastImportedPdfKey && pdfStore.has(lastImportedPdfKey)) return pdfStore.get(lastImportedPdfKey);

      // Last resort: pick best match by common characters (when names are similar but not equal)
      if (key && pdfStore.size > 1) {
        let best = null;
        let bestScore = -1;
        for (const [k, v] of pdfStore.entries()) {
          if (!k) continue;
          let score = 0;
          if (k === key) score += 1000;
          if (k.includes(key) || key.includes(k)) score += 500;

          // common chars
          const setB = new Set(String(k).split(''));
          let common = 0;
          for (const ch of String(key)) if (setB.has(ch)) common += 1;
          score += common;

          // slight boost if original filename contains raw name
          if (v && v.fileName && name && String(v.fileName).includes(name)) score += 50;

          if (score > bestScore) { bestScore = score; best = v; }
        }
        if (best) return best;
      }

      return null;
    }



    
// ---------------- 作業工程擷取（排關圖 PDF -> 轉可編輯表格） ----------------
const processTableCache = new Map();     // key -> { ok, data, previewDataUrl, message }
const processTableInflight = new Map();  // key -> Promise<result>

// 若未能從文字內容推估裁切位置，使用此預設裁切（盡量涵蓋整張排關圖的「作業工程」表格區）
const PROCESS_CROP_FALLBACK = { x: 0.03, y: 0.05, w: 0.94, h: 0.90 };

function processTableKey(pdfItem) {
  if (!pdfItem) return '';
  if (pdfItem.source === 'drive' && pdfItem.id) return 'drive:' + String(pdfItem.id);
  return 'local:' + String(pdfItem.fileName || pdfItem.displayName || '');
}


async function downloadDrivePdfArrayBufferChunked_(fileId, sizeBytes) {
  const baseUrl = DRIVE_EXEC_URL;
  if (!baseUrl) throw new Error('DRIVE_EXEC_URL 未設定');

  const totalBytes = Number(sizeBytes || 0);

  async function directDownloadOnce_() {
    const url = baseUrl + (baseUrl.indexOf('?') >= 0 ? '&' : '?') +
                'action=download&id=' + encodeURIComponent(String(fileId));

    const res = await jsonpRequest(url, 35000);
    if (!res || !res.ok) throw new Error((res && res.message) ? res.message : 'download failed');

    let b64 = res.base64 || res.data || res.fileBase64 || res.content || '';
    b64 = stripDataUrlPrefix(b64);
    if (!b64) throw new Error('No base64 payload');

    const u8 = base64ToUint8Array(b64);
    return u8.buffer;
  }

  // 小檔案：優先整包 download（只要 1 次 JSONP，通常比多次 downloadChunk 快很多）
  // 註：Apps Script 端有 8MB 上限；此處保守抓 2MB 以避免過大的 JSONP payload 造成 load error。
  const DIRECT_MAX = 2 * 1024 * 1024;
  if (!totalBytes || totalBytes <= DIRECT_MAX) {
    try {
      return await directDownloadOnce_();
    } catch (e) {
      // 下載整包失敗（或後端回應過大/其他錯誤）再退回分段
    }
  }

  // 大檔案：分段 downloadChunk。為了縮短總耗時，先用較大的 chunk，若遇到 load error 再降級。
  const LIMITS = [360000, 240000, 120000]; // 皆為 3 的倍數，避免 base64 邊界問題
  let lastErr = null;

  for (let li = 0; li < LIMITS.length; li++) {
    const BYTES_PER_CHUNK = LIMITS[li];
    try {
      let offset = 0;
      let parts = [];
      let loops = 0;

      while (true) {
        loops += 1;
        if (loops > 20000) throw new Error('chunk too many');

        const url = baseUrl + (baseUrl.indexOf('?') >= 0 ? '&' : '?')
          + 'action=downloadChunk'
          + '&id=' + encodeURIComponent(String(fileId))
          + '&offset=' + encodeURIComponent(offset)
          + '&limit=' + encodeURIComponent(BYTES_PER_CHUNK);

        const res = await jsonpRequest(url, 45000);
        if (!res || !res.ok) throw new Error((res && res.message) ? res.message : 'downloadChunk failed');

        const chunkB64 = stripDataUrlPrefix(res.chunkBase64 || res.base64Chunk || res.chunk || res.data || '');
        if (chunkB64) parts.push(chunkB64);

        const done = !!(res.done || res.isLast);
        const chunkBytes = Number(res.chunkBytes || 0);

        if (chunkBytes > 0) {
          offset = Number(res.offset || offset) + chunkBytes;
        } else {
          offset = offset + BYTES_PER_CHUNK;
        }

        if (done) break;
        if (totalBytes && offset >= totalBytes) break;
      }

      const b64 = parts.join('');
      if (!b64) throw new Error('No chunk base64 payload');

      const u8 = base64ToUint8Array(b64);
      return u8.buffer;

    } catch (e) {
      lastErr = e;
      // 常見：chunk 太大導致 JSONP script load error。降級 chunk size 再試。
      continue
    }
  }

  // 最後保底：再試一次整包 download（可能是 chunk 端回應格式異常）
  try {
    return await directDownloadOnce_();
  } catch (e2) {
    throw (lastErr || e2);
  }
}


/* =========================
   Excel 排關圖：離線轉 PDF（顯示排關圖時才轉換）
   - 目的：維持既有「顯示排關圖 / PDF.js 渲染 / 標註 / 下載PDF」流程不變
   - 限制：前端 XLSX 解析不保證還原 Excel 的色彩/字型/圖片；此轉換以「表格/合併儲存格/文字」為主
========================= */
function __excelIsSupported_(pdfItem){
  return !!(pdfItem && (pdfItem.source === 'excel' || pdfItem.excelAb) && pdfItem.excelAb);
}

function __sum_(arr, a, b){
  let s = 0;
  for (let i = a; i < b; i++) s += (Number(arr[i]) || 0);
  return s;
}

function __isValidPdfAb_(ab){
  try{
    if (!ab) return false;
    const u8 = (ab instanceof Uint8Array) ? ab : new Uint8Array(ab);
    if (u8.length < 5) return false;
    // "%PDF-"
    return (u8[0] === 0x25 && u8[1] === 0x50 && u8[2] === 0x44 && u8[3] === 0x46 && u8[4] === 0x2D);
  } catch (_) {
    return false;
  }
}

async function __jsPdfOutputArrayBufferSafe_(doc){
  // 1) arraybuffer
  try {
    const out = doc.output('arraybuffer');
    if (__isValidPdfAb_(out)) return out;
  } catch (_) {}

  // 2) blob -> arrayBuffer
  try {
    const blob = doc.output('blob');
    if (blob && typeof blob.arrayBuffer === 'function') {
      const ab = await blob.arrayBuffer();
      if (__isValidPdfAb_(ab)) return ab;
    }
  } catch (_) {}

  // 3) datauristring -> base64 -> bytes
  try {
    const uri = doc.output('datauristring');
    const idx = String(uri || '').indexOf('base64,');
    const b64 = idx >= 0 ? String(uri).slice(idx + 7).trim() : '';
    if (b64) {
      const u8 = base64ToUint8Array(b64);
      if (__isValidPdfAb_(u8)) return u8.buffer;
    }
  } catch (_) {}

  throw new Error('Excel 轉 PDF 失敗：輸出不是有效的 PDF（可能是 jsPDF / 瀏覽器限制）');
}

async function __excelArrayBufferToPdf_(excelAb, meta){
  // 目標：將 Excel 轉成「影像型」PDF，再交給既有 PDF.js 流程顯示/標註/下載。
  // 為了讓樣式（底色/粗框/旋轉文字/欄寬列高/列印區域）盡量貼近 Excel，優先用 ExcelJS。
  meta = meta || {};

  const okP = await ensureJsPdfLoaded();
  if (!okP || !(window.jspdf && window.jspdf.jsPDF)) throw new Error('jsPDF 尚未載入（離線請放置 jspdf.umd.min.js 於同層）');
  const jsPDF = window.jspdf.jsPDF;

  // ===== helpers: address/range =====
  function __colToLetters_(n){
    let s = '';
    let x = n;
    while (x > 0) {
      const m = (x - 1) % 26;
      s = String.fromCharCode(65 + m) + s;
      x = Math.floor((x - 1) / 26);
    }
    return s;
  }
  function __lettersToCol_(letters){
    const t = String(letters || '').toUpperCase();
    let n = 0;
    for (let i=0;i<t.length;i++){
      const code = t.charCodeAt(i);
      if (code < 65 || code > 90) continue;
      n = n * 26 + (code - 64);
    }
    return n;
  }
  function __decodeCellA1_(a1){
    const m = String(a1||'').replace(/\$/g,'').match(/^([A-Z]+)(\d+)$/i);
    if (!m) return { r: 1, c: 1 };
    return { c: __lettersToCol_(m[1]), r: parseInt(m[2],10) || 1 };
  }
  function __decodeRangeA1_(rng){
    const p = String(rng||'').replace(/\$/g,'').split(':');
    const a = __decodeCellA1_(p[0]||'A1');
    const b = __decodeCellA1_(p[1]||p[0]||'A1');
    return { s: { r: Math.min(a.r,b.r), c: Math.min(a.c,b.c) }, e: { r: Math.max(a.r,b.r), c: Math.max(a.c,b.c) } };
  }

  // ===== helpers: colors =====
  function __hexFromArgb_(argb){
    const s = String(argb || '').replace(/^#/, '');
    if (!s) return null;
    const hex = (s.length === 8) ? s.slice(2) : s;
    if (!/^[0-9a-f]{6}$/i.test(hex)) return null;
    return '#' + hex.toLowerCase();
  }

  // Excel tint: tint>0 toward white, tint<0 toward black
  function __applyTintToHex_(hex, tint){
    const hh = String(hex || '').replace(/^#/, '');
    if (!/^[0-9a-f]{6}$/i.test(hh)) return null;
    let r = parseInt(hh.slice(0,2), 16);
    let g = parseInt(hh.slice(2,4), 16);
    let b = parseInt(hh.slice(4,6), 16);
    const t = Number(tint || 0);
    if (!isFinite(t) || t === 0) return '#' + hh.toLowerCase();
    function adj(x){
      if (t < 0) return Math.round(x * (1 + t));
      return Math.round(x + (255 - x) * t);
    }
    r = Math.max(0, Math.min(255, adj(r)));
    g = Math.max(0, Math.min(255, adj(g)));
    b = Math.max(0, Math.min(255, adj(b)));
    return '#' + [r,g,b].map(v => v.toString(16).padStart(2,'0')).join('');
  }

  // Parse theme palette from SheetJS theme XML (theme1.xml)
  function __parseThemePaletteFromSheetJs_(ab){
    // index: 0=lt1,1=dk1,2=lt2,3=dk2,4..9=accent1..accent6
    const fallback = ['#ffffff','#000000','#eeece1','#1f497d','#4f81bd','#c0504d','#9bbb59','#8064a2','#4bacc6','#f79646'];
    try {
      if (!window.XLSX || !window.DOMParser) return fallback;
      const wb0 = window.XLSX.read(ab, { type: 'array' });
      const themeXml = wb0 && (wb0.Themes || (wb0.Workbook && wb0.Workbook.Themes));
      if (!themeXml || typeof themeXml !== 'string') return fallback;

      const doc = new DOMParser().parseFromString(themeXml, 'application/xml');
      const clrScheme = doc.getElementsByTagName('a:clrScheme')[0] || doc.getElementsByTagName('clrScheme')[0];
      if (!clrScheme) return fallback;

      function pick(tag){
        const node = clrScheme.getElementsByTagName('a:' + tag)[0] || clrScheme.getElementsByTagName(tag)[0];
        if (!node) return null;
        const srgb = node.getElementsByTagName('a:srgbClr')[0] || node.getElementsByTagName('srgbClr')[0];
        if (srgb && srgb.getAttribute('val')) return '#' + String(srgb.getAttribute('val')).toLowerCase();
        const sys = node.getElementsByTagName('a:sysClr')[0] || node.getElementsByTagName('sysClr')[0];
        if (sys) {
          const last = sys.getAttribute('lastClr') || sys.getAttribute('val');
          if (last) return '#' + String(last).toLowerCase();
        }
        return null;
      }

      const lt1 = pick('lt1') || fallback[0];
      const dk1 = pick('dk1') || fallback[1];
      const lt2 = pick('lt2') || fallback[2];
      const dk2 = pick('dk2') || fallback[3];
      const a1  = pick('accent1') || fallback[4];
      const a2  = pick('accent2') || fallback[5];
      const a3  = pick('accent3') || fallback[6];
      const a4  = pick('accent4') || fallback[7];
      const a5  = pick('accent5') || fallback[8];
      const a6  = pick('accent6') || fallback[9];
      return [lt1, dk1, lt2, dk2, a1, a2, a3, a4, a5, a6];
    } catch (e) {
      return fallback;
    }
  }

  let __THEME_HEX__ = null;
  async function __getThemePalette_(ab){
    if (__THEME_HEX__) return __THEME_HEX__;
    try { await ensureXlsxLoaded(); } catch (_) {}
    __THEME_HEX__ = __parseThemePaletteFromSheetJs_(ab);
    return __THEME_HEX__;
  }

  function __colorToHex_(color, themePalette){
    if (!color) return null;
    if (color.argb) return __hexFromArgb_(color.argb);
    if (color.rgb)  return __hexFromArgb_(color.rgb);
    if (color.theme != null && color.theme !== '') {
      const pal = themePalette || __THEME_HEX__ || ['#ffffff','#000000','#eeece1','#1f497d','#4f81bd','#c0504d','#9bbb59','#8064a2','#4bacc6','#f79646'];
      const idx = Number(color.theme);
      if (isFinite(idx) && idx >= 0 && idx < pal.length) {
        const base = pal[idx];
        const tint = (color.tint != null) ? Number(color.tint) : 0;
        return __applyTintToHex_(base, tint) || base;
      }
    }
    return null;
  }


  // ===== try ExcelJS =====
  const okE = await ensureExcelJsLoaded();
  if (okE && window.ExcelJS) {
    const ExcelJS = window.ExcelJS;
    const wb = new ExcelJS.Workbook();
    await wb.xlsx.load(excelAb);
    const ws = wb.worksheets && wb.worksheets.length ? wb.worksheets[0] : null;
    if (!ws) throw new Error('找不到 Excel 工作表');

    // Theme palette (for Excel theme colors)
    const __themePalette = await __getThemePalette_(excelAb);

    // print area (優先)
    let range = null;
    try {
      const pa = ws.pageSetup && ws.pageSetup.printArea ? ws.pageSetup.printArea : null;
      if (pa) {
        // ExcelJS: printArea may be 'A1:C9' or ['A1:C9']
        const r0 = Array.isArray(pa) ? pa[0] : String(pa);
        if (r0) range = __decodeRangeA1_(r0);
      }
    } catch (_) {}
    if (!range) {
      // fallback to dimensions
      const dim = ws.dimensions;
      range = dim ? __decodeRangeA1_(dim) : __decodeRangeA1_('A1:A1');
    }

    // cap (avoid huge)
    const MAX_ROWS = 220;
    const MAX_COLS = 90;
    if ((range.e.r - range.s.r + 1) > MAX_ROWS) range.e.r = range.s.r + MAX_ROWS - 1;
    if ((range.e.c - range.s.c + 1) > MAX_COLS) range.e.c = range.s.c + MAX_COLS - 1;

    const nRows = (range.e.r - range.s.r + 1);
    const nCols = (range.e.c - range.s.c + 1);

    // merges
    const mergeStart = new Map();
    const covered = new Set();
    const merges = [];
    try {
      if (ws.model && Array.isArray(ws.model.merges)) {
        for (const m of ws.model.merges) merges.push(String(m));
      } else if (ws._merges) {
        for (const k of ws._merges.keys()) merges.push(String(k));
      }
    } catch (_) {}
    for (const m of merges) {
      const rg = __decodeRangeA1_(m);
      const key = rg.s.r + ',' + rg.s.c;
      mergeStart.set(key, rg);
      for (let r = rg.s.r; r <= rg.e.r; r++){
        for (let c = rg.s.c; c <= rg.e.c; c++){
          const k = r + ',' + c;
          if (k !== key) covered.add(k);
        }
      }
    }

    // col widths / row heights
    const colW = new Array(nCols).fill(44);
    for (let c = range.s.c; c <= range.e.c; c++){
      const idx = c - range.s.c;
      const col = ws.getColumn(c);
      const wch = (col && col.width != null) ? Number(col.width) : null;
      if (wch != null && isFinite(wch)) {
        colW[idx] = Math.max(18, Math.min(520, wch * 7 + 12));
      }
    }
    const rowHArr = new Array(nRows).fill(22);
    for (let r = range.s.r; r <= range.e.r; r++){
      const idx = r - range.s.r;
      const row = ws.getRow(r);
      const hpt = (row && row.height != null) ? Number(row.height) : null;
      if (hpt != null && isFinite(hpt)) {
        rowHArr[idx] = Math.max(12, Math.min(260, hpt * (96/72)));
      }
    }

    // Performance preset: faster Excel->PDF conversion.
    // Viewer-side rendering will still be HiDPI, so extremely high export zoom is usually unnecessary.
    const EXPORT_LAYOUT_ZOOM = 1.05;
    const EXPORT_FONT_ZOOM = 1.25;
    for (let i = 0; i < colW.length; i++) colW[i] *= EXPORT_LAYOUT_ZOOM;
    for (let i = 0; i < rowHArr.length; i++) rowHArr[i] *= EXPORT_LAYOUT_ZOOM;

    // sizes
    let tableW = colW.reduce((a,b)=>a+(Number(b)||0),0);
    let tableH = rowHArr.reduce((a,b)=>a+(Number(b)||0),0);
    const margin = 18;
    const title = String(meta.title || '').trim();
    let titleH = title ? 30 : 0;
    let pageW = tableW + margin * 2;
    let pageH = tableH + margin * 2 + titleH;

    // scale down if too large
    const MAX_DIM = 5200;
    const bigger = Math.max(pageW, pageH);
    let scale = 1;
    if (bigger > MAX_DIM) {
      scale = MAX_DIM / bigger;
      pageW *= scale;
      pageH *= scale;
      titleH *= scale;
      for (let i = 0; i < colW.length; i++) colW[i] *= scale;
      for (let i = 0; i < rowHArr.length; i++) rowHArr[i] *= scale;
      tableW *= scale;
      tableH *= scale;
    }

    // canvas (HiDPI raster for sharper PDF)
    const cssW = Math.max(1, Math.round(pageW));
    const cssH = Math.max(1, Math.round(pageH));
    // HiDPI rasterization for Excel->PDF image embedding.
    // This is still bitmap-based (not true vector), so we push raster scale higher
    // to reduce blur on thin lines and small fonts.
    // Trade-off: higher memory / file size.
    // NOTE: This is bitmap-based. Use a moderate raster scale to reduce conversion time.
    // The PDF viewer itself renders at HiDPI; pushing rasterScale too high here mainly increases CPU/memory.
    let rasterScale = 2.5;
    try {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      // Prefer ~2x on standard displays; up to ~3x on HiDPI.
      rasterScale = Math.max(2, Math.min(3.25, Math.round(dpr * 2)));
    } catch (_) {}
    const MAX_RASTER_DIM = 9000;
    const MAX_RASTER_AREA = 80e6;
    while ((cssW * rasterScale) > MAX_RASTER_DIM || (cssH * rasterScale) > MAX_RASTER_DIM || (cssW * cssH * rasterScale * rasterScale) > MAX_RASTER_AREA) {
      rasterScale = rasterScale - 0.5;
      if (rasterScale <= 1.25) { rasterScale = 1.25; break; }
    }

const canvas = document.createElement('canvas');
    canvas.width = Math.max(1, Math.round(cssW * rasterScale));
    canvas.height = Math.max(1, Math.round(cssH * rasterScale));
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('瀏覽器不支援 Canvas');

    // Draw in CSS pixels, render to higher-resolution backing store
    ctx.setTransform(rasterScale, 0, 0, rasterScale, 0, 0);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, cssW, cssH);

    const startX = margin * scale;
    const startY = (margin * scale) + titleH;

    if (title) {
      ctx.fillStyle = '#111111';
      ctx.font = `${Math.max(12, Math.round(15*scale*EXPORT_FONT_ZOOM))}px sans-serif`;
      ctx.textBaseline = 'alphabetic';
      ctx.fillText(title, startX, margin * scale + (18*scale));
    }

    // x positions
    const xPos = new Array(nCols).fill(0);
    let acc = 0;
    for (let i = 0; i < nCols; i++){
      xPos[i] = acc;
      acc += colW[i];
    }


    // Prefix sums (performance): avoid O(R^2) row-height accumulation during rendering
    const colPrefix = new Array(nCols + 1);
    colPrefix[0] = 0;
    for (let i = 0; i < nCols; i++) colPrefix[i + 1] = colPrefix[i] + (Number(colW[i]) || 0);


    // nRows already computed above
    const rowPrefix = new Array(nRows + 1);
    rowPrefix[0] = 0;
    for (let i = 0; i < nRows; i++) rowPrefix[i + 1] = rowPrefix[i] + (Number(rowHArr[i]) || 22);

    function __sumCols_(c0, spanC){
      const a = Math.max(0, Math.min(nCols, c0));
      const b = Math.max(a, Math.min(nCols, c0 + spanC));
      return colPrefix[b] - colPrefix[a];
    }
    // base grid
    const baseGridW = Math.max(0.7, 0.9 * scale);
    const padX = 4 * scale;
    const padY = 3 * scale;

    function wrapLines(text, maxWidth){
      const out = [];
      const t = String(text || '');
      if (!t) return out;
      const parts = t.split(/\s+/).filter(Boolean);
      if (parts.length <= 1) {
        let buf = '';
        for (const ch of t) {
          const next = buf + ch;
          if (ctx.measureText(next).width > maxWidth && buf) {
            out.push(buf);
            buf = ch;
          } else {
            buf = next;
          }
        }
        if (buf) out.push(buf);
        return out;
      }
      let line = '';
      for (const w of parts){
        const next = line ? (line + ' ' + w) : w;
        if (ctx.measureText(next).width <= maxWidth) {
          line = next;
        } else {
          if (line) out.push(line);
          line = w;
        }
      }
      if (line) out.push(line);
      return out;
    }


    // ===== helpers: number/text formatting (match Excel display more closely) =====
    function __countDecimalsFromFmt_(fmt){
      const m = String(fmt || '').match(/0\.([0]+)/);
      return m ? m[1].length : 0;
    }
    function __formatNumberByNumFmt_(num, fmt){
      const f = String(fmt || '');
      if (!f) return String(num);
      // percent
      if (f.includes('%')) {
        const d = __countDecimalsFromFmt_(f);
        return (num * 100).toFixed(d) + '%';
      }
      // fixed decimals
      const d = __countDecimalsFromFmt_(f);
      if (d > 0) return Number(num).toFixed(d);
      // integer-like formats
      if (/[#0]/.test(f)) return String(Math.round(Number(num)));
      return String(num);
    }
    function __getCellDisplayText_(cell, r, c){
      if (!cell) return '';
      // Pull numeric value (including formula result)
      let num = null;
      try {
        const v = cell.value;
        if (typeof v === 'number') num = v;
        else if (v && typeof v === 'object' && typeof v.result === 'number') num = v.result;
      } catch (_) {}

      // Special requirements from your template (優先覆寫)
      if (num != null) {
        try {
          const left = (c > 1) ? ws.getCell(r, c - 1) : null;
          const up   = (r > 1) ? ws.getCell(r - 1, c) : null;
          const lbl = ((left && left.text) ? String(left.text) : '') + ' ' + ((up && up.text) ? String(up.text) : '');
          if (lbl.includes('總作業時間')) return Number(num).toFixed(1);
          if (lbl.includes('產線編成效率')) return (Number(num) * 100).toFixed(0) + '%';
        } catch (_) {}

        // Generic formatting via numFmt (when available)
        const fmt = cell.numFmt || (cell.style && cell.style.numFmt) || null;
        return __formatNumberByNumFmt_(num, fmt);
      }

      // Fallback: plain text
      const t = (cell.text != null) ? String(cell.text) : '';
      return String(t).trim();
    }

    function __borderWidth_(style){
      const s = String(style || '').toLowerCase();
      if (!s) return 0;
      if (s === 'thin') return 1;
      if (s === 'medium') return 2;
      if (s === 'thick') return 3;
      if (s === 'double') return 2;
      return 1;
    }
    function __drawBorders_(x,y,w,h, border){
      // 重要：不要畫出 Excel 的預設格線（這些在 Excel 介面看得到，但列印/PDF 應為空白）。
      // 只畫出「明確設定」的邊框樣式。
      if (!border) return;
      const sides = [
        ['left', x, y, x, y+h],
        ['right', x+w, y, x+w, y+h],
        ['top', x, y, x+w, y],
        ['bottom', x, y+h, x+w, y+h]
      ];
      for (const [side, x1,y1,x2,y2] of sides){
        const seg = border[side] || null;
        if (!seg || !seg.style) continue;
        const w0 = __borderWidth_(seg.style);
        if (w0 <= 0) continue;
        const col = __colorToHex_(seg.color, __themePalette) || '#1f1f1f';
        ctx.lineWidth = Math.max(baseGridW, w0 * scale);
        ctx.strokeStyle = col;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
    }

    function __sumRowH_(r0, span){
      const i0 = (r0 - range.s.r);
      const a = Math.max(0, Math.min(nRows, i0));
      const b = Math.max(a, Math.min(nRows, i0 + span));
      return rowPrefix[b] - rowPrefix[a];
    }
    function __yForRow_(r){
      const i = (r - range.s.r);
      const a = Math.max(0, Math.min(nRows, i));
      return startY + (rowPrefix[a] || 0);
    }

    // draw
    for (let r = range.s.r; r <= range.e.r; r++){
      const y = __yForRow_(r);
      for (let c = range.s.c; c <= range.e.c; c++){
        const key = r + ',' + c;
        if (covered.has(key)) continue;

        const m = mergeStart.get(key);
        const spanR = m ? (m.e.r - m.s.r + 1) : 1;
        const spanC = m ? (m.e.c - m.s.c + 1) : 1;

        const c0 = c - range.s.c;
        const w = __sumCols_(c0, spanC);
        const h = __sumRowH_(r, spanR);
        const x = startX + xPos[c0];

        const cell = ws.getCell(r, c);
        const st = cell ? (cell.style || {}) : {};
        // fill
        try {
          const fill = (cell && (cell.fill || cell.style && cell.style.fill)) || st.fill;
          const pat = fill && (fill.pattern || fill.patternType);
          const isSolid = (pat === 'solid' || pat == null);
          const fg = fill && (fill.fgColor || fill.foreground || (fill.bgColor && isSolid ? fill.bgColor : null));
          if (fill && fill.type === 'pattern' && isSolid && fg) {
            const hx = __colorToHex_(fg, __themePalette);
            if (hx) {
              ctx.fillStyle = hx;
              ctx.fillRect(x, y, w, h);
            }
          }
        } catch (_) {}

        // border
        __drawBorders_(x, y, w, h, (cell && (cell.border || (cell.style && cell.style.border))) || st.border);

        // text
        const text = __getCellDisplayText_(cell, r, c);
        if (!text) continue;

        const font = (cell && cell.font) || st.font || {};

        const fs = font.size != null ? Math.max(7, Math.round(Number(font.size) * scale * EXPORT_FONT_ZOOM)) : Math.max(9, Math.round(12 * scale * EXPORT_FONT_ZOOM));
        const fw = font.bold ? 'bold ' : '';
        const fn = font.name ? String(font.name) : 'sans-serif';
        ctx.font = `${fw}${fs}px ${fn}`;
        const fc = __colorToHex_(font.color, __themePalette) || '#111111';
        ctx.fillStyle = fc;
        ctx.textBaseline = 'middle';

        const align = (cell && cell.alignment) || st.alignment || {};

        const hAlign = align.horizontal || 'left';
        const vAlign = align.vertical || 'middle';
        const rotate = (align.textRotation != null) ? Number(align.textRotation) : 0;
        const wrap = (align.wrapText != null) ? !!align.wrapText : true;

        const innerW = Math.max(2, w - padX * 2);
        const innerH = Math.max(2, h - padY * 2);
        const lineH = Math.max(12 * scale, fs * 1.25);
        const lines = wrap ? wrapLines(text, innerW) : [text];
        const maxLines = Math.max(1, Math.floor(innerH / lineH));
        const useLines = lines.slice(0, maxLines);
        const blockH = useLines.length * lineH;

        function __anchorX_(){
          if (hAlign === 'center') return x + w / 2;
          if (hAlign === 'right') return x + w - padX;
          return x + padX;
        }
        function __textAlign_(){
          if (hAlign === 'center') return 'center';
          if (hAlign === 'right') return 'right';
          return 'left';
        }
        function __anchorY_(blockH){
          if (vAlign === 'top') return y + padY + lineH/2;
          if (vAlign === 'bottom') return y + h - padY - blockH + lineH/2;
          return y + (h - blockH)/2 + lineH/2;
        }
        ctx.textAlign = __textAlign_();

        if (rotate && rotate !== 0) {
          let deg = rotate;
          if (deg === 255) deg = 90;
          const rad = deg * Math.PI / 180;
          ctx.save();
          ctx.translate(x + w/2, y + h/2);
          ctx.rotate(rad);
          ctx.textAlign = 'center';
          let ty = -blockH/2 + lineH/2;
          for (const ln of useLines){
            ctx.fillText(ln, 0, ty);
            ty += lineH;
          }
          ctx.restore();
        } else {
          const tx = __anchorX_();
          let ty = __anchorY_(blockH);
          for (const ln of useLines){
            ctx.fillText(ln, tx, ty);
            ty += lineH;
          }
        }
      }
    }

    // canvas -> pdf
    const doc = new jsPDF({
      orientation: cssW >= cssH ? 'l' : 'p',
      unit: 'px',
      format: [cssW, cssH],
      compress: true
    });
    const imgData = canvas.toDataURL('image/jpeg', 0.88);
    doc.addImage(imgData, 'JPEG', 0, 0, cssW, cssH);
    return await __jsPdfOutputArrayBufferSafe_(doc);
  }

  // ===== fallback: SheetJS（無 ExcelJS 時，樣式還原能力有限） =====
  const okX = await ensureXlsxLoaded();
  if (!okX || !window.XLSX) throw new Error('ExcelJS 尚未載入（建議離線放置 exceljs.min.js）；且 XLSX 也尚未載入');
  throw new Error('ExcelJS 未載入：目前無法做到與 Excel 列印樣式接近的 PDF。請放置 exceljs.min.js 後重試。');
}

async function getPdfArrayBuffer(pdfItem) {
  if (!pdfItem) return null;
  if (pdfItem.ab) return pdfItem.ab;

  // Excel 匯入：顯示/擷取時先離線轉成 PDF，再沿用既有 PDF 流程
  if (__excelIsSupported_(pdfItem)) {
    // Excel -> PDF：先嘗試離線快取（IndexedDB），命中則可大幅縮短載入時間
    try {
      if (!pdfItem._excelCacheId) pdfItem._excelCacheId = __excelPdfCacheIdForItem_(pdfItem);
      if (pdfItem._excelCacheId) {
        const cached = await cacheGetPdf_(pdfItem._excelCacheId);
        if (cached && cached.ab) {
          pdfItem.ab = cached.ab;
          pdfItem.lastDownloadError = '';
          return pdfItem.ab;
        }
      }
    } catch (e) {}
    if (pdfItem._excelPdfInflight) return await pdfItem._excelPdfInflight;
    pdfItem._excelPdfInflight = (async () => {
      try {
        const title = (pdfItem.displayName || guessNameFromFilename(pdfItem.fileName || '') || '').trim();
        const ab = await __excelArrayBufferToPdf_(pdfItem.excelAb, { title });
        // 轉檔成功後寫入離線快取，避免同檔反覆轉換
        try {
          if (ab && pdfItem._excelCacheId) {
            await cachePutPdf_(pdfItem._excelCacheId, ab, { name: pdfItem.displayName || pdfItem.fileName || '', sizeBytes: (pdfItem.excelAb && pdfItem.excelAb.byteLength) ? pdfItem.excelAb.byteLength : 0, updatedAt: '' });
          }
        } catch (e) {}
        return ab || null;
      } catch (e) {
        console.warn('Excel -> PDF 轉換失敗：', e);
        return null;
      }
    })();
    try {
      pdfItem.ab = await pdfItem._excelPdfInflight;
      return pdfItem.ab || null;
    } finally {
      pdfItem._excelPdfInflight = null;
    }
  }

  

  // Cache/Local 匯入（IndexedDB）：若刷新後記憶體釋放，仍可由快取取回
  if ((pdfItem.source === 'cache' || pdfItem.source === 'local') && pdfItem.id) {
    try {
      const cached = await cacheGetPdf_(String(pdfItem.id));
      if (cached && cached.ab) {
        pdfItem.ab = cached.ab;
        pdfItem.lastDownloadError = '';
        return pdfItem.ab;
      }
    } catch (e) {}
  }

// Drive 匯入：先用離線快取；未命中則走「小檔整包 download / 大檔分段 downloadChunk」自動策略
  if (pdfItem.source === 'drive' && pdfItem.id) {
    const fileId = String(pdfItem.id);
    const sizeBytes = Number(pdfItem.sizeBytes || 0);

    // 先嘗試從離線快取取回（可在離線狀態使用）
    const cached = await cacheGetPdf_(fileId);
    if (cached && cached.ab) {
      pdfItem.ab = cached.ab;
      pdfItem.lastDownloadError = '';
      return pdfItem.ab;
    }

    try {
      const ab = await downloadDrivePdfArrayBufferChunked_(fileId, sizeBytes); // 內部已含「小檔 download / 大檔 chunk」策略
      pdfItem.ab = ab;
      pdfItem.lastDownloadError = '';
      await cachePutPdf_(fileId, pdfItem.ab, { name: pdfItem.displayName || pdfItem.fileName || '', sizeBytes: sizeBytes, updatedAt: pdfItem.updatedAt || '' });
      return pdfItem.ab;
    } catch (e) {
      const msg = String((e && e.message) ? e.message : e);
      pdfItem.lastDownloadError = msg;
      console.warn('Drive 檔案下載失敗（作業工程擷取不可用）', msg);
      return null;
    }
  }

  // Local 匯入：匯入時已存入 pdfItem.ab
  return pdfItem.ab || null;
}
async function extractProcessTableDataFromPdf(arrayBuffer) {
  const ok = await ensurePdfJsLoaded();
  if (!ok || !window.pdfjsLib) return { ok: false, message: 'PDF.js 尚未載入' };

  const median = (arr) => {
    const a = (arr || []).filter(v => typeof v === 'number' && isFinite(v)).slice().sort((x,y)=>x-y);
    if (!a.length) return null;
    const mid = Math.floor(a.length/2);
    return a.length % 2 ? a[mid] : (a[mid-1] + a[mid]) / 2;
  };

  const pickBestYBand = (arr, yKey = 'ly', band = 8) => {
    // group by y band, return the band with the most elements
    const buckets = new Map();
    for (const it of arr) {
      const y = Number(it[yKey]);
      if (!isFinite(y)) continue;
      const k = Math.round(y / band);
      if (!buckets.has(k)) buckets.set(k, []);
      buckets.get(k).push(it);
    }
    let best = null;
    for (const [k, list] of buckets.entries()) {
      if (!best || list.length > best.list.length) best = { k, list };
    }
    return best ? best.list : [];
  };

  try {
    // Try normal load; fallback to disableWorker for restricted environments.
    let doc;
    try {
      doc = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
    } catch (err) {
      window.pdfjsLib.disableWorker = true;
      doc = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
    }

    const page = await doc.getPage(1);
    const viewport = page.getViewport({ scale: 2.0 });

    const tc = await page.getTextContent({ normalizeWhitespace: true, disableCombineTextItems: false });
    const raw = (tc && tc.items) ? tc.items : [];

    // Convert to viewport coords (origin: top-left)
    const items = [];
    for (const it of raw) {
      const str = (it && it.str != null) ? String(it.str).trim() : '';
      if (!str) continue;
      const t = it.transform || [];
      const e = t[4], f = t[5];
      const pt = viewport.convertToViewportPoint(e, f);
      items.push({ str, lx: pt[0], ly: pt[1] });
    }

    if (!items.length) {
      return { ok: false, message: '此 PDF 可能為掃描圖或無可選取文字，無法自動擷取。' };
    }

    const H = viewport.height;
    const W = viewport.width;

    // ---- Heuristic tuned for 排關圖格式（含 31..1 欄位、底部 1人 / 作業時間） ----
    const isColNo = (s) => {
      const m = String(s).match(/^\d{1,2}$/);
      if (!m) return false;
      const n = parseInt(s, 10);
      return n >= 1 && n <= 31;
    };
    const isFloat = (s) => /^(\d+)(\.\d+)?$/.test(String(s));
    const isMan = (s) => /^(\d+)\s*人$/.test(String(s).replace(/\s+/g,''));
    const parseManNum = (s) => {
      const t = String(s || '').replace(/\s+/g,'');
      const m = t.match(/^(\d+)人$/);
      if (m) return parseInt(m[1], 10);
      const n = parseInt(t, 10);
      return Number.isFinite(n) ? n : null;
    };

    const parseFloatNum = (s) => {
      const t = String(s || '').replace(/\s+/g,'');
      const v = parseFloat(t);
      return Number.isFinite(v) ? v : null;
    };

    const findRightValue = (labelRe, valueTestFn, parseFn) => {
      const labels = items.filter(it => labelRe.test(String(it.str || '')));
      if (!labels.length) return null;
      // Prefer the bottom-most label (summary box is usually near bottom)
      labels.sort((a,b) => b.ly - a.ly);
      const lab = labels[0];
      const band = items
        .filter(it => Math.abs(it.ly - lab.ly) <= 14)
        .filter(it => it.lx > lab.lx + 6)
        .filter(it => valueTestFn(it.str));
      if (!band.length) return null;
      band.sort((a,b) => a.lx - b.lx);
      return parseFn(band[0].str);
    };


    // 1) 找到欄號（1..31）所在的 header row（用 y-band 避免誤抓到其他地方的 1/2）
    const headerCandidatesAll = items.filter(it => isColNo(it.str) && it.ly < H * 0.35);
    const headerCandidates = pickBestYBand(headerCandidatesAll, 'ly', 8);

    if (headerCandidates.length < 8) {
      return { ok: false, message: '找不到排關圖欄位結構（1~31），請確認 PDF 格式是否與範例一致。' };
    }

    // pick one per number (closest to the chosen header row)
    const byNo = new Map();
    for (const it of headerCandidates) {
      const n = parseInt(it.str, 10);
      // If duplicate, keep the one closest to median header y (more stable)
      if (!byNo.has(n)) byNo.set(n, it);
    }

    // sequence 1 -> 31 (對應 Excel 項次 1..n)
    const headers = Array.from(byNo.entries())
      .map(([n, it]) => ({ n, x: it.lx, y: it.ly }))
      .sort((a, b) => a.n - b.n);

    const yHeader = median(headers.map(h => h.y));

    // Determine x boundaries for each column via midpoints (sorted by x)
    const sortedByX = [...headers].sort((a,b)=>a.x-b.x);
    const xBoundsByNo = new Map();
    for (let i=0;i<sortedByX.length;i++){
      const cur = sortedByX[i];
      const prev = sortedByX[i-1];
      const next = sortedByX[i+1];
      const left = prev ? (prev.x + cur.x)/2 : Math.max(0, cur.x - 55);
      const right = next ? (cur.x + next.x)/2 : Math.min(W, cur.x + 55);
      xBoundsByNo.set(cur.n, { left, right, center: cur.x });
    }

    // 2) 找到「1人」所在 row（以多數 1人 的 y-band 中位數作為 row）
    const manItemsAll = items.filter(it => isMan(it.str) && it.ly > H*0.35 && it.ly < H*0.92);
    const manItems = pickBestYBand(manItemsAll, 'ly', 8);
    const yMan = manItems.length ? median(manItems.map(it => it.ly)) : null;

    // 3) 找到作業時間 row（通常在 1人 的下一行；以 y-band 避免抓到其他統計數字）
    let yTime = null;
    if (yMan != null) {
      const timeNearAll = items
        .filter(it => isFloat(it.str) && it.ly > yMan && it.ly < yMan + 80)
        .filter(it => {
          const v = parseFloat(it.str);
          return isFinite(v) && v >= 0 && v <= 20; // 作業時間通常不會太大
        });
      const timeNear = pickBestYBand(timeNearAll, 'ly', 8);
      if (timeNear.length) yTime = median(timeNear.map(it => it.ly));
    }
    if (yTime == null && yMan != null) yTime = yMan + 18;

    // 4) 擷取每欄的工程文字（垂直字串：依 y 由小到大拼接）
    const rows = [];
    for (const h of headers) {
      const b = xBoundsByNo.get(h.n);
      if (!b) continue;

      const inCol = items.filter(it => it.lx >= b.left && it.lx <= b.right);

      // man
      let manVal = '';
      if (yMan != null) {
        const mCand = inCol
          .map(it => ({ it, dy: Math.abs(it.ly - yMan) }))
          .filter(o => o.dy <= 18 && isMan(o.it.str))
          .sort((a,b)=>a.dy-b.dy)[0];
        if (mCand) manVal = mCand.it.str.replace(/\s+/g,'');
      }

      // time
      let timeVal = '';
      if (yTime != null) {
        const tCand = inCol
          .map(it => ({ it, dy: Math.abs(it.ly - yTime) }))
          .filter(o => o.dy <= 18 && isFloat(o.it.str))
          .filter(o => {
            const v = parseFloat(o.it.str);
            return isFinite(v) && v >= 0 && v <= 20;
          })
          .sort((a,b)=>a.dy-b.dy)[0];
        if (tCand) timeVal = tCand.it.str;
      }

      // step text area
      const yTop = (yHeader != null) ? (yHeader + 18) : (H * 0.12);
      const yBottom = (yMan != null) ? (yMan - 10) : (H * 0.70);

      const parts = inCol
        .filter(it => it.ly >= yTop && it.ly <= yBottom)
        // 排除 header row 的欄號（僅在 yHeader 附近）
        .filter(it => !(isColNo(it.str) && yHeader != null && Math.abs(it.ly - yHeader) <= 14))
        // 排除 row labels / noise
        .filter(it => !/(^人數$|^作業時間$|^總作業|^總人數$)/.test(it.str))
        .filter(it => !/作業工程/.test(it.str))
        // 不排除一般數字（例如 1.4、0.3、9克 等會用到）
        .filter(it => !(isFloat(it.str) && yTime != null && Math.abs(it.ly - yTime) <= 22));

      parts.sort((a,b)=>a.ly-b.ly);
      let step = parts.map(it => it.str).join('');
      step = step
        .replace(/\s+/g,'')
        .replace(/[，,]+/g,'')
        .replace(/＋/g,'+')
        .replace(/－/g,'-');

      // Noise cleanup
      step = step.replace(/作業工程/g,'');
      step = step.replace(/作業/g,'').replace(/工程/g,'');
      if (!step || step.length <= 1) continue;
      if (/(目標|總計|改善|優化方向|成效|產線|效率|產力|輸送帶)/.test(step)) continue;

      const manNum = manVal ? (manVal.match(/^(\d+)/)?.[1] || '') : '';
      rows.push({
        no: rows.length + 1,
        step,
        man: manNum,
        time: timeVal || ''
      });
    }

    // preview (optional): crop around header->time row and first/last columns
    let previewDataUrl = '';
    try {
      const x0 = Math.max(0, Math.min(...sortedByX.map(o=>o.x)) - 30);
      const x1 = Math.min(W, Math.max(...sortedByX.map(o=>o.x)) + 30);
      const y0 = Math.max(0, (yHeader != null ? yHeader - 10 : H * 0.05));
      const y1 = Math.min(H, (yTime != null ? yTime + 80 : (yMan != null ? yMan + 80 : H * 0.80)));
      const cropBox = { x: x0 / W, y: y0 / H, w: (x1-x0) / W, h: (y1-y0) / H };
      previewDataUrl = await renderCropPreviewDataUrl(page, viewport, cropBox);
    } catch (e) {}

    if (!rows.length) {
      return { ok: false, message: '已載入 PDF，但未成功擷取「作業工程」欄位。請確認 PDF 是否為可選取文字。', previewDataUrl };
    }

    // ---- Summary (所需人數 / 總計人數 / 總作業時間) ----
    const requiredPeopleSum = rows.reduce((acc, r) => acc + (parseManNum(r.man) || 0), 0);
    const totalTimeSum = rows.reduce((acc, r) => {
      const v = parseFloatNum(r.time);
      return acc + (Number.isFinite(v) ? v : 0);
    }, 0);

    const requiredPeopleLabel = findRightValue(/所需人數/, (s) => isMan(s) || /^\d+$/.test(String(s).trim()), parseManNum);
    const totalPeopleLabel = findRightValue(/總計人數|總人數/, (s) => isMan(s) || /^\d+$/.test(String(s).trim()), parseManNum);
    const totalTimeLabelA = findRightValue(/總作業時間/, (s) => isFloat(s), parseFloatNum);
    const totalTimeLabelB = totalTimeLabelA != null ? totalTimeLabelA : findRightValue(/總作業/, (s) => isFloat(s), parseFloatNum);

    const summary = {
      requiredPeople: (requiredPeopleLabel != null ? requiredPeopleLabel : requiredPeopleSum) || 0,
      totalPeople: (totalPeopleLabel != null ? totalPeopleLabel : ((requiredPeopleLabel != null ? requiredPeopleLabel : requiredPeopleSum) || 0)) || 0,
      totalTime: (totalTimeLabelB != null ? totalTimeLabelB : totalTimeSum) || 0
    };

    return { ok: true, rows, previewDataUrl, summary };

  } catch (err) {
    return { ok: false, message: String(err && err.message ? err.message : err) };
  }
}


async function getProcessTableForProduct(productName, opts) {
  opts = opts || {};
  const pdfItem = findPdfForProductName(productName);
  if (!pdfItem) return { ok: false, message: '找不到對應的排關圖 PDF' };

  const key = processTableKey(pdfItem);
  if (!opts.force && processTableCache.has(key)) return processTableCache.get(key);

  if (!opts.force && processTableInflight.has(key)) return await processTableInflight.get(key);

  const p = (async () => {
    const ab = await getPdfArrayBuffer(pdfItem);
    if (!ab) {
      // Provide more diagnostics for cloud import
      const isDrive = (pdfItem && pdfItem.source === 'drive' && pdfItem.id);
      if (isDrive) {
        const detail = pdfItem.lastDownloadError ? ('；詳細：' + pdfItem.lastDownloadError) : '';
        const testUrl = (typeof DRIVE_EXEC_URL === 'string' && DRIVE_EXEC_URL)
          ? (DRIVE_EXEC_URL + (DRIVE_EXEC_URL.indexOf('?') >= 0 ? '&' : '?') + 'action=download&id=' + encodeURIComponent(pdfItem.id))
          : '';
        const hint = testUrl ? ('；請測試：' + testUrl) : '';
        return { ok: false, message: '無法取得 PDF 檔案（雲端匯入需 Apps Script 支援 action=download，且需重新部署）' + detail + hint };
      }
      return { ok: false, message: '無法取得 PDF 檔案（請確認已成功匯入 PDF）' };
    }

    const res = await extractProcessTableDataFromPdf(ab);
    // cache even failures (short-lived) to avoid repeated heavy work
    processTableCache.set(key, res);
    return res;
  })();

  processTableInflight.set(key, p);
  const res = await p;
  processTableInflight.delete(key);
  return res;
}


    // Suggestions: list imported PDF product names and provide substring matching
    function allImportedProductNames() {
      const out = [];
      const seen = new Set();
      for (const v of pdfStore.values()) {
        const name = (v && v.displayName) ? String(v.displayName).trim() : '';
        if (!name) continue;
        if (seen.has(name)) continue;
        seen.add(name);
        out.push(name);
      }
      return out;
    }

    function suggestProductNames(query, limit = 8) {
      const q = (query || '').toString().trim();
      if (!q) return [];
      const names = allImportedProductNames();

      // Substring match (case-insensitive for Latin, neutral for CJK)
      const qLower = q.toLowerCase();
      const hits = names.filter(n => n.toLowerCase().includes(qLower));

      // Prefer prefix hits first, then other substring hits
      hits.sort((a, b) => {
        const ap = a.toLowerCase().startsWith(qLower) ? 0 : 1;
        const bp = b.toLowerCase().startsWith(qLower) ? 0 : 1;
        if (ap !== bp) return ap - bp;
        return a.length - b.length;
      });

      return hits.slice(0, limit);
    }

    function renderSuggestBox(boxEl, items, onPick) {
      if (!boxEl) return;
      boxEl.innerHTML = '';

      if (!items || items.length === 0) {
        boxEl.classList.add('hidden');
        return;
      }

      items.forEach((name) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'w-full text-left px-3 py-2 text-sm hover:bg-slate-50';
        btn.textContent = name;

        // Use mousedown to avoid blur closing before click
        btn.addEventListener('mousedown', (e) => {
          e.preventDefault();
          onPick && onPick(name);
        });

        boxEl.appendChild(btn);
      });

      boxEl.classList.remove('hidden');
    }

    function hideSuggestBox(boxEl) {
      if (!boxEl) return;
      boxEl.classList.add('hidden');
    }

    
    async function renderPdfInto(containerEl, arrayBuffer) {
      if (!containerEl) return;
      containerEl.innerHTML = '';

      if (!(window.pdfjsLib && pdfjsLib.getDocument)) {
        throw new Error('pdfjsLib not available');
      }

      const loading = document.createElement('div');
      loading.className = 'p-4 text-sm text-slate-600';
      loading.textContent = '載入排關圖中…';
      containerEl.appendChild(loading);

      const doc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

      // Clear loading
      containerEl.innerHTML = '';

      // Fit-to-width scale based on container
      const padding = 24; // internal padding estimate
      const targetW = Math.max(320, containerEl.clientWidth - padding);
      const dpr = Math.max(1, window.devicePixelRatio || 1);

      for (let p = 1; p <= doc.numPages; p++) {
        // eslint-disable-next-line no-await-in-loop
        const page = await doc.getPage(p);

        const viewport1 = page.getViewport({ scale: 1 });
        const scaleCss = Math.min(3.0, Math.max(0.6, targetW / viewport1.width));
        // Render at HiDPI for crisp text/lines. CSS size remains responsive.
        const viewport = page.getViewport({ scale: scaleCss * dpr });

        const wrap = document.createElement('div');
        wrap.className = 'p-3 border-b bg-white';
        const label = document.createElement('div');
        label.className = 'mb-2 text-xs text-slate-500';
        label.textContent = `第 ${p} / ${doc.numPages} 頁`;
        wrap.appendChild(label);

        const canvas = document.createElement('canvas');
        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        canvas.style.width = `${Math.floor(viewport.width / dpr)}px`;
        canvas.style.height = `${Math.floor(viewport.height / dpr)}px`;
        canvas.className = 'w-full rounded-lg border';

        const ctx = canvas.getContext('2d');
        // eslint-disable-next-line no-await-in-loop
        await page.render({ canvasContext: ctx, viewport }).promise;

        wrap.appendChild(canvas);
        containerEl.appendChild(wrap);
      }
    }

    function openPdfModal(productName, pdfItem) {
      const modal = document.getElementById('pdfModal');
      const renderEl = document.getElementById('pdfRender');
      const frame = document.getElementById('pdfFrame');
      const empty = document.getElementById('pdfEmpty');
      const title = document.getElementById('pdfTitle');
      const list = document.getElementById('pdfListText');
      const openBtn = document.getElementById('pdfOpenBtn');

      title.textContent = productName ? `商品名：${productName}` : '—';
      list.textContent = pdfListText();

      // reset
      if (openBtn) {
        openBtn.classList.add('hidden');
        openBtn.removeAttribute('href');
      }
      if (renderEl) {
        renderEl.classList.add('hidden');
        renderEl.innerHTML = '';
      }
      if (frame) {
        frame.classList.add('hidden');
        frame.src = 'about:blank';
      }

      if (pdfItem && pdfItem.blobUrl) {
        if (openBtn) {
          openBtn.href = pdfItem.blobUrl;
          openBtn.classList.remove('hidden');
        }
      }

      if (pdfItem && (pdfItem.ab || pdfItem.blobUrl)) {
        empty.classList.add('hidden');

        // Prefer PDF.js rendering (avoid Chrome blocking iframe navigation in some environments)
        (async () => {
          if (pdfItem && pdfItem.ab && renderEl) {
            try {
              renderEl.classList.remove('hidden');
              await renderPdfInto(renderEl, pdfItem.ab);
              return;
            } catch (err) {
              console.warn('PDF render fallback to iframe:', err);
              // fall back to iframe
            }
          }

          if (pdfItem && pdfItem.blobUrl && frame) {
            frame.classList.remove('hidden');
            frame.src = pdfItem.blobUrl;
          } else {
            empty.classList.remove('hidden');
          }
        })();
      } else {
        empty.classList.remove('hidden');
      }

      modal.classList.remove('hidden');
      document.body.classList.add('overflow-hidden');
    }



    function closePdfModal() {
      const modal = document.getElementById('pdfModal');
      const frame = document.getElementById('pdfFrame');
      const renderEl = document.getElementById('pdfRender');
      modal.classList.add('hidden');
      try { frame.src = 'about:blank'; } catch (e) {}
      try {
        if (renderEl) {
          renderEl.innerHTML = '';
          renderEl.classList.add('hidden');
        }
      } catch (e) {}
      document.body.classList.remove('overflow-hidden');
    }

    // ---------------- Google Drive（主資料夾→子資料夾）匯入：Apps Script Web App 方案 ----------------
    // 主資料夾（根資料夾）ID（由你提供）
    const DRIVE_ROOT_FOLDER_ID = '1YAYmLy9Wm0Kj4yNv5hG5-p6VXmp-02nz';

    // Apps Script Web App /exec（你新部署的網址）
    const DRIVE_EXEC_URL = 'https://script.google.com/macros/s/AKfycbzckzJBKBbjktBRf3PPodoHn7UbdfGiP24wUXFu7YOOzsnPlSPgVPOUs6UFQD6smAuo/exec';

    // （可選）token：若 Apps Script 有啟用 TOKEN 驗證，請填同一組；未啟用可留空
    const DRIVE_TOKEN = '';

    // 目前瀏覽中的資料夾（支援逐層進入）
    let driveActiveFolderId = DRIVE_ROOT_FOLDER_ID;
    let driveActiveFolderName = '主資料夾';
    let driveFolderStack = [{ id: DRIVE_ROOT_FOLDER_ID, name: '主資料夾' }];

    // 目前資料夾的「子資料夾清單」快取
    let driveFoldersCache = [];

    // 若你更新了 Apps Script 部署網址，請把上面 DRIVE_EXEC_URL 改成新的 /exec 連結即可。

    


    function openDriveModal() {
      // Header
      var rootEl = document.getElementById('driveRootFolderIdText');
      if (rootEl) rootEl.textContent = DRIVE_ROOT_FOLDER_ID;
      // init folder browser at root
      driveFolderStack = [{ id: DRIVE_ROOT_FOLDER_ID, name: '主資料夾' }];
      driveActiveFolderId = DRIVE_ROOT_FOLDER_ID;
      driveActiveFolderName = '主資料夾';
      $('#driveFolderIdText').textContent = getDriveBreadcrumbText_();
      var fc = document.getElementById('driveFolderCountText');
      if (fc) fc.textContent = '0';
      $('#driveCountText').textContent = '0';
      $('#driveSearch').value = '';
      driveSelectedIds = new Set();
      driveSelectedFolderIds = new Set();
      syncDriveFolderSelectedCount_();
      $('#driveList').innerHTML = '';
      var fl = document.getElementById('driveFolderList');
      if (fl) fl.innerHTML = '';

      $('#driveModal').classList.remove('hidden');
      document.body.classList.add('overflow-hidden');

      // 先載入子資料夾清單，再載入檔案清單
      driveRefreshCurrentFolder();
    }

    function closeDriveModal() {
      $('#driveModal').classList.add('hidden');
      document.body.classList.remove('overflow-hidden');
      try { setDriveProgress_(false, 0, 0, ''); } catch (e) {}
    }

    function formatBytes(n) {
      const num = Number(n || 0);
      if (!num) return '—';
      const units = ['B','KB','MB','GB'];
      let i = 0, v = num;
      while (v >= 1024 && i < units.length - 1) { v /= 1024; i++; }
      return `${v.toFixed(i === 0 ? 0 : 1)} ${units[i]}`;
    }

    function formatDate(iso) {
      if (!iso) return '—';
      try {
        const d = new Date(iso);
        return d.toLocaleString();
      } catch (e) {
        return iso;
      }
    }

    let driveCache = []; // [{id,name,sizeBytes,updatedAt,productName}]
    let driveSelectedIds = new Set();
    // 資料夾勾選（用於『匯入整份資料夾』）
    let driveSelectedFolderIds = new Set();

    function syncDriveFolderSelectedCount_() {
      var el = document.getElementById('driveFolderSelCountText');
      if (!el) return;
      try { el.textContent = String(driveSelectedFolderIds ? driveSelectedFolderIds.size : 0); } catch (e) { el.textContent = '0'; }
    }


    function escapeHtml(s) {
      return String(s || '')
        .replaceAll('&','&amp;')
        .replaceAll('<','&lt;')
        .replaceAll('>','&gt;')
        .replaceAll('"','&quot;')
        .replaceAll("'","&#39;");
    }

    
    function getVisibleDriveCheckboxes() {
      // Only currently rendered/visible items
      return Array.from(document.querySelectorAll('.driveChk'));
    }

    function setAllVisibleDriveChecks(checked) {
      const boxes = getVisibleDriveCheckboxes();
      boxes.forEach(b => {
        b.checked = !!checked;
        const id = b.getAttribute('data-id');
        if (!id) return;
        if (b.checked) driveSelectedIds.add(id);
        else driveSelectedIds.delete(id);
      });
      syncDriveSelectAllState();
    }

    function syncDriveSelectAllState() {
      const selectAll = document.getElementById('driveSelectAll');
      if (!selectAll) return;
      const boxes = getVisibleDriveCheckboxes();
      if (boxes.length === 0) {
        selectAll.checked = false;
        selectAll.indeterminate = false;
        return;
      }
      const checkedCount = boxes.filter(b => b.checked).length;
      selectAll.checked = checkedCount === boxes.length;
      selectAll.indeterminate = checkedCount > 0 && checkedCount < boxes.length;
    }

function renderDriveList(items) {
      const list = $('#driveList');
      list.innerHTML = '';
      const q = ($('#driveSearch').value || '').trim().toLowerCase();

      const filtered = (items || []).filter(it => {
        if (!q) return true;
        return (it.name || '').toLowerCase().includes(q) || (it.productName || '').toLowerCase().includes(q);
      });

      $('#driveCountText').textContent = String(filtered.length);

      if (filtered.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'p-4 text-sm text-slate-600';
        empty.textContent = '此資料夾目前沒有可用的檔案（PDF / Excel），或搜尋條件無結果。';
        list.appendChild(empty);
        return;
      }

      filtered.forEach((it) => {
        const row = document.createElement('label');
        row.className = 'grid grid-cols-12 items-center gap-2 px-3 py-2 border-t hover:bg-slate-50 cursor-pointer';
        var badge = '';
        if (it.kind === 'excel') {
          badge = '<span class="ml-2 inline-flex items-center rounded-full bg-amber-100 px-2 py-0.5 text-[11px] font-semibold text-amber-700">Excel</span>';
        } else if (it.kind === 'pdf') {
          badge = '<span class="ml-2 inline-flex items-center rounded-full bg-slate-100 px-2 py-0.5 text-[11px] font-semibold text-slate-600">PDF</span>';
        }
        row.innerHTML = `
          <div class="col-span-1"><input type="checkbox" class="driveChk rounded" data-id="${it.id}"></div>
          <div class="col-span-7">
            <div class="text-sm font-semibold text-slate-800 break-words">${escapeHtml(it.productName || it.name)}${badge}</div>
            <div class="text-xs text-slate-500 break-words">${escapeHtml(it.name || '')}${it.kind === 'excel' ? '<span class="ml-2 text-[11px] text-amber-700">（匯入後會自動轉成 PDF）</span>' : ''}</div>
          </div>
          <div class="col-span-2 text-xs text-slate-600">${escapeHtml(formatBytes(it.sizeBytes))}</div>
          <div class="col-span-2 text-xs text-slate-600">${escapeHtml(formatDate(it.updatedAt))}</div>
        `;
        // Apply persisted selection state
        const chk = row.querySelector('.driveChk');
        if (chk) {
          chk.checked = driveSelectedIds.has(it.id);
          if (!chk.__bound) {
            chk.addEventListener('change', () => {
              if (chk.checked) driveSelectedIds.add(it.id);
              else driveSelectedIds.delete(it.id);
              syncDriveSelectAllState();
            });
            chk.__bound = true;
          }
        }

        list.appendChild(row);
      });
    }

    // ---------------------------
// JSONP helper (for GitHub Pages / static hosting)
// ---------------------------
function jsonpRequest(url, timeoutMs) {
  timeoutMs = timeoutMs || 20000;
  return new Promise(function(resolve, reject) {
    var cbName = '__jsonp_cb_' + Date.now() + '_' + Math.floor(Math.random() * 100000);
    var script = document.createElement('script');
    var done = false;

    function cleanup() {
      try { delete window[cbName]; } catch (e) { window[cbName] = undefined; }
      if (script && script.parentNode) script.parentNode.removeChild(script);
    }

    var timer = setTimeout(function() {
      if (done) return;
      done = true;
      cleanup();
      reject(new Error('timeout'));
    }, timeoutMs);

    window[cbName] = function(data) {
      if (done) return;
      done = true;
      clearTimeout(timer);
      cleanup();
      resolve(data);
    };

    script.onerror = function() {
      if (done) return;
      done = true;
      clearTimeout(timer);
      cleanup();
      reject(new Error('load error'));
    };

    var sep = (url.indexOf('?') >= 0) ? '&' : '?';
    script.src = url + sep + 'callback=' + encodeURIComponent(cbName);
    document.body.appendChild(script);
  });
}

function buildDrivePreviewUrl(fileId) {
  return 'https://drive.google.com/file/d/' + encodeURIComponent(fileId) + '/preview';
}
function buildDriveOpenUrl(fileId) {
  return 'https://drive.google.com/file/d/' + encodeURIComponent(fileId) + '/view';
}

// Drive 檔案類型判斷：支援 PDF 與 Excel（.xlsx/.xls/.xlsm）
function __driveExt_(filename){
  const s = String(filename || '').trim();
  const dot = s.lastIndexOf('.');
  if (dot < 0) return '';
  return s.slice(dot + 1).toLowerCase();
}
function __driveKind_(filename){
  const ext = __driveExt_(filename);
  if (ext === 'pdf') return 'pdf';
  if (ext === 'xlsx' || ext === 'xls' || ext === 'xlsm') return 'excel';
  return 'other';
}



// Build Apps Script URL with optional token
function buildDriveApiUrl(query) {
  var baseUrl = DRIVE_EXEC_URL;
  if (!baseUrl || baseUrl.indexOf('script.google.com/macros/s/') === -1) {
    throw new Error('未設定正確的 Apps Script /exec 網址');
  }
  var qs = String(query || '').replace(/^\?/, '');
  if (DRIVE_TOKEN) {
    qs += (qs ? '&' : '') + 'token=' + encodeURIComponent(DRIVE_TOKEN);
  }
  // cache bust
  qs += (qs ? '&' : '') + 'ts=' + Date.now();
  return baseUrl + (baseUrl.indexOf('?') >= 0 ? '&' : '?') + qs;
}


// ------- Drive 資料夾瀏覽（支援多層） -------
function getDriveBreadcrumbText_() {
  try {
    if (Array.isArray(driveFolderStack) && driveFolderStack.length) {
      return driveFolderStack
        .map(function(x){ return x ? (x.name || x.id || '') : ''; })
        .filter(Boolean)
        .join(' / ');
    }
  } catch (e) {}
  return driveActiveFolderName || driveActiveFolderId || '—';
}

function driveSetCurrentFromStack_() {
  if (!Array.isArray(driveFolderStack) || driveFolderStack.length === 0) {
    driveFolderStack = [{ id: DRIVE_ROOT_FOLDER_ID, name: '主資料夾' }];
  }
  var top = driveFolderStack[driveFolderStack.length - 1];
  driveActiveFolderId = top.id;
  driveActiveFolderName = top.name || top.id;
  setActiveDriveFolder(driveActiveFolderId, driveActiveFolderName);
}

function driveEnterFolder_(folderId, folderName) {
  if (!folderId) return;
  if (!Array.isArray(driveFolderStack)) driveFolderStack = [];
  driveFolderStack.push({ id: folderId, name: folderName || folderId });
  driveSetCurrentFromStack_();
  driveRefreshCurrentFolder();
}

function driveGoUp_() {
  if (!Array.isArray(driveFolderStack) || driveFolderStack.length <= 1) return;
  driveFolderStack.pop();
  driveSetCurrentFromStack_();
  driveRefreshCurrentFolder();
}

async function driveRefreshCurrentFolder() {
  // 同步更新：「子資料夾清單」與「檔案清單」
  await loadDriveFolders(driveActiveFolderId);
  await loadDriveList(driveActiveFolderId);
}

function renderDriveFolders(folders) {
  var list = document.getElementById('driveFolderList');
  var countEl = document.getElementById('driveFolderCountText');
  var arr = Array.isArray(folders) ? folders : [];
  if (countEl) countEl.textContent = String(arr.length);
  if (!list) return;

  list.innerHTML = '';

  // 返回上層（多層資料夾）
  if (Array.isArray(driveFolderStack) && driveFolderStack.length > 1) {
    var up = document.createElement('button');
    up.type = 'button';
    up.className = 'w-full text-left px-3 py-2 border-t bg-slate-50 hover:bg-slate-100 flex items-center justify-between gap-3';
    up.setAttribute('data-drive-folder-up', '1');

    var upName = (driveFolderStack[driveFolderStack.length - 2] && (driveFolderStack[driveFolderStack.length - 2].name || driveFolderStack[driveFolderStack.length - 2].id)) || '';

    up.innerHTML =
      '<div class="min-w-0">' +
        '<div class="text-xs font-semibold text-slate-700 truncate">← 返回上層</div>' +
        '<div class="text-[11px] text-slate-500 truncate">' + escapeHtml(upName) + '</div>' +
      '</div>' +
      '<div class="shrink-0 text-[11px] text-slate-500">上層</div>';

    list.appendChild(up);
  }

  if (arr.length === 0) {
    var empty = document.createElement('div');
    empty.className = 'p-4 text-sm text-slate-600';
    empty.textContent = '此資料夾沒有子資料夾。';
    list.appendChild(empty);
    syncDriveFolderSelectedCount_();
    return;
  }

  arr.forEach(function(f) {
    var row = document.createElement('div');
    row.className = 'w-full px-3 py-2 border-t hover:bg-slate-50 flex items-center gap-3 bg-white';

    // checkbox (select folder)
    var chk = document.createElement('input');
    chk.type = 'checkbox';
    chk.className = 'driveFolderChk rounded';
    chk.setAttribute('data-folder-id', f.id);
    chk.setAttribute('data-folder-name', f.name || f.id);
    chk.checked = !!(driveSelectedFolderIds && driveSelectedFolderIds.has(f.id));
    chk.addEventListener('change', function() {
      var fid = String(f.id);
      if (!driveSelectedFolderIds) driveSelectedFolderIds = new Set();
      if (chk.checked) driveSelectedFolderIds.add(fid);
      else driveSelectedFolderIds.delete(fid);
      syncDriveFolderSelectedCount_();
    });

    // name button (enter folder)
    var btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'flex-1 min-w-0 text-left';
    btn.setAttribute('data-drive-folder-id', f.id);
    btn.setAttribute('data-drive-folder-name', f.name || f.id);
    btn.innerHTML =
      '<div class="min-w-0">' +
        '<div class="text-sm font-semibold text-slate-800 truncate">' + escapeHtml(f.name || f.id) + '</div>' +
        '<div class="text-xs text-slate-500 truncate">' + (f.updatedAt ? escapeHtml(formatDate(f.updatedAt)) : '') + '</div>' +
      '</div>';

    // enter button
    var enter = document.createElement('button');
    enter.type = 'button';
    enter.className = 'shrink-0 rounded-lg border px-2 py-1 text-xs font-semibold hover:bg-slate-50';
    enter.setAttribute('data-drive-folder-id', f.id);
    enter.setAttribute('data-drive-folder-name', f.name || f.id);
    enter.textContent = '進入';

    row.appendChild(chk);
    row.appendChild(btn);
    row.appendChild(enter);
    list.appendChild(row);
  });

  syncDriveFolderSelectedCount_();
}

function setActiveDriveFolder(folderId, folderName) {
  driveActiveFolderId = folderId;
  driveActiveFolderName = folderName || folderId;
  var t = document.getElementById('driveFolderIdText');
  if (t) t.textContent = getDriveBreadcrumbText_();

  // clear selection per folder switch
  driveSelectedIds = new Set();
  var selectAll = document.getElementById('driveSelectAll');
  if (selectAll) {
    selectAll.checked = false;
    selectAll.indeterminate = false;
  }

  // refresh folder highlight
  renderDriveFolders(driveFoldersCache);
  try { syncDriveFolderSelectedCount_(); } catch (e) {}
}

async function loadDriveFolders(folderId) {
  $('#driveHint').textContent = '正在從雲端載入資料夾清單…';
  $('#driveHint').classList.remove('hidden');

  try {
    var fid = folderId || driveActiveFolderId || DRIVE_ROOT_FOLDER_ID;
    var url = buildDriveApiUrl('action=listFolders&folderId=' + encodeURIComponent(fid));
    var res = await jsonpRequest(url, 20000);

    if (!res || !res.ok) {
      throw new Error((res && res.message) ? res.message : '資料夾清單載入失敗');
    }

    driveFoldersCache = (res.items || []).map(function(it){
      return {
        id: it.id,
        name: it.name,
        updatedAt: (it.updatedAt || it.lastUpdated || '')
      };
    });

    // sort newest first
    driveFoldersCache.sort(function(a,b){
      var aa = a.updatedAt || '';
      var bb = b.updatedAt || '';
      return aa < bb ? 1 : (aa > bb ? -1 : 0);
    });

    renderDriveFolders(driveFoldersCache);
    $('#driveHint').classList.add('hidden');

  } catch (err) {
    $('#driveHint').textContent = '資料夾清單載入失敗：' + (err && err.message ? err.message : String(err));
    $('#driveHint').classList.remove('hidden');
    driveFoldersCache = [];
    renderDriveFolders([]);
  }
}

async function reloadDriveAll() {
  await driveRefreshCurrentFolder();
}
    async function loadDriveList(folderId) {
  $('#driveHint').textContent = '正在從雲端載入檔案清單…';
  $('#driveHint').classList.remove('hidden');

  try {
    var fid = folderId || driveActiveFolderId;
    if (!fid) {
      renderDriveList([]);
      syncDriveSelectAllState();
      $('#driveHint').classList.add('hidden');
      return;
    }

    var url = buildDriveApiUrl('action=list&folderId=' + encodeURIComponent(fid) + '&types=pdf,excel');
    var res = await jsonpRequest(url, 20000);

    if (!res || !res.ok) {
      throw new Error((res && res.message) ? res.message : '雲端清單載入失敗');
    }

    // 新版 Apps Script list 回傳欄位：id/name/size/url/mimeType/lastUpdated
    // 舊版也可能回傳：sizeBytes/updatedAt
    driveCache = (res.items || [])
      .map(function(it) {
        var name = (it && it.name != null) ? String(it.name) : '';
        var pname = guessNameFromFilename(name);

        var mt = (it && it.mimeType != null) ? String(it.mimeType) : '';
        var kind = '';
        if (mt && mt.indexOf('pdf') >= 0) kind = 'pdf';
        else if (mt && (mt.indexOf('spreadsheet') >= 0 || mt.indexOf('excel') >= 0 || mt.indexOf('ms-excel') >= 0)) kind = 'excel';
        else kind = __driveKind_(name);

        return {
          id: it.id,
          name: name,
          ext: __driveExt_(name),
          kind: kind,
          mimeType: mt,
          sizeBytes: Number(it.sizeBytes || it.size || 0),
          updatedAt: (it.updatedAt || it.lastUpdated || ''),
          productName: pname,
          previewUrl: buildDrivePreviewUrl(it.id),
          openUrl: buildDriveOpenUrl(it.id)
        };
      })
      // 前端也做一次保險過濾：只顯示 PDF/Excel
      .filter(function(it){ return it && (it.kind === 'pdf' || it.kind === 'excel'); });

    driveCacheLoaded = true;
    $('#driveHint').classList.add('hidden');
    renderDriveList(driveCache);
    syncDriveSelectAllState();
  } catch (err) {
    $('#driveHint').textContent = '雲端清單載入失敗：' + (err && err.message ? err.message : String(err));
    $('#driveHint').classList.remove('hidden');
    renderDriveList([]);
    syncDriveSelectAllState();
  }
}


    function base64ToUint8Array(base64) {
      const raw = atob((base64 || '').replace(/\s+/g,''));
      const out = new Uint8Array(raw.length);
      for (let i = 0; i < raw.length; i++) out[i] = raw.charCodeAt(i);
      return out;
    }

    function stripDataUrlPrefix(s) {
      // Accepts "data:application/pdf;base64,...." or plain base64; returns plain base64
      const str = (s || '').trim();
      const idx = str.indexOf('base64,');
      return idx >= 0 ? str.slice(idx + 7).trim() : str;
    }

    let __driveImporting = false;

function setDriveProgress_(show, done, total, filename) {
  var wrap = document.getElementById('driveProgressWrap');
  var bar = document.getElementById('driveProgressBar');
  var pctEl = document.getElementById('driveProgressPct');
  var fileEl = document.getElementById('driveProgressFile');
  var labelEl = document.getElementById('driveProgressLabel');

  if (!wrap || !bar || !pctEl) return;

  if (!show) {
    wrap.classList.add('hidden');
    bar.style.width = '0%';
    pctEl.textContent = '0%';
    if (fileEl) fileEl.textContent = '';
    if (labelEl) labelEl.textContent = '下載中…';
    return;
  }

  wrap.classList.remove('hidden');

  var t = Math.max(0, parseInt(total || 0, 10));
  var d = Math.max(0, parseInt(done || 0, 10));
  var p = (t > 0) ? Math.min(100, Math.round((d / t) * 100)) : 0;

  bar.style.width = p + '%';
  pctEl.textContent = p + '%';
  if (labelEl) labelEl.textContent = '下載進度（' + d + '/' + t + '）';
  if (fileEl) fileEl.textContent = filename ? String(filename) : '';
}

function setDriveProgressLabel_(text) {
  var labelEl = document.getElementById('driveProgressLabel');
  if (!labelEl) return;
  labelEl.textContent = String(text || '下載中…');
}


async function __importDriveItemsCore_(items, opts) {
  opts = opts || {};
  var label = opts.label || '檔案';
  var closeAfter = (opts.closeAfter !== false);
  var onlyPdf = !!opts.onlyPdf;

  var arr = Array.isArray(items) ? items.slice() : [];
  // dedupe by Drive file id
  var seenId = new Set();
  arr = arr.filter(function(it){
    if (!it || !it.id) return false;
    var id = String(it.id);
    if (seenId.has(id)) return false;
    seenId.add(id);
    return true;
  });

  if (!arr.length) {
    alert('找不到可匯入的檔案。');
    return;
  }

  var total = arr.length;

  // A 模式：本次匯入覆蓋
  resetImportContext_();

  // UI
  var driveHint = document.getElementById('driveHint');
  var hintBak = driveHint ? driveHint.textContent : '';
  if (driveHint) {
    driveHint.classList.remove('text-slate-500');
    driveHint.classList.add('text-emerald-700');
  }

  setDriveProgress_(true, 0, total, '');
  setDriveProgressLabel_('下載中…');

  var imported = 0;

  for (var c = 0; c < arr.length; c++) {
    var item = arr[c];

    var kind = item.kind || (item.name ? __driveKind_(item.name) : 'pdf');
    if (onlyPdf && kind !== 'pdf') {
      setDriveProgress_(true, c + 1, total, item.name || '');
      continue;
    }

    var productName = item.productName || guessNameFromFilename(item.name || '');
    var key = normalizeKey(productName);

    // key 解析失敗仍推進進度
    if (!key) {
      setDriveProgress_(true, c + 1, total, item.name || '');
      continue;
    }

    // 先建立 pdfItem（即使下載/轉檔失敗也保留 metadata，方便後續重試 / 復原）
    var pdfItem = {
      displayName: productName,
      id: item.id,
      fileName: item.name || (productName + (kind === 'excel' ? '.xlsx' : '.pdf')),
      blobUrl: item.previewUrl || buildDrivePreviewUrl(item.id),
      openUrl: item.openUrl || buildDriveOpenUrl(item.id),
      sizeBytes: item.sizeBytes || 0,
      updatedAt: item.updatedAt || '',
      source: 'drive',
      driveKind: kind
    };

    pdfStore.set(key, pdfItem);
    lastImportedPdfKey = key;
    try { upsertCurrentImported_(pdfItem); } catch (e) {}

    // 顯示進度
    setDriveProgress_(true, c, total, (pdfItem.fileName || pdfItem.displayName || ''));

    try {
      if (kind === 'excel') {
        // 1) 先看是否已快取（同一份檔案匯入第二次可直接命中）
        setDriveProgressLabel_('檢查離線快取…');
        var cached = await cacheGetPdf_(String(pdfItem.id));
        if (cached && cached.ab) {
          pdfItem.ab = cached.ab;
        } else {
          // 2) 下載 Excel bytes
          setDriveProgressLabel_('下載 Excel…');
          if (driveHint) driveHint.textContent = '下載 Excel（' + (c + 1) + '/' + total + '）：' + (pdfItem.fileName || pdfItem.displayName || '');
          var excelAb = await downloadDrivePdfArrayBufferChunked_(String(pdfItem.id), Number(pdfItem.sizeBytes || 0));

          // 3) Excel -> PDF
          setDriveProgressLabel_('轉檔中（Excel → PDF）…');
          if (driveHint) driveHint.textContent = '轉檔中（Excel → PDF）（' + (c + 1) + '/' + total + '）：' + (pdfItem.fileName || pdfItem.displayName || '');
          var title = (pdfItem.displayName || guessNameFromFilename(pdfItem.fileName || '') || '').trim();
          var pdfAb = await __excelArrayBufferToPdf_(excelAb, { title: title });
          pdfItem.ab = pdfAb;

          // 4) 以 Drive fileId 為 key 寫入 PDF 快取（之後顯示排關圖直接命中）
          try {
            await cachePutPdf_(String(pdfItem.id), pdfItem.ab, {
              name: pdfItem.displayName || pdfItem.fileName || '',
              sizeBytes: Number(pdfItem.sizeBytes || 0),
              updatedAt: pdfItem.updatedAt || '',
              original: 'excel'
            });
          } catch (e) {}
        }

        if (pdfItem.ab) {
          try { pdfItem.cachedBlobUrl = URL.createObjectURL(new Blob([pdfItem.ab], { type: 'application/pdf' })); } catch (e) {}
        }
      } else {
        // PDF：走既有流程（getPdfArrayBuffer 內部會寫入 IndexedDB）
        setDriveProgressLabel_('下載 PDF…');
        if (driveHint) driveHint.textContent = '下載 PDF（' + (c + 1) + '/' + total + '）：' + (pdfItem.fileName || pdfItem.displayName || '');
        var ab = await getPdfArrayBuffer(pdfItem);
        if (ab) {
          try { pdfItem.cachedBlobUrl = URL.createObjectURL(new Blob([ab], { type: 'application/pdf' })); } catch (e) {}
        }
      }
    } catch (e) {
      console.warn('drive import failed:', e);
    } finally {
      setDriveProgressLabel_('下載進度（' + (c + 1) + '/' + total + '）');
      setDriveProgress_(true, c + 1, total, (pdfItem.fileName || pdfItem.displayName || ''));
    }

    imported++;
  }

  // 還原提示文字與進度條
  setDriveProgress_(false, 0, 0, '');

  if (driveHint) {
    driveHint.textContent = hintBak || '提示：已匯入並嘗試快取（若檔案過大，請調整 Apps Script 以支援分段下載）。';
    driveHint.classList.remove('text-emerald-700');
    driveHint.classList.add('text-slate-500');
  }

  if (closeAfter) closeDriveModal();

  // 若使用者已填商品名，立即嘗試顯示「作業工程」橫條
  try { refreshAllProcessStrips(); } catch (e) {}

  alert('已成功匯入排關圖（' + label + '：共 ' + imported + ' 份）');
}

async function importSelectedFromDrive() {
  if (__driveImporting) return;
  __driveImporting = true;
  try {
    var checks = Array.prototype.slice.call(document.querySelectorAll('.driveChk:checked'));
    if (!checks.length) {
      alert('請先勾選至少一個檔案。');
      return;
    }

    var items = [];
    for (var i = 0; i < checks.length; i++) {
      var id = checks[i].getAttribute('data-id');
      if (!id) continue;
      for (var j = 0; j < driveCache.length; j++) {
        if (String(driveCache[j].id) === String(id)) { items.push(driveCache[j]); break; }
      }
    }

    await __importDriveItemsCore_(items, { label: '已勾選檔案' });
  } finally {
    __driveImporting = false;
  }
}

async function __driveFetchFolders_(folderId) {
  var url = buildDriveApiUrl('action=listFolders&folderId=' + encodeURIComponent(String(folderId || '')));
  var res = await jsonpRequest(url, 20000);
  if (!res || !res.ok) throw new Error((res && res.message) ? res.message : '資料夾清單載入失敗');
  return (res.items || []).map(function(it){
    return { id: it.id, name: it.name, updatedAt: (it.updatedAt || it.lastUpdated || '') };
  });
}

function __driveMapListItems_(items) {
  return (items || []).map(function(it){
    var name = (it && it.name != null) ? String(it.name) : '';
    var pname = guessNameFromFilename(name);
    var mt = (it && it.mimeType != null) ? String(it.mimeType) : '';
    var kind = '';
    if (mt && mt.indexOf('pdf') >= 0) kind = 'pdf';
    else if (mt && (mt.indexOf('spreadsheet') >= 0 || mt.indexOf('excel') >= 0 || mt.indexOf('ms-excel') >= 0)) kind = 'excel';
    else kind = __driveKind_(name);

    return {
      id: it.id,
      name: name,
      ext: __driveExt_(name),
      kind: kind,
      mimeType: mt,
      sizeBytes: Number(it.sizeBytes || it.size || 0),
      updatedAt: (it.updatedAt || it.lastUpdated || ''),
      productName: pname,
      previewUrl: buildDrivePreviewUrl(it.id),
      openUrl: buildDriveOpenUrl(it.id)
    };
  });
}

async function __driveFetchFiles_(folderId) {
  // 只抓 PDF，可大幅縮短下載/掃描時間
  var url = buildDriveApiUrl('action=list&folderId=' + encodeURIComponent(String(folderId || '')) + '&types=pdf');
  var res = await jsonpRequest(url, 20000);
  if (!res || !res.ok) throw new Error((res && res.message) ? res.message : '雲端清單載入失敗');
  var mapped = __driveMapListItems_(res.items || []);
  return mapped.filter(function(it){ return it && it.kind === 'pdf'; });
}

async function importSelectedFoldersFromDrive() {
  if (__driveImporting) return;
  __driveImporting = true;

  try {
    var folderIds = Array.from(driveSelectedFolderIds || []);
    if (!folderIds.length) {
      alert('請先在「資料夾」清單勾選至少一個資料夾。');
      return;
    }

    // 掃描資料夾：遞迴收集 PDF
    var driveHint = document.getElementById('driveHint');
    var hintBak = driveHint ? driveHint.textContent : '';
    if (driveHint) {
      driveHint.classList.remove('text-slate-500');
      driveHint.classList.add('text-emerald-700');
      driveHint.textContent = '掃描資料夾中…（含子資料夾）';
    }

    setDriveProgress_(true, 0, 1, '');
    setDriveProgressLabel_('掃描資料夾中…');

    // BFS scan
    var queue = folderIds.map(function(x){ return String(x); }).filter(Boolean);
    var seenFolders = new Set();
    var seenFiles = new Set();
    var out = [];
    var scanned = 0;

    while (queue.length) {
      var fid = queue.shift();
      if (!fid || seenFolders.has(fid)) continue;
      seenFolders.add(fid);
      scanned++;

      try { setDriveProgressLabel_('掃描資料夾中…（已掃描 ' + scanned + ' 個；已找到 ' + out.length + ' 份 PDF）'); } catch (e) {}

      var filesRes = await Promise.allSettled([__driveFetchFiles_(fid), __driveFetchFolders_(fid)]);
      // files
      if (filesRes[0] && filesRes[0].status === 'fulfilled') {
        var files = filesRes[0].value || [];
        files.forEach(function(it){
          var id = it && it.id ? String(it.id) : '';
          if (!id || seenFiles.has(id)) return;
          seenFiles.add(id);
          out.push(it);
        });
      }
      // folders
      if (filesRes[1] && filesRes[1].status === 'fulfilled') {
        var folders = filesRes[1].value || [];
        folders.forEach(function(f){
          var id = f && f.id ? String(f.id) : '';
          if (!id || seenFolders.has(id)) return;
          queue.push(id);
        });
      }

      if (driveHint) driveHint.textContent = '掃描資料夾中…（已掃描 ' + scanned + ' 個；已找到 ' + out.length + ' 份 PDF）';
    }

    if (!out.length) {
      setDriveProgress_(false, 0, 0, '');
      if (driveHint) {
        driveHint.textContent = hintBak || '（掃描完成）';
        driveHint.classList.remove('text-emerald-700');
        driveHint.classList.add('text-slate-500');
      }
      alert('在所選資料夾中找不到任何 PDF。');
      return;
    }

    // 使用既有匯入流程（只匯入 PDF）
    await __importDriveItemsCore_(out, { label: '資料夾 PDF', onlyPdf: true });

  } finally {
    __driveImporting = false;
  }
}


    function deepClone(obj) { return JSON.parse(JSON.stringify(obj)); }

    function todayISO() {
      const d = new Date();
      const pad = (n) => String(n).padStart(2, '0');
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;
    }

    
    function genRid_() {
      return 'r' + Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
    }


function makeEmptyRecord() {
      return {
        rid: genRid_(),
        type: '',
        name: '',
        productName: '',
        date: '',
        notesText: '',
        notesInk: '',
        desc: '',
        images: [],

        // KPI from 排關圖（可自動帶入，也可手動修正）
        plannedOutputHr: '',        // 預計產量(hr)
        manHourProductivity: '',    // 人時生產性
        packagingEquip: '',         // 包裝設備
        packagingCapacityHr: '',    // 包裝機台產能(hr)

        // internal
        _kpiLastKey: '',
        drivePick: null,
        processStepsRows: [],

        // PDF inline prefs
        pdfZoomFactor: 1,
        pdfAnnoMode: false,
        pdfAnnoTool: 'pen',
        pdfAnnoPenColor: '#f97316',
        pdfAnnoPenWidth: 3,
        pdfAnnoStore: {},       // in-memory (loaded/saved via IndexedDB)
        _annoLoadedForKey: '',  // internal
        _activePdfKey: ''
      };
    }


    function displayName(rec, idx) {
      const name = rec && typeof rec.name === 'string' ? rec.name : '';
      const n = name.trim();
      return n ? n : `未命名 ${idx + 1}`;
    }

    function chunk(arr, size) {
      const out = [];
      for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
      return out;
    }

    function fileToDataUrl(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    function getImageSize(dataUrl) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => resolve({ width: img.naturalWidth, height: img.naturalHeight });
        img.src = dataUrl;
      });
    }

    function renderImagePreview(container, images) {
      container.innerHTML = '';
      if (!images || images.length === 0) return;

      if (images.length === 1) {
        const wrap = document.createElement('div');
        wrap.className = 'one-image-wrap rounded-xl border bg-white p-2';
        const img = document.createElement('img');
        img.src = images[0].dataUrl;
        img.alt = images[0].name || 'image';
        wrap.appendChild(img);
        container.appendChild(wrap);
        return;
      }

      const grid = document.createElement('div');
      grid.className = 'grid grid-cols-2 gap-3 sm:grid-cols-3 lg:grid-cols-4';
      images.forEach((it) => {
        const card = document.createElement('div');
        card.className = 'rounded-xl border bg-white p-2';

        const img = document.createElement('img');
        img.src = it.dataUrl;
        img.alt = it.name || 'image';
        img.className = 'h-32 w-full rounded-lg object-cover';

        const meta = document.createElement('div');
        meta.className = 'mt-2 text-[11px] text-slate-500 break-all';
        meta.textContent = it.name || '';

        card.appendChild(img);
        card.appendChild(meta);
        grid.appendChild(card);
      });
      container.appendChild(grid);
    }

    // ---------------- Notes: force-flush handwriting ink before DOM is hidden/removed ----------------
    // iPad/pen users may switch tabs while still drawing; pointerup/cancel may not fire before panel is hidden.
    // To prevent losing the handwriting canvas, we snapshot it to state on tab changes and before re-render.
    function flushNotesInkForIndex(idx) {
      try {
        const i = Number(idx);
        if (!Number.isFinite(i) || !state.records[i]) return;
        const panel = panelsEl.querySelector(`.panel[data-idx="${i}"]`);
        if (!panel) return;
        const canvas = panel.querySelector('.notesCanvas');
        if (canvas) {
          try { state.records[i].notesInk = canvas.toDataURL('image/png'); } catch (_) {}
          // Persist tool just in case
          const tool = String(canvas.dataset.notesTool || '').trim();
          if (tool) state.records[i].notesTool = tool;

          // Persist canvas box height (if any)
          const boxEl = canvas.closest('.notesCanvasBox') || canvas.parentElement;
          if (boxEl) {
            const h = Math.round(boxEl.getBoundingClientRect().height || 0);
            if (h > 0) state.records[i].notesBoxH = h;
          }
        }
      } catch (_) {}
    }

    function flushAllNotesInk() {
      try {
        for (let i = 0; i < state.records.length; i++) flushNotesInkForIndex(i);
      } catch (_) {}
    }

    function setActive(index, opts) {
      const options = opts || { scrollTabIntoView: true };
      const i = Math.max(0, Math.min(index, state.records.length - 1));

      // IMPORTANT: snapshot handwriting ink from current panel before switching.
      if (Number.isFinite(state.active) && state.active !== i) {
        flushNotesInkForIndex(state.active);
      }
      state.active = i;

      $$('.tabBtn', tabsEl).forEach((btn) => {
        const idx = Number(btn.dataset.idx);
        const isOn = idx === i;
        btn.classList.toggle('bg-slate-900', isOn);
        btn.classList.toggle('text-white', isOn);
        btn.classList.toggle('bg-white', !isOn);
        btn.classList.toggle('text-slate-700', !isOn);
        btn.classList.toggle('border-slate-200', !isOn);
        btn.classList.toggle('border-slate-900', isOn);
      });

      $$('.panel', panelsEl).forEach((p) => {
        const idx = Number(p.dataset.idx);
        p.classList.toggle('hidden', idx !== i);
      });

      if (options.scrollTabIntoView) {
        const activeBtn = tabsEl.querySelector(`.tabBtn[data-idx="${i}"]`);
        if (activeBtn) activeBtn.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
      }

      // Reposition floating catalog button after tab changes
      schedulePositionCatalogBtn();
    }

    function updateTabLabel(idx) {
      const el = tabsEl.querySelector(`.tabBtn[data-idx="${idx}"] .tabLabel`);
      if (el) el.textContent = displayName(state.records[idx], idx);
    }

    function updatePanelTitle(panelEl, idx) {
      const t = panelEl.querySelector('.panelTitle');
      if (t) t.textContent = displayName(state.records[idx], idx);
    }

    function removeAt(idx) {
      if (state.records.length <= 1) {
        state.records[0] = makeEmptyRecord();
        renderAll();
        schedulePositionCatalogBtn();
        return;
      }
      state.records.splice(idx, 1);
      if (state.active >= state.records.length) state.active = state.records.length - 1;
      renderAll();
    }

    function duplicateAt(idx) {
      // Snapshot handwriting first to avoid losing ink when DOM is rebuilt.
      flushNotesInkForIndex(state.active);

      const copy = deepClone(state.records[idx]);
      // New record should not share annotation identity
      copy.rid = genRid_();
      copy.pdfAnnoStore = {};
      copy._annoLoadedForKey = '';
      copy._activePdfKey = '';

      state.records.splice(idx + 1, 0, copy);

      const newIdx = idx + 1;
      state.active = newIdx;
      renderAll();

      setActive(newIdx, { scrollTabIntoView: true });
    }

    function addForm(prefill) {
      // Snapshot current handwriting BEFORE changing active / rebuilding DOM.
      // renderAll() will restore canvas ink asynchronously; calling setActive() after that can
      // accidentally overwrite notesInk with a blank canvas if we flush too early.
      flushNotesInkForIndex(state.active);

      const record = prefill ? deepClone(prefill) : makeEmptyRecord();
      state.records.push(record);

      const newIdx = state.records.length - 1;
      state.active = newIdx;
      renderAll();

      // renderAll() already applied active UI (scroll disabled). Call again only to scroll into view.
      setActive(newIdx, { scrollTabIntoView: true });
    }

    function renderAll() {
      // Snapshot handwriting ink before rebuilding DOM (prevents losing in-progress strokes).
      flushAllNotesInk();

      tabsEl.innerHTML = '';
      panelsEl.innerHTML = '';

      state.records.forEach((rec, idx) => {
        // --- Tab button ---
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.dataset.idx = String(idx);
        btn.className = 'tabBtn inline-flex items-center gap-2 rounded-xl border px-3 py-2 text-sm font-semibold mr-2';
        btn.innerHTML = `<span class="tabLabel">${displayName(rec, idx)}</span>`;
        btn.addEventListener('click', () => setActive(idx));
        tabsEl.appendChild(btn);

        // --- Panel ---
        const node = panelTpl.content.cloneNode(true);
        const panel = node.querySelector('article');
        panel.classList.add('panel');
        panel.dataset.idx = String(idx);

        // Record patch helper (define early so below handlers can use it safely)
        const setRecord = (patch) => {
          Object.assign(state.records[idx], patch);
          scheduleSaveState_();
        };

        const typeInput   = $('.typeInput', panel);
        const nameInput   = $('.nameInput', panel);

        const kpiPlannedOutputInput = panel.querySelector('.kpiPlannedOutputInput');
        const kpiManHourInput       = panel.querySelector('.kpiManHourInput');
        const kpiPackEquipInput     = panel.querySelector('.kpiPackEquipInput');
        const kpiPackCapInput       = panel.querySelector('.kpiPackCapInput');
        const kpiHint               = panel.querySelector('.kpiHint');

        const suggestBox  = panel.querySelector('.suggestBox');
        const descInput   = $('.descInput', panel);
        const processStepsWrap = panel.querySelector('.processStepsWrap');
        const processStepsTable = panel.querySelector('.processStepsTable');
        const processStepsHint  = panel.querySelector('.processStepsHint');
                const processLoading    = panel.querySelector('.processLoading');
const processPreviewWrap = panel.querySelector('.processStepsPreviewWrap');
        const processPreviewImg  = panel.querySelector('.processStepsPreviewImg');
        const processRefreshBtn  = panel.querySelector('.processRefreshBtn');

        const imgInput    = $('.imgInput', panel);
        const imgHint     = $('.imgHint', panel);
        const imgPreview  = $('.imgPreview', panel);

        // Notes: typing
        const notesTextInput = $('.notesTextInput', panel);

        // Init values
        typeInput.value = rec.type || '';
        nameInput.value = rec.name || '';
        try { setTimeout(() => { try { if (nameInput && nameInput.value) scheduleKpiRefresh(false); } catch (e) {} }, 0); } catch (e) {}
        descInput.value = rec.desc || '';

        // KPI init
        if (kpiPlannedOutputInput) kpiPlannedOutputInput.value = rec.plannedOutputHr || '';
        if (kpiManHourInput)       kpiManHourInput.value       = rec.manHourProductivity || '';
        if (kpiPackEquipInput)     kpiPackEquipInput.value     = rec.packagingEquip || '';
        if (kpiPackCapInput)       kpiPackCapInput.value       = rec.packagingCapacityHr || '';


        // Panel title
        updatePanelTitle(panel, idx);
        // ---- Notes: typing ----
        if (notesTextInput) {
          notesTextInput.value = rec.notesText || '';
          notesTextInput.addEventListener('input', (e) => setRecord({ notesText: (e.target.value || '') }));
        }

        // ---- Images preview ----
        if (rec.images && rec.images.length) {
          imgHint.textContent = `已選擇 ${rec.images.length} 張圖片。`;
          renderImagePreview(imgPreview, rec.images);
        }

        // ---- Inputs handlers ----
        typeInput.addEventListener('change', (e) => setRecord({ type: (e.target.value || '') }));

        // Name input: update record + update tab/title + suggestions
        const applyPickedName = (picked) => {
          nameInput.value = picked;
          setRecord({ name: picked, productName: picked });
          updateTabLabel(idx);
          updatePanelTitle(panel, idx);
          hideSuggestBox(suggestBox);
          try { scheduleKpiRefresh(true); } catch (e) {}
          
        };

        // ---- KPI（排關圖自動帶入） ----
        let __kpiReqId = 0;
        let __kpiTimer = null;

        const applyKpiToUI_ = (patch) => {
          const r = state.records[idx] || {};
          const vPlanned = (patch && patch.plannedOutputHr != null) ? patch.plannedOutputHr : (r.plannedOutputHr || '');
          const vMan     = (patch && patch.manHourProductivity != null) ? patch.manHourProductivity : (r.manHourProductivity || '');
          const vEq      = (patch && patch.packagingEquip != null) ? patch.packagingEquip : (r.packagingEquip || '');
          const vCap     = (patch && patch.packagingCapacityHr != null) ? patch.packagingCapacityHr : (r.packagingCapacityHr || '');

          if (kpiPlannedOutputInput) kpiPlannedOutputInput.value = vPlanned;
          if (kpiManHourInput)       kpiManHourInput.value       = vMan;
          if (kpiPackEquipInput)     kpiPackEquipInput.value     = vEq;
          if (kpiPackCapInput)       kpiPackCapInput.value       = vCap;
        };

        const setKpiHint_ = (msg) => {
          if (!kpiHint) return;
          if (msg) {
            kpiHint.textContent = String(msg);
            kpiHint.classList.remove('hidden');
          } else {
            kpiHint.textContent = '';
            kpiHint.classList.add('hidden');
          }
        };

        const clearKpiHint_ = () => setKpiHint_('');

        const refreshKpiPanel = async (force) => {
          const myId = ++__kpiReqId;
          const nameNow = (nameInput && nameInput.value) ? String(nameInput.value).trim() : '';
          if (!nameNow) {
            clearKpiHint_();
            return;
          }

          const key = normalizeKey(nameNow);
          // KPI hint: only show on failure
          clearKpiHint_();

          let kpi = key ? kpiStore.get(key) : null;

          if (!kpi) {
            const pdfItem = findPdfForProductName(nameNow);
            try {
              if (pdfItem) {
                if (pdfItem.source === 'excel' && pdfItem.excelAb) {
                  kpi = await extractKpiFromExcel(pdfItem.excelAb);
                } else if (pdfItem.ab) {
                  kpi = await extractKpiFromPdf(pdfItem.ab);
                }
                if (kpi && key) {
                  kpiStore.set(key, { ...kpi, source: (pdfItem.source || 'local'), updatedAt: Date.now() });
                }
              }
            } catch (e) {
              console.warn('refreshKpiPanel failed:', e);
            }
          }

          if (myId != __kpiReqId) return;

          if (!kpi) {
            setKpiHint_('未找到對應排關圖 KPI（請確認已匯入 PDF/Excel，且商品名相符）');
            return;
          }

          const recNow = state.records[idx] || {};
          const lastKey = recNow._kpiLastKey || '';
          const nameChanged = (lastKey && lastKey !== key);
          const overwriteAll = !!force || !lastKey || nameChanged;

          const patch = { _kpiLastKey: key };
          if (overwriteAll || !recNow.plannedOutputHr)     patch.plannedOutputHr     = (kpi.plannedOutputHr || '');
          if (overwriteAll || !recNow.manHourProductivity) patch.manHourProductivity = (kpi.manHourProductivity || '');
          if (overwriteAll || !recNow.packagingEquip)      patch.packagingEquip      = (kpi.packagingEquip || '');
          if (overwriteAll || !recNow.packagingCapacityHr) patch.packagingCapacityHr = (kpi.packagingCapacityHr || '');

          setRecord(patch);
          applyKpiToUI_(patch);

          // 成功帶入時不顯示訊息
          clearKpiHint_();
        };

        const scheduleKpiRefresh = (force) => {
          if (__kpiTimer) clearTimeout(__kpiTimer);
          __kpiTimer = setTimeout(() => refreshKpiPanel(!!force), 350);
        };

        // expose for global refresh after 匯入排關圖
        panel.__refreshKpiPanel = (force) => refreshKpiPanel(!!force);

        // KPI manual edit -> update record (does not auto-overwrite unless name changes)
        // KPI 欄位為唯讀：不允許手動編輯
        // if (kpiPlannedOutputInput) kpiPlannedOutputInput.addEventListener('input', (e) => setRecord({ plannedOutputHr: (e.target.value || '') }));
        // if (kpiManHourInput)       kpiManHourInput.addEventListener('input', (e) => setRecord({ manHourProductivity: (e.target.value || '') }));
        // if (kpiPackEquipInput)     kpiPackEquipInput.addEventListener('input', (e) => setRecord({ packagingEquip: (e.target.value || '') }));
        // if (kpiPackCapInput)       kpiPackCapInput.addEventListener('input', (e) => setRecord({ packagingCapacityHr: (e.target.value || '') }));



        
// ---- 作業工程（從排關圖擷取 -> 可編輯表格） ----
let __procReqId = 0;
let __procTimer = null;

const clearProcessUI = () => {
  if (processStepsWrap) processStepsWrap.classList.add('hidden');
  if (processStepsHint) processStepsHint.textContent = '';  if (processStepsHint) processStepsHint.classList.add('hidden');
  if (processLoading) { processLoading.classList.add('hidden'); processLoading.textContent = ''; }
  if (processStepsTable) processStepsTable.innerHTML = '';
  if (processPreviewImg) processPreviewImg.removeAttribute('src');
  if (processPreviewWrap) processPreviewWrap.classList.add('hidden');
};

const escapeHtml = (s) => String(s || '')
  .replace(/&/g, '&amp;').replace(/</g, '&lt;')
  .replace(/>/g, '&gt;').replace(/"/g, '&quot;')
  .replace(/'/g, '&#39;');


const renderProcessTable = (data) => {
  if (!processStepsTable) return;

  const fromCols = (data && data.columns && Array.isArray(data.columns) && data.columns.length)
    ? data.columns
    : null;

  // Normalize to rows: { no, step, man, time, manOk, manActual, timeOk, timeActual }
  let rows = [];
  if (fromCols) {
    // old format: [ [no], [step], [man], [time] ]
    const col0 = data.columns[0] || [];
    const col1 = data.columns[1] || [];
    const col2 = data.columns[2] || [];
    const col3 = data.columns[3] || [];
    const n = Math.max(col0.length, col1.length, col2.length, col3.length);
    for (let i = 0; i < n; i++) {
      rows.push({
        no: (col0[i] ?? ''),
        step: (col1[i] ?? ''),
        man: (col2[i] ?? ''),
        time: (col3[i] ?? ''),
        manOk: false,
        manActual: '',
        timeOk: false,
        timeActual: '',
        note: '',
      });
    }
  } else {
    rows = (data && data.rows && Array.isArray(data.rows)) ? data.rows : [];
  }

  // Merge with saved edits if present
  const savedRows = (state.records[idx] && state.records[idx].processStepsRows) ? state.records[idx].processStepsRows : null;
  if (savedRows && Array.isArray(savedRows) && savedRows.length && rows && rows.length) {
    const map = new Map(savedRows.map(r => [String(r.no ?? ''), r]));
    rows = rows.map(r => {
      const key = String(r.no ?? '');
      const s = map.get(key);
      return s ? ({
        ...r,
        step: (s.step ?? r.step),
        man: (s.man ?? r.man),
        time: (s.time ?? r.time),
        manOk: !!s.manOk,
        manActual: (s.manActual ?? ''),
        timeOk: !!s.timeOk,
        timeActual: (s.timeActual ?? ''),
        note: (s.note ?? r.note ?? ''),
      }) : r;
    });
  } else if (savedRows && Array.isArray(savedRows) && savedRows.length && (!rows || !rows.length)) {
    rows = savedRows;
  }

  // Summary (prefer extracted summary -> saved summary -> computed)
  const savedSummary = (state.records[idx] && state.records[idx].processStepsSummary) ? state.records[idx].processStepsSummary : null;
  const inSummary = (data && data.summary) ? data.summary : null;

  const toInt = (v) => {
    const n = parseInt(String(v ?? '').replace(/[^\d\-]/g,''), 10);
    return Number.isFinite(n) ? n : 0;
  };
  const toFloat = (v) => {
    const s = String(v ?? '').trim();
    const n = parseFloat(s);
    return Number.isFinite(n) ? n : 0;
  };

  const computedRequired = rows.reduce((acc, r) => acc + toInt(r.man), 0);
  const computedTotalTime = rows.reduce((acc, r) => acc + toFloat(r.time), 0);

  const summary = {
    requiredPeople: (inSummary && inSummary.requiredPeople != null) ? toInt(inSummary.requiredPeople)
      : (savedSummary && savedSummary.requiredPeople != null) ? toInt(savedSummary.requiredPeople)
      : computedRequired,
    totalPeople: (inSummary && inSummary.totalPeople != null) ? toInt(inSummary.totalPeople)
      : (savedSummary && savedSummary.totalPeople != null) ? toInt(savedSummary.totalPeople)
      : computedRequired,
    totalTime: (inSummary && inSummary.totalTime != null) ? toFloat(inSummary.totalTime)
      : (savedSummary && savedSummary.totalTime != null) ? toFloat(savedSummary.totalTime)
      : computedTotalTime,
  };

  // Persist summary for this record
  state.records[idx].processStepsSummary = summary;
  saveState();

  // Determine max standard time for highlighting
  const timeNums = rows.map(r => toFloat(r.time)).filter(v => Number.isFinite(v) && v > 0);
  const maxTime = timeNums.length ? Math.max(...timeNums) : null;

  const buildCellGroup = (prefix, r) => {
    const std = escapeHtml(r[prefix] ?? '');
    const ok  = !!r[prefix + 'Ok'];
    const act = escapeHtml(r[prefix + 'Actual'] ?? '');
    const inputType = (prefix === 'man' || prefix === 'time') ? 'number' : 'text';
    const stepAttr = (prefix === 'man') ? 'step="1"' : 'step="0.01"';
    const inputMode = (prefix === 'man') ? 'numeric' : 'decimal';

    const stdVal = (prefix === 'time') ? toFloat(r.time) : null;
    const isMax = (prefix === 'time' && maxTime != null && Number.isFinite(stdVal) && stdVal === maxTime);

    const stdCls = [
      'procStd',
      'tabular-nums',
      'text-center',
      'px-2','py-0.5',
      'rounded-lg',
      'border',
      'border-slate-200',
      'bg-slate-50',
      'text-base'
    ].concat(isMax ? ['!text-red-600','font-bold','!border-red-200','!bg-red-50'] : []).join(' ');

    return `
      <div class="grid grid-cols-3 gap-2 items-center">
        <div class="text-center text-sm font-semibold text-slate-500">標準</div>
        <div class="text-center text-sm font-semibold text-slate-500">符合</div>
        <div class="text-center text-sm font-semibold text-slate-500">實際</div>

        <div class="${stdCls}" contenteditable="true" data-col="${prefix}">${std}</div>
        <div class="text-center">
          <input class="procCheck h-5 w-5 align-middle" type="checkbox" data-col="${prefix}Ok" ${ok ? 'checked' : ''} />
        </div>
        <div class="text-center">
          <input class="procActual w-full max-w-[160px] rounded-lg border border-slate-200 bg-white px-2 py-0.5 text-base text-slate-800 focus:outline-none focus:ring focus:ring-slate-200"
                 type="${inputType}" ${stepAttr} inputmode="${inputMode}" data-col="${prefix}Actual" value="${act}" />
        </div>
      </div>
    `;
  };

  const fmt1 = (v) => {
    const n = Number(v);
    if (!Number.isFinite(n)) return '';
    // keep at most 2 decimals, trim trailing zeros
    return (Math.round(n * 100) / 100).toString();
  };

  const html = `
    <div class="space-y-3">
      ${rows.map((r, i) => {
        const no = escapeHtml(r.no ?? (i + 1));
        const step = escapeHtml(r.step ?? '');
        return `
          <div class="procRow grid grid-cols-1 lg:grid-cols-12 gap-3" data-no="${no}">
            <!-- 左：項次＋工程（同一框） -->
            <div class="lg:col-span-4 rounded-2xl border border-slate-200 bg-white p-2 shadow-sm">
              <div class="flex items-center gap-3 mb-1.5">
                <div class="procNo h-9 w-9 shrink-0 rounded-xl bg-slate-900 text-white flex items-center justify-center text-sm font-bold tabular-nums" data-col="no">${no}</div>
                <div class="min-w-0">
                  <div class="text-sm font-semibold text-slate-500">項次／工程</div>
                </div>
              </div>
              <div class="procStepText rounded-xl border border-slate-200 bg-white px-3 py-1.5 text-base text-slate-800" data-col="step">${step}</div>
            </div>

            <!-- 中：人數（單獨一框） -->
            <div class="lg:col-span-3 rounded-2xl border border-slate-200 bg-white p-2 shadow-sm">
              <div class="flex items-center justify-between mb-1.5">
                <div class="text-base font-semibold text-slate-700">人數</div>
                ${i === 0 ? '<label class="inline-flex items-center gap-2 select-none">' +
                  '<input class="procAllOk h-4 w-4" type="checkbox" data-all="man" />' +
                  '<span class="text-sm font-semibold text-emerald-700">皆符合</span>' +
                '</label>' : ''}
              </div>
              ${buildCellGroup('man', r)}
            </div>

            <!-- 右：作業時間（單獨一框） -->
            <div class="lg:col-span-3 rounded-2xl border border-slate-200 bg-white p-2 shadow-sm">
              <div class="flex items-center justify-between mb-1.5">
                <div class="text-base font-semibold text-slate-700">作業時間</div>
                ${i === 0 ? '<label class="inline-flex items-center gap-2 select-none">' +
                  '<input class="procAllOk h-4 w-4" type="checkbox" data-all="time" />' +
                  '<span class="text-sm font-semibold text-emerald-700">皆符合</span>' +
                '</label>' : ''}
              </div>
              ${buildCellGroup('time', r)}
            </div>

            <!-- 右：紀錄（打字） -->
            <div class="lg:col-span-2 rounded-2xl border border-slate-200 bg-white p-2 shadow-sm">
              <div class="flex items-center justify-between mb-1.5">
                <div class="text-base font-semibold text-slate-700">紀錄</div>
              </div>
              <textarea class="procNote w-full rounded-xl border border-slate-200 bg-white px-3 py-1.5 text-sm text-slate-800 focus:outline-none focus:ring focus:ring-slate-200" rows="3" data-col="note" placeholder="可記錄此項需注意/確認事項" style="resize: vertical;">${escapeHtml(r.note ?? '')}</textarea>
            </div>
          </div>
        `;
      }).join('')}

      <!-- Summary row -->
      <div class="grid grid-cols-1 lg:grid-cols-12 gap-3">
        <div class="lg:col-span-4"></div>

        <div class="lg:col-span-3 rounded-2xl border border-slate-200 bg-white p-2 shadow-sm">
          <div class="grid grid-cols-3 rounded-xl overflow-hidden border border-slate-200 text-base">
            <div class="bg-slate-100 px-2 py-1.5 font-semibold text-slate-700">所需人數</div>
            <div class="bg-emerald-50 px-2 py-1.5 font-bold tabular-nums text-center text-slate-900">${escapeHtml(summary.requiredPeople)}</div>
            <div class="bg-slate-100 px-2 py-1.5 text-center text-slate-700">人</div>

            <div class="bg-slate-100 px-2 py-1.5 font-semibold text-slate-700 border-t border-slate-200">總計人數</div>
            <div class="bg-emerald-50 px-2 py-1.5 font-bold tabular-nums text-center text-slate-900 border-t border-slate-200">${escapeHtml(summary.totalPeople)}</div>
            <div class="bg-slate-100 px-2 py-1.5 text-center text-slate-700 border-t border-slate-200">人</div>
          </div>
        </div>

        <div class="lg:col-span-3 rounded-2xl border border-slate-200 bg-white p-2 shadow-sm">
          <div class="grid grid-cols-2 rounded-xl overflow-hidden border border-slate-200 text-base">
            <div class="bg-slate-100 px-2 py-1.5 font-semibold text-slate-700">總作業時間(S)</div>
            <div class="bg-emerald-50 px-2 py-1.5 font-bold tabular-nums text-center text-slate-900">${escapeHtml(fmt1(summary.totalTime))}</div>
          </div>
        </div>

        <div class="lg:col-span-2"></div>
      </div>
    </div>
  `;

  processStepsTable.innerHTML = html;

  // Ensure consistent styling for step text
  processStepsTable.querySelectorAll('.procStepText').forEach(el => {
    el.classList.add('min-h-[40px]', 'leading-snug');
  });

  const refreshMaxTimeHighlight = () => {
    const stdEls = Array.from(processStepsTable.querySelectorAll('[data-col="time"].procStd'));
    const vals = stdEls
      .map(el => {
        const v = parseFloat(String(el.textContent || '').trim());
        return Number.isFinite(v) ? v : null;
      })
      .filter(v => v != null);
    if (!vals.length) return;
    const mx = Math.max(...vals);

    stdEls.forEach(el => {
      const v = parseFloat(String(el.textContent || '').trim());
      const isMaxNow = Number.isFinite(v) && v === mx;
      el.classList.toggle('!text-red-600', isMaxNow);
      el.classList.toggle('font-bold', isMaxNow);
      el.classList.toggle('!border-red-200', isMaxNow);
      el.classList.toggle('!bg-red-50', isMaxNow);
    });
  };

  const saveNow = () => {
    const out = [];
    const rowsEls = processStepsTable.querySelectorAll('.procRow');
    rowsEls.forEach((rowEl) => {
      const no = (rowEl.querySelector('[data-col="no"]')?.textContent || rowEl.getAttribute('data-no') || '').trim();
      const step = (rowEl.querySelector('[data-col="step"]')?.textContent || '').trim();

      const man = (rowEl.querySelector('[data-col="man"]')?.textContent || '').trim();
      const manOk = !!rowEl.querySelector('[data-col="manOk"]')?.checked;
      const manActual = (rowEl.querySelector('[data-col="manActual"]')?.value || '').trim();

      const time = (rowEl.querySelector('[data-col="time"]')?.textContent || '').trim();
      const timeOk = !!rowEl.querySelector('[data-col="timeOk"]')?.checked;
      const timeActual = (rowEl.querySelector('[data-col="timeActual"]')?.value || '').trim();
      const note = (rowEl.querySelector('[data-col="note"]')?.value || '').trim();

      out.push({ no, step, man, manOk, manActual, time, timeOk, timeActual, note });
    });

    state.records[idx].processStepsRows = out;

    // recompute computed totals if user edits standards
    const req = out.reduce((acc, r) => acc + toInt(r.man), 0);
    const tSum = out.reduce((acc, r) => acc + toFloat(r.time), 0);
    state.records[idx].processStepsSummary = {
      requiredPeople: (inSummary && inSummary.requiredPeople != null) ? toInt(inSummary.requiredPeople) : req,
      totalPeople: (inSummary && inSummary.totalPeople != null) ? toInt(inSummary.totalPeople) : req,
      totalTime: (inSummary && inSummary.totalTime != null) ? toFloat(inSummary.totalTime) : tSum,
    };

    saveState();
  };

  // Bind editing + highlight updates
  processStepsTable.querySelectorAll('[contenteditable="true"]').forEach(el => {
    el.addEventListener('input', () => {
      saveNow();
      if (el.getAttribute('data-col') === 'time') refreshMaxTimeHighlight();
    });
    el.addEventListener('blur', () => {
      saveNow();
      if (el.getAttribute('data-col') === 'time') refreshMaxTimeHighlight();
    });
  });
  const syncAllOk = (kind) => {
    const checks = Array.from(processStepsTable.querySelectorAll(`input.procCheck[data-col="${kind}Ok"]`));
    const masters = Array.from(processStepsTable.querySelectorAll(`input.procAllOk[data-all="${kind}"]`));
    if (!masters.length) return;

    if (!checks.length) {
      masters.forEach(m => { m.checked = false; m.indeterminate = false; });
      return;
    }
    const any = checks.some(c => c.checked);
    const all = checks.every(c => c.checked);
    masters.forEach(m => {
      m.checked = all;
      // 用半選狀態表示「部分符合」
      m.indeterminate = any && !all;
    });
  };

  // master toggle: 勾選後整欄位的「符合」全選/全不選
  processStepsTable.querySelectorAll('input.procAllOk').forEach(m => {
    m.addEventListener('change', () => {
      const kind = m.getAttribute('data-all');
      const checked = !!m.checked;
      processStepsTable.querySelectorAll(`input.procCheck[data-col="${kind}Ok"]`).forEach(cb => { cb.checked = checked; });
      saveNow();
      syncAllOk(kind);
    });
  });

  processStepsTable.querySelectorAll('input.procCheck, input.procActual, textarea.procNote').forEach(el => {
    el.addEventListener('change', () => {
      saveNow();
      if (el.classList.contains('procCheck')) {
        const col = el.getAttribute('data-col') || '';
        if (col === 'manOk') syncAllOk('man');
        if (col === 'timeOk') syncAllOk('time');
      }
    });
    el.addEventListener('input', () => saveNow());
  });

  // initial refresh
  refreshMaxTimeHighlight();
  syncAllOk('man');
  syncAllOk('time');
};


const refreshProcessSteps = async (force = false) => {
  if (!processStepsWrap) return;

  const nameNow = (state.records[idx] && state.records[idx].name) ? String(state.records[idx].name).trim() : '';
  const myId = ++__procReqId;

  if (!nameNow) { clearProcessUI(); if (processStepsHint) { processStepsWrap.classList.remove('hidden'); processStepsHint.classList.remove('hidden'); processStepsHint.textContent = '請先填寫商品名'; } return; }

  const pdfItem = findPdfForProductName(nameNow);
  if (!pdfItem) { clearProcessUI(); processStepsWrap.classList.remove('hidden'); if (processStepsHint) processStepsHint.classList.remove('hidden'); processStepsHint.textContent = '找不到對應排關圖（請先匯入排關圖或確認檔名）'; return; }

  processStepsWrap.classList.remove('hidden');
  if (processLoading) { processLoading.classList.remove('hidden'); processLoading.textContent = '載入中…'; }

  if (processStepsHint) { processStepsHint.classList.remove('hidden'); processStepsHint.textContent = '載入中...'; }

  const endLoading = () => {
    // 只在這次請求仍是最新請求時才關閉 Loading，避免覆蓋後續請求的狀態
    if (myId !== __procReqId) return;
    if (processLoading) { processLoading.classList.add('hidden'); processLoading.textContent = ''; }
  };

  let result = null;
  try {
    result = await getProcessTableForProduct(nameNow, { force });
  } catch (err) {
    result = { ok: false, message: (err && err.message) ? String(err.message) : String(err) };
  }

  if (myId !== __procReqId) return; // stale

  try {
    const safeRender = (payload) => {
      try {
        renderProcessTable(payload);
        return true;
      } catch (e) {
        console.error(e);
        if (processStepsWrap) processStepsWrap.classList.remove('hidden');
        if (processStepsTable) processStepsTable.innerHTML = '';
        if (processStepsHint) { processStepsHint.classList.remove('hidden'); processStepsHint.textContent = '作業工程呈現失敗：' + (e && e.message ? e.message : String(e)); }
        return false;
      }
    };

    if (result && result.ok && result.rows && result.rows.length) {
      safeRender({ rows: result.rows, summary: result.summary });
      if (processStepsHint && processStepsHint.textContent === '載入中...') { processStepsHint.textContent = ''; processStepsHint.classList.add('hidden'); }
    } else {
      // fallback: show last saved record edits if any
      const savedRows = (state.records[idx] && state.records[idx].processStepsRows) ? state.records[idx].processStepsRows : null;
      const savedLegacy = (state.records[idx] && state.records[idx].processSteps) ? state.records[idx].processSteps : null;

      if (savedRows && savedRows.length) safeRender({ rows: savedRows });
      else if (savedLegacy && savedLegacy.length) safeRender({ columns: savedLegacy });
      else safeRender({ rows: [] });

      if (processStepsHint) {
        processStepsHint.classList.remove('hidden');
        processStepsHint.textContent = (result && result.message)
          ? String(result.message)
          : '（無法擷取作業工程；若為雲端匯入，請確認 Apps Script 已支援 action=download / chunk 且已重新部署）';
      }
    }
  } catch (uiErr) {
    console.error(uiErr);
    if (processStepsWrap) processStepsWrap.classList.remove('hidden');
    if (processStepsTable) processStepsTable.innerHTML = '';
    if (processStepsHint) { processStepsHint.classList.remove('hidden'); processStepsHint.textContent = '作業工程處理失敗：' + (uiErr && uiErr.message ? uiErr.message : String(uiErr)); }
  }

    // 來源預覽（若已隱藏，此段不會影響）
  finally {
    endLoading();
  }
};

const scheduleProcessSteps = () => {
  if (__procTimer) clearTimeout(__procTimer);
  __procTimer = setTimeout(() => refreshProcessSteps(false), 350);
};

// Expose for global refresh after 匯入排關圖
panel.__refreshProcessStrip = () => refreshProcessSteps(true);
// Initial render disabled (manual trigger only)
if (processRefreshBtn) {
  processRefreshBtn.addEventListener('click', () => refreshProcessSteps(true));
}


        nameInput.addEventListener('input', (e) => {
          const v = (e.target.value || '');
          setRecord({ name: v, productName: v });
          updateTabLabel(idx);
          updatePanelTitle(panel, idx);

          const hits = suggestProductNames(v, 8);
          renderSuggestBox(suggestBox, hits, applyPickedName);
          try { scheduleKpiRefresh(false); } catch (e) {}
          
        });

        nameInput.addEventListener('focus', () => {
          const hits = suggestProductNames(nameInput.value || '', 8);
          renderSuggestBox(suggestBox, hits, applyPickedName);
        });

        nameInput.addEventListener('blur', () => {
          // Delay so mousedown on an item can run first
          setTimeout(() => hideSuggestBox(suggestBox), 150);
        });

        descInput.addEventListener('input', (e) => setRecord({ desc: (e.target.value || '') }));

        // ---- Show PDF (inline) ----
const showPdfBtn = panel.querySelector('.showPdfBtn');
const pdfInlineWrap = panel.querySelector('.pdfInlineWrap');
const pdfInlineRender = panel.querySelector('.pdfInlineRender');
const closePdfInlineBtn = panel.querySelector('.closePdfInlineBtn');
const pdfZoomInBtn = panel.querySelector('.pdfZoomIn');
const pdfZoomOutBtn = panel.querySelector('.pdfZoomOut');
const pdfFitBtn = panel.querySelector('.pdfFit');
const pdfAnnoToggleBtn = panel.querySelector('.pdfAnnoToggle');
const pdfPenSizeBtn = panel.querySelector('.pdfPenSizeBtn');
const pdfPenColorBtn = panel.querySelector('.pdfPenColorBtn');
const pdfPenSettings = panel.querySelector('.pdfPenSettings');
const pdfPenSizeRange = panel.querySelector('.pdfPenSizeRange');
const pdfPenSizeValue = panel.querySelector('.pdfPenSizeValue');
const pdfPenColorPicker = panel.querySelector('.pdfPenColorPicker');
const pdfPenColorValue = panel.querySelector('.pdfPenColorValue');
const pdfPenSettingsClose = panel.querySelector('.pdfPenSettingsClose');
const pdfPenColorSwatches = panel.querySelectorAll('.pdfPenColorSwatch');

const pdfAnnoClearBtn = panel.querySelector('.pdfAnnoClear');
const pdfAnnoEraserBtn = panel.querySelector('.pdfAnnoEraser');
const pdfDownloadBtn = panel.querySelector('.pdfDownloadBtn');

function ensurePdfPrefs_() {
  const rec = state.records[idx];
  if (!rec) return;
  if (typeof rec.pdfZoomFactor !== 'number' || !Number.isFinite(rec.pdfZoomFactor)) rec.pdfZoomFactor = 1.25; // iPad 友善：預設稍微放大
  if (typeof rec.pdfAnnoMode !== 'boolean') rec.pdfAnnoMode = false;
  if (!rec.pdfAnnoStore || typeof rec.pdfAnnoStore !== 'object') rec.pdfAnnoStore = {};
  if (!rec.pdfAnnoTool) rec.pdfAnnoTool = 'pen';

  // Pen settings (persist per form)
  if (typeof rec.pdfAnnoPenWidth !== 'number' || !Number.isFinite(rec.pdfAnnoPenWidth)) rec.pdfAnnoPenWidth = 3;
  rec.pdfAnnoPenWidth = Math.max(1, Math.min(12, Math.round(rec.pdfAnnoPenWidth)));

  if (!rec.pdfAnnoPenColor || typeof rec.pdfAnnoPenColor !== 'string') rec.pdfAnnoPenColor = '#f97316';
  if (!/^#([0-9a-fA-F]{6})$/.test(rec.pdfAnnoPenColor)) rec.pdfAnnoPenColor = '#f97316';
}

function updatePdfInlineControls_() {
  ensurePdfPrefs_();
  const rec = state.records[idx];

  // Pen (toggle draw layer ON/OFF; and switch back from eraser -> pen)
  if (pdfAnnoToggleBtn) {
    const penActive = rec.pdfAnnoMode && rec.pdfAnnoTool === 'pen';
    pdfAnnoToggleBtn.classList.toggle('is-active', penActive);
    pdfAnnoToggleBtn.setAttribute('aria-pressed', penActive ? 'true' : 'false');
    pdfAnnoToggleBtn.textContent = (rec.pdfAnnoMode && penActive) ? '畫筆中' : '畫筆';
  }

  // Pen settings UI
  if (pdfPenSizeRange) pdfPenSizeRange.value = String(rec.pdfAnnoPenWidth);
  if (pdfPenSizeValue) pdfPenSizeValue.textContent = String(rec.pdfAnnoPenWidth);

  const penColor = String(rec.pdfAnnoPenColor || '#f97316');
  if (pdfPenColorPicker) pdfPenColorPicker.value = penColor;
  if (pdfPenColorValue) pdfPenColorValue.textContent = penColor.toLowerCase();

  if (pdfPenColorSwatches && pdfPenColorSwatches.length) {
    pdfPenColorSwatches.forEach((btn) => {
      const c = String(btn.getAttribute('data-color') || '').toLowerCase();
      const on = (c && c === penColor.toLowerCase());
      btn.classList.toggle('ring-2', on);
      btn.classList.toggle('ring-slate-700', on);
    });
  }

  // Eraser only meaningful when annotation layer is on
  if (pdfAnnoEraserBtn) {
    pdfAnnoEraserBtn.classList.toggle('btn-disabled', !rec.pdfAnnoMode);
    pdfAnnoEraserBtn.classList.toggle('is-active', rec.pdfAnnoMode && rec.pdfAnnoTool === 'eraser');
    pdfAnnoEraserBtn.setAttribute('aria-pressed', (rec.pdfAnnoMode && rec.pdfAnnoTool === 'eraser') ? 'true' : 'false');
  }

  if (pdfAnnoClearBtn) {
    pdfAnnoClearBtn.classList.toggle('btn-disabled', !rec.pdfAnnoMode);
  }

  // Sync fullscreen floating toolbar (if exists)
  try {
    if (pdfInlineWrap && pdfInlineWrap._fsUi && typeof pdfInlineWrap._fsUi.sync === 'function') pdfInlineWrap._fsUi.sync();
  } catch (_) {}
}

function showInlinePdf(show) {
  if (!pdfInlineWrap) return;
  pdfInlineWrap.classList.toggle('hidden', !show);
  if (show) {
    // slightly delayed to ensure layout is ready
    setTimeout(() => {
      try { pdfInlineWrap.scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch (_) {}
    }, 50);
  }
}

function collapseInlinePdf_() {
  try {
    if (pdfInlineWrap && pdfInlineWrap.classList.contains('is-fullscreen')) {
      try { exitPdfFullscreen_(); } catch (_) {}
    }
  } catch (_) {}

  // Hide any open settings/panels
  try { if (pdfPenSettings) pdfPenSettings.classList.add('hidden'); } catch (_) {}
  try {
    if (pdfInlineWrap && pdfInlineWrap._fsUi) {
      const ui = pdfInlineWrap._fsUi;
      if (ui && ui.panel) ui.panel.classList.add('hidden');
    }
  } catch (_) {}

  showInlinePdf(false);

  // Return focus back to the form area (similar to normal collapse behavior)
  try {
    setTimeout(() => {
      try { (showPdfBtn || panel).scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch (_) {}
    }, 50);
  } catch (_) {}
}


async function refreshInlinePdfPreview() {
  if (!pdfInlineRender) return;

  const productName = (state.records[idx].name || '').trim();
  const pdfItem = findPdfForProductName(productName);

  if (!pdfItem) {
    // Only alert when user truly has no imported PDFs. If PDFs exist but name doesn't match,
    // fall back silently (avoid false alarm / misfire notifications).
    if (pdfStore.size === 0) {
      alert('目前沒有可用的排關圖資料。\n\n請先匯入排關圖（離線或雲端）再顯示排關圖。');
    } else {
      console.warn('排關圖已匯入，但未能以商品名比對到檔案；請確認「商品名」是否與排關圖檔名/內文一致。');
    }
    return;
  }

  try {
    ensurePdfPrefs_();
    // If the source is an Excel-converted PDF, start slightly more zoomed-in
    // so text/lines are easier to read (user can still use fit/+/−).
    try {
      const rec = state.records[idx];
      if (pdfItem && pdfItem.source === 'excel' && rec && !rec.__excelZoomInited) {
        rec.pdfZoomFactor = Math.max(1.6, Number(rec.pdfZoomFactor) || 1.25);
        rec.__excelZoomInited = true;
      }
    } catch (_) {}
    await new Promise(r=>requestAnimationFrame(()=>requestAnimationFrame(r)));
    await ensurePdfJsLoaded();
    const ab = await getPdfArrayBuffer(pdfItem);
    if (!ab) throw new Error('No PDF buffer');

    const rec = state.records[idx];
    const pdfKey = normalizeKey((pdfItem.displayName || productName || '').trim());
    rec._activePdfKey = pdfKey || '';
    if (pdfKey) await ensureAnnoLoadedForRecord_(rec, pdfKey);

    await renderPdfInto(pdfInlineRender, ab, {
      zoomFactor: rec.pdfZoomFactor,
      annotate: rec.pdfAnnoMode,
      annoStore: rec.pdfAnnoStore,
      onAnnoChange: () => { if (pdfKey) scheduleAnnoSaveForRecord_(rec, pdfKey); },
      eraser: (rec.pdfAnnoTool === 'eraser'),
      penColor: rec.pdfAnnoPenColor,
      penWidth: rec.pdfAnnoPenWidth
    });

    updatePdfInlineControls_();
  } catch (err) {
    console.error('Inline PDF preview failed:', err);
    alert('排關圖顯示失敗：' + (err && err.message ? err.message : String(err)));
  }
}

// ---- iPad two-finger pinch zoom + two-finger pan (avoid triggering ink) ----
function attachPinchZoomToInlinePdf_() {
  if (!pdfInlineRender) return;
  if (pdfInlineRender.__pinchBound) return;
  pdfInlineRender.__pinchBound = true;

  let gesturing = false;
  let pinchActive = false;
  let startDist = 0;
  let startZoom = 1;
  let lastZoom = 1;

  // Incremental pan baseline
  let lastMidX = 0;
  let lastMidY = 0;
  let curScrollLeft = 0;
  let curScrollTop = 0;

  // Preview scale tracking
  let lastPreviewRatio = 1;

  // rAF batching (avoid jank on iPad)
  let rafId = 0;
  let pending = null; // { sl, st, pr }

  let commitTimer = null;

  const clampZoom_ = (z) => {
    const n = Number(z);
    if (!Number.isFinite(n)) return 1;
    return Math.max(0.6, Math.min(3.5, n));
  };

  const dist_ = (t1, t2) => {
    const dx = (t2.clientX - t1.clientX);
    const dy = (t2.clientY - t1.clientY);
    return Math.sqrt(dx*dx + dy*dy);
  };

  const mid_ = (t1, t2) => ({
    x: (t1.clientX + t2.clientX) / 2,
    y: (t1.clientY + t2.clientY) / 2
  });

  const pagesWrap_ = () => (pdfInlineRender._pagesWrap || pdfInlineRender);

  const setPreviewScale_ = (ratio) => {
    const wrap = pagesWrap_();
    if (!wrap) return;
    const r = Math.max(0.5, Math.min(3.5, Number(ratio) || 1));
    // Debounce tiny ratio noise (common on iPad)
    if (Math.abs(r - lastPreviewRatio) < 0.008) return;
    lastPreviewRatio = r;
    wrap.style.willChange = 'transform';
    wrap.style.transformOrigin = '0 0';
    wrap.style.transform = `translateZ(0) scale(${r})`;
  };

  const clearPreviewScale_ = () => {
    const wrap = pagesWrap_();
    if (!wrap) return;
    wrap.style.transform = '';
    wrap.style.willChange = '';
    lastPreviewRatio = 1;
  };

  const disableInk_ = (v) => {
    try {
      if (pdfInlineRender._annoControllers && pdfInlineRender._annoControllers.length) {
        pdfInlineRender._annoControllers.forEach(o => {
          try { o.api && o.api.setDisabled && o.api.setDisabled(!!v); } catch (_) {}
        });
      }
    } catch (_) {}
  };

  const scheduleFrame_ = () => {
    if (rafId) return;
    rafId = requestAnimationFrame(() => {
      rafId = 0;
      if (!pending) return;
      const { sl, st, pr } = pending;
      pending = null;
      try {
        if (typeof sl === 'number') pdfInlineRender.scrollLeft = sl;
        if (typeof st === 'number') pdfInlineRender.scrollTop = st;
      } catch (_) {}
      if (typeof pr === 'number') {
        setPreviewScale_(pr);
      }
    });
  };

  // Ensure scrolling feels native on iPad
  try { pdfInlineRender.style.webkitOverflowScrolling = 'touch'; } catch (_) {}
  try { pdfInlineRender.style.touchAction = 'none'; } catch (_) {}

  pdfInlineRender.addEventListener('touchstart', (e) => {
    if (!e.touches || e.touches.length !== 2) return;

    ensurePdfPrefs_();
    const rec = state.records[idx];

    gesturing = true;
    pinchActive = false;
    pdfInlineRender._pinching = true;

    // reset preview
    clearPreviewScale_();

    startDist = dist_(e.touches[0], e.touches[1]);
    startZoom = clampZoom_(rec.pdfZoomFactor || 1);
    lastZoom = startZoom;

    const m = mid_(e.touches[0], e.touches[1]);
    lastMidX = m.x;
    lastMidY = m.y;
    curScrollLeft = pdfInlineRender.scrollLeft;
    curScrollTop  = pdfInlineRender.scrollTop;

    // Temporarily disable ink while 2-finger gesturing
    disableInk_(true);

    // Prevent page scroll/zoom while gesturing inside the viewer
    e.preventDefault();
  }, { passive: false, capture: true });

  pdfInlineRender.addEventListener('touchmove', (e) => {
    if (!gesturing) return;
    if (!e.touches || e.touches.length < 2) return;

    const t1 = e.touches[0];
    const t2 = e.touches[1];

    // --- Pan (incremental, smoother than absolute baselining) ---
    const m = mid_(t1, t2);
    const dx = (m.x - lastMidX);
    const dy = (m.y - lastMidY);
    lastMidX = m.x;
    lastMidY = m.y;

    // Natural "grab" feel
    curScrollLeft -= dx;
    curScrollTop  -= dy;

    // --- Pinch (only activate when user meaningfully pinches) ---
    let pr = null;
    if (startDist && startDist > 0) {
      const d = dist_(t1, t2);
      const ratio = d / startDist;
      const nextZoom = clampZoom_(startZoom * ratio);

      // Activation threshold to avoid jitter when user is only panning
      if (!pinchActive) {
        if (Math.abs(d - startDist) >= 10 || Math.abs(nextZoom - startZoom) >= 0.03) {
          pinchActive = true;
        }
      }

      if (pinchActive) {
        // Debounce tiny zoom noise
        if (Math.abs(nextZoom - lastZoom) >= 0.006) {
          lastZoom = nextZoom;
        }
        pr = startZoom ? (lastZoom / startZoom) : 1;
      }
    }

    pending = { sl: curScrollLeft, st: curScrollTop, pr };
    scheduleFrame_();

    e.preventDefault();
  }, { passive: false, capture: true });

  const end_ = (e) => {
    if (!gesturing) return;
    if (e.touches && e.touches.length >= 2) return;

    gesturing = false;
    pdfInlineRender._pinching = false;

    // Stop any pending frame updates (avoid late preview updates after end)
    try {
      if (rafId) { cancelAnimationFrame(rafId); rafId = 0; }
      pending = null;
    } catch (_) {}

    ensurePdfPrefs_();
    const rec = state.records[idx];
    const nextZoom = clampZoom_(lastZoom);

    // Decide whether the user actually pinched (vs. pure pan)
    const didPinch = pinchActive || (Math.abs(nextZoom - startZoom) > 0.008);

    // Commit zoom with a smaller threshold so it doesn't snap back on iPad
    const zoomChanged = didPinch && (Math.abs(nextZoom - startZoom) > 0.004);
    if (zoomChanged) rec.pdfZoomFactor = nextZoom;

    // Restore ink after gesture ends
    disableInk_(false);

    // If user pinched, keep the preview transform until re-render completes to avoid jump-back
    if (!zoomChanged) {
      clearPreviewScale_();
    }

    if (commitTimer) clearTimeout(commitTimer);
    commitTimer = setTimeout(async () => {
      if (zoomChanged && pdfInlineWrap && !pdfInlineWrap.classList.contains('hidden')) {
        try {
          await refreshInlinePdfPreview();
        } catch (_) {
          // If render fails, remove preview transform to avoid being stuck
          try { clearPreviewScale_(); } catch (_) {}
        } finally {
          // Ensure preview transform is cleared after re-render
          try { clearPreviewScale_(); } catch (_) {}
        }
      } else {
        // No zoom commit; ensure preview is cleared
        try { clearPreviewScale_(); } catch (_) {}
      }
    }, 80);

    e.preventDefault();
  };

  pdfInlineRender.addEventListener('touchend', end_, { passive: false, capture: true });
  pdfInlineRender.addEventListener('touchcancel', end_, { passive: false, capture: true });
}


attachPinchZoomToInlinePdf_();

/* ---- PDF Fullscreen (overlay) & Floating Toolbar ---- */
function ensurePdfFullscreenUi_() {
  if (!pdfInlineWrap) return;
  if (pdfInlineWrap._fsUi) return;

  const closeBtn = document.createElement('button');
  closeBtn.type = 'button';
  closeBtn.className = 'pdfFsCloseBtn hidden';
  closeBtn.setAttribute('aria-label', '關閉全螢幕');
  closeBtn.innerHTML = `
    <svg viewBox="0 0 24 24" width="22" height="22" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M9 3H5a2 2 0 0 0-2 2v4" stroke="white" stroke-width="2" stroke-linecap="round"/>
      <path d="M15 3h4a2 2 0 0 1 2 2v4" stroke="white" stroke-width="2" stroke-linecap="round"/>
      <path d="M9 21H5a2 2 0 0 1-2-2v-4" stroke="white" stroke-width="2" stroke-linecap="round"/>
      <path d="M15 21h4a2 2 0 0 0 2-2v-4" stroke="white" stroke-width="2" stroke-linecap="round"/>
    </svg>`;

  const fabBtn = document.createElement('button');
  fabBtn.type = 'button';
  fabBtn.className = 'pdfFsToolFab hidden';
  fabBtn.setAttribute('aria-label', '工具列');
  fabBtn.innerHTML = `
    <svg viewBox="0 0 24 24" width="22" height="22" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M4 20l4-1 9-9-3-3-9 9-1 4z" stroke="#0f172a" stroke-width="2" stroke-linejoin="round"/>
      <path d="M13 6l3 3" stroke="#0f172a" stroke-width="2" stroke-linecap="round"/>
    </svg>`;

  const panel = document.createElement('div');
  panel.className = 'pdfFsToolPanel hidden';
  panel.innerHTML = `
    <div class="row">
      <button type="button" class="toolBtn fsPenBtn">畫筆</button>
      <button type="button" class="toolBtn fsEraserBtn">橡皮擦</button>
    </div>
    <div class="row">
      <span class="label">粗細</span>
      <input type="range" min="1" max="12" step="1" class="fsSizeRange" />
      <span class="label fsSizeValue" style="width:24px;text-align:right;">3</span>
    </div>
    <div class="row">
      <span class="label">顏色</span>
      <div style="display:flex;align-items:center;gap:6px;">
        <button type="button" class="fsColorSwatch" data-color="#f97316" style="background:#f97316"></button>
        <button type="button" class="fsColorSwatch" data-color="#ef4444" style="background:#ef4444"></button>
        <button type="button" class="fsColorSwatch" data-color="#3b82f6" style="background:#3b82f6"></button>
        <button type="button" class="fsColorSwatch" data-color="#22c55e" style="background:#22c55e"></button>
        <button type="button" class="fsColorSwatch" data-color="#111827" style="background:#111827"></button>
      </div>
      <input type="color" class="fsColorPicker" />
      <span class="fsColorValue" style="font-size:12px;font-weight:700;color:#64748b;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace;">#f97316</span>
    </div>
    <div class="row">
      <button type="button" class="miniBtn fsFitBtn">適合寬度</button>
      <button type="button" class="miniBtn fsClearBtn">清除標註</button>
      <button type="button" class="miniBtn fsClosePanelBtn" style="margin-left:auto;">收合</button>
    </div>
  `;

  // Attach to dock (so absolute positioning works in fullscreen)
  const dock = pdfInlineWrap.querySelector('.pdfFsDock') || pdfInlineWrap;
  dock.appendChild(closeBtn);
  dock.appendChild(fabBtn);
  dock.appendChild(panel);

  const penBtn = panel.querySelector('.fsPenBtn');
  const eraserBtn = panel.querySelector('.fsEraserBtn');
  const sizeRange = panel.querySelector('.fsSizeRange');
  const sizeValue = panel.querySelector('.fsSizeValue');
  const colorPicker = panel.querySelector('.fsColorPicker');
  const colorValue = panel.querySelector('.fsColorValue');
  const colorSwatches = panel.querySelectorAll('.fsColorSwatch');
  const fitBtn = panel.querySelector('.fsFitBtn');
  const clearBtn = panel.querySelector('.fsClearBtn');
  const closePanelBtn = panel.querySelector('.fsClosePanelBtn');

  const sync = () => {
    try {
      ensurePdfPrefs_();
      const rec = state.records[idx] || {};
      const penActive = !!rec.pdfAnnoMode && rec.pdfAnnoTool === 'pen';
      const eraserActive = !!rec.pdfAnnoMode && rec.pdfAnnoTool === 'eraser';
      if (penBtn) penBtn.classList.toggle('is-active', penActive);
      if (eraserBtn) eraserBtn.classList.toggle('is-active', eraserActive);

      const w = Number(rec.pdfAnnoPenWidth || 3);
      if (sizeRange) sizeRange.value = String(w);
      if (sizeValue) sizeValue.textContent = String(w);

      const col = String(rec.pdfAnnoPenColor || '#f97316');
      if (colorPicker) colorPicker.value = col;
      if (colorValue) colorValue.textContent = col.toLowerCase();
      if (colorSwatches && colorSwatches.length) {
        colorSwatches.forEach((btn) => {
          const c = (btn.getAttribute('data-color') || '').toLowerCase();
          btn.classList.toggle('is-active', c && c === col.toLowerCase());
        });
      }
    } catch (_) {}
  };

  closeBtn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); exitPdfFullscreen_(); });

  fabBtn.addEventListener('click', (e) => {
    e.preventDefault(); e.stopPropagation();
    const wasHidden = panel.classList.contains('hidden');
    panel.classList.toggle('hidden');

    // In fullscreen: opening the toolbar defaults to pen tool (annotation ON with pen).
    if (wasHidden) {
      try {
        ensurePdfPrefs_();
        const rec = state.records[idx] || {};
        const penActive = !!rec.pdfAnnoMode && rec.pdfAnnoTool === 'pen';
        if (!penActive) {
          if (pdfAnnoToggleBtn) pdfAnnoToggleBtn.click();
        }
      } catch (_) {}
    }

    sync();
  });

  if (closePanelBtn) {
    closePanelBtn.addEventListener('click', (e) => {
      e.preventDefault(); e.stopPropagation();
      try { collapseInlinePdf_(); }
      catch (_) { try { panel.classList.add('hidden'); } catch (_) {} }
    });
  }

  if (penBtn) {
    penBtn.addEventListener('click', async (e) => {
      e.preventDefault(); e.stopPropagation();
      try { if (pdfAnnoToggleBtn) pdfAnnoToggleBtn.click(); } catch (_) {}
      sync();
    });
  }

  if (eraserBtn) {
    eraserBtn.addEventListener('click', async (e) => {
      e.preventDefault(); e.stopPropagation();
      try { if (pdfAnnoEraserBtn) pdfAnnoEraserBtn.click(); } catch (_) {}
      sync();
    });
  }

  if (sizeRange) {
    const onSize = (e) => {
      try {
        applyPenWidth_(e.target.value);
        sync();
      } catch (_) {}
    };
    sizeRange.addEventListener('input', onSize);
    sizeRange.addEventListener('change', onSize);
  }

  if (colorPicker) {
    const onCol = (e) => {
      try { applyPenColor_(e.target.value); } catch (_) {}
      sync();
    };
    colorPicker.addEventListener('input', onCol);
    colorPicker.addEventListener('change', onCol);
  }

  if (colorSwatches && colorSwatches.length) {
    colorSwatches.forEach((btn) => {
      btn.addEventListener('click', (e) => {
        e.preventDefault(); e.stopPropagation();
        const c = btn.getAttribute('data-color');
        if (c) { try { applyPenColor_(c); } catch (_) {} }
        sync();
      });
    });
  }

  if (fitBtn) {
    fitBtn.addEventListener('click', async (e) => {
      e.preventDefault(); e.stopPropagation();
      await fitPdfWidth_();
      sync();
    });
  }

  if (clearBtn) {
    clearBtn.addEventListener('click', async (e) => {
      e.preventDefault(); e.stopPropagation();
      try { if (pdfAnnoClearBtn) pdfAnnoClearBtn.click(); } catch (_) {}
      sync();
    });
  }

  pdfInlineWrap._fsUi = { closeBtn, fabBtn, panel, sync };
}

async function fitPdfWidth_() {
  ensurePdfPrefs_();
  const rec = state.records[idx];
  rec.pdfZoomFactor = 1.0;
  if (pdfInlineWrap && !pdfInlineWrap.classList.contains('hidden')) await refreshInlinePdfPreview();
}

function enterPdfFullscreen_() {
  if (!pdfInlineWrap) return;
  if (pdfInlineWrap.classList.contains('is-fullscreen')) return;

  ensurePdfFullscreenUi_();

  // Save original placement
  const place = pdfInlineWrap._fsPlace || (pdfInlineWrap._fsPlace = {});
  if (!place.placeholder) {
    const ph = document.createElement('div');
    ph.className = 'pdfFsPlaceholder';
    ph.style.display = 'none';
    place.placeholder = ph;
  }

  try {
    place.parent = pdfInlineWrap.parentNode;
    // Insert placeholder at current position
    if (place.parent) place.parent.insertBefore(place.placeholder, pdfInlineWrap);
  } catch (_) {}

  // Move viewer to body
  try { document.body.appendChild(pdfInlineWrap); } catch (_) {}
  document.body.classList.add('pdf-fs-lock');
  pdfInlineWrap.classList.add('is-fullscreen');

  // Show floating UI
  const ui = pdfInlineWrap._fsUi;
  if (ui) {
    ui.closeBtn.classList.remove('hidden');
    ui.fabBtn.classList.remove('hidden');
    ui.panel.classList.add('hidden');
    try { ui.sync(); } catch (_) {}
  }

  // ESC to close
  if (!pdfInlineWrap._fsKeyHandler) {
    pdfInlineWrap._fsKeyHandler = (e) => {
      if (e && (e.key === 'Escape' || e.key === 'Esc')) exitPdfFullscreen_();
    };
    document.addEventListener('keydown', pdfInlineWrap._fsKeyHandler);
  }

  // Re-render once to fit new viewport
  setTimeout(() => {
    try { if (pdfInlineWrap && !pdfInlineWrap.classList.contains('hidden')) refreshInlinePdfPreview(); } catch (_) {}
  }, 60);
}

function exitPdfFullscreen_() {
  if (!pdfInlineWrap) return;
  if (!pdfInlineWrap.classList.contains('is-fullscreen')) return;

  pdfInlineWrap.classList.remove('is-fullscreen');
  document.body.classList.remove('pdf-fs-lock');

  const place = pdfInlineWrap._fsPlace || {};
  try {
    const ph = place.placeholder;
    if (ph && ph.parentNode) {
      ph.parentNode.replaceChild(pdfInlineWrap, ph);
    } else if (place.parent) {
      place.parent.appendChild(pdfInlineWrap);
    }
  } catch (_) {
    // noop
  }

  const ui = pdfInlineWrap._fsUi;
  if (ui) {
    ui.closeBtn.classList.add('hidden');
    ui.fabBtn.classList.add('hidden');
    ui.panel.classList.add('hidden');
  }

  if (pdfInlineWrap._fsKeyHandler) {
    try { document.removeEventListener('keydown', pdfInlineWrap._fsKeyHandler); } catch (_) {}
    pdfInlineWrap._fsKeyHandler = null;
  }

  // Re-render once to fit back
  setTimeout(() => {
    try { if (pdfInlineWrap && !pdfInlineWrap.classList.contains('hidden')) refreshInlinePdfPreview(); } catch (_) {}
  }, 80);
}



if (showPdfBtn) {
  showPdfBtn.addEventListener('click', async () => {
    const isHidden = pdfInlineWrap ? pdfInlineWrap.classList.contains('hidden') : true;
    if (isHidden) {
      showInlinePdf(true);
      await refreshInlinePdfPreview();
    } else {
      collapseInlinePdf_();
    }
  });
}

if (closePdfInlineBtn) {
  closePdfInlineBtn.addEventListener('click', () => collapseInlinePdf_());
}



if (pdfDownloadBtn) {
  pdfDownloadBtn.addEventListener('click', async () => {
    try {
      const btn = pdfDownloadBtn;
      const oldText = btn.textContent;
      btn.textContent = '下載中…';
      btn.disabled = true;

      ensurePdfPrefs_();
      const wasHidden = (pdfInlineWrap && pdfInlineWrap.classList.contains('hidden'));
      if (wasHidden) {
        showInlinePdf(true);
      }
      // Ensure canvases exist; avoid re-rendering when already visible (would wipe unsaved ink)
      const hasCanvases = (pdfInlineRender && pdfInlineRender._pdfCanvases && pdfInlineRender._pdfCanvases.length);
      if (wasHidden || !hasCanvases) {
        await refreshInlinePdfPreview();
      } else {
        await new Promise(r=>requestAnimationFrame(()=>requestAnimationFrame(r)));
      }

      const pdfPages = (pdfInlineRender && pdfInlineRender._pdfCanvases) ? pdfInlineRender._pdfCanvases : [];
      if (!pdfPages.length) throw new Error('尚未產生可下載的頁面，請先顯示排關圖');

      // Annotation sources
      const annoCanvases = (pdfInlineRender && pdfInlineRender._annoCanvases) ? pdfInlineRender._annoCanvases : [];
      const annoMap = {};
      annoCanvases.forEach(o => { if (o && o.pageNum && o.canvas) annoMap[o.pageNum] = o.canvas; });

      const rec = state.records[idx] || {};
      const store = (rec.pdfAnnoStore && typeof rec.pdfAnnoStore === 'object') ? rec.pdfAnnoStore : (rec.pdfAnnoStore = {});

      // Force-flush current annotation canvases into store to avoid debounce timing gaps
      try {
        if (annoCanvases && annoCanvases.length) {
          annoCanvases.forEach(o => {
            if (o && o.pageNum && o.canvas) {
              try { store[o.pageNum] = o.canvas.toDataURL('image/png'); } catch (_) {}
            }
          });
        }
      } catch (_) {}

      const drawDataUrl_ = (ctx, dataUrl, w, h) => new Promise((resolve) => {
        if (!dataUrl) return resolve(false);
        const img = new Image();
        img.onload = () => {
          try { ctx.drawImage(img, 0, 0, w, h); resolve(true); }
          catch (_) { resolve(false); }
        };
        img.onerror = () => resolve(false);
        img.src = dataUrl;
      });

      // Build merged page images (PDF page + annotation overlay)
      const pageImgs = [];
      for (let i = 0; i < pdfPages.length; i++) {
        const p = pdfPages[i];
        const pageNum = p.pageNum;
        const baseCanvas = p.canvas;
        const w = baseCanvas.width;
        const h = baseCanvas.height;

        const merged = document.createElement('canvas');
        merged.width = w;
        merged.height = h;
        const mctx = merged.getContext('2d');

        mctx.drawImage(baseCanvas, 0, 0);
        if (annoMap[pageNum]) {
          mctx.drawImage(annoMap[pageNum], 0, 0);
        } else if (store[pageNum]) {
          await drawDataUrl_(mctx, store[pageNum], w, h);
        }

        pageImgs.push({ imgData: merged.toDataURL('image/jpeg', 0.92), w, h });
      }

      const safeName = String((state.records[idx] && state.records[idx].name) ? state.records[idx].name : '排關圖')
        .trim()
        .replace(/[\\/:*?"<>|]+/g, '_')
        .slice(0, 60) || '排關圖';

      const fileName = `排關圖_標註版_${safeName}.pdf`;

      // Prefer jsPDF for direct download; fallback to print-to-PDF for offline/no-CDN scenarios.
      const ok = await ensureJsPdfLoaded();
      const jsPDF = (ok && window.jspdf && window.jspdf.jsPDF) ? window.jspdf.jsPDF : null;

      if (jsPDF) {
        let doc = null;
        for (let i = 0; i < pageImgs.length; i++) {
          const p = pageImgs[i];
          const orientation = (p.w >= p.h) ? 'l' : 'p';
          if (!doc) doc = new jsPDF({ orientation, unit: 'px', format: [p.w, p.h], compress: true });
          else doc.addPage([p.w, p.h], orientation);
          doc.addImage(p.imgData, 'JPEG', 0, 0, p.w, p.h);
        }
        doc.save(fileName);
      } else {
        // Fallback: open a printable view; user can "Save as PDF" in the print/share UI.
        const w = window.open('', '_blank');
        if (!w) throw new Error('無法開啟新視窗（請允許彈出視窗）');

        w.document.open();
        w.document.write('<!doctype html><html lang="zh-Hant"><head><meta charset="utf-8" />');
        w.document.write('<meta name="viewport" content="width=device-width,initial-scale=1" />');
        w.document.write('<title>' + fileName.replace(/</g,'&lt;') + '</title>');
        w.document.write('<style>body{margin:0;padding:0} img{width:100%;display:block} .page{page-break-after:always}</style>');
        w.document.write('</head><body>');
        for (let i = 0; i < pageImgs.length; i++) {
          w.document.write("<div class='page'><img src='" + pageImgs[i].imgData + "' /></div>");
        }
        w.document.write('</body></html>');
        w.document.close();

        setTimeout(() => { try { w.focus(); w.print(); } catch (_) {} }, 600);
        alert('未能載入 jsPDF，已改用列印模式。請在列印/分享選單中選擇「儲存為 PDF」。');
      }

      btn.textContent = oldText;
      btn.disabled = false;
    } catch (err) {
      console.error(err);
      alert('下載排關圖失敗：' + (err && err.message ? err.message : String(err)));
      try {
        pdfDownloadBtn.textContent = '下載排關圖';
        pdfDownloadBtn.disabled = false;
      } catch (_) {}
    }
  });
}


if (pdfZoomInBtn) {
  pdfZoomInBtn.addEventListener('click', async () => {
    ensurePdfPrefs_();
    const rec = state.records[idx];
    rec.pdfZoomFactor = Math.min(3.5, rec.pdfZoomFactor + 0.15);
    if (pdfInlineWrap && !pdfInlineWrap.classList.contains('hidden')) await refreshInlinePdfPreview();
  });
}

if (pdfZoomOutBtn) {
  pdfZoomOutBtn.addEventListener('click', async () => {
    ensurePdfPrefs_();
    const rec = state.records[idx];
    rec.pdfZoomFactor = Math.max(0.6, rec.pdfZoomFactor - 0.15);
    if (pdfInlineWrap && !pdfInlineWrap.classList.contains('hidden')) await refreshInlinePdfPreview();
  });
}

if (pdfFitBtn) {
  pdfFitBtn.addEventListener('click', async (e) => {
    try { e && e.preventDefault && e.preventDefault(); } catch (_) {}
    // Make sure viewer is visible before fullscreen
    const wasHidden = (pdfInlineWrap && pdfInlineWrap.classList.contains('hidden'));
    if (wasHidden) {
      showInlinePdf(true);
      await refreshInlinePdfPreview();
    }

    // Toggle fullscreen
    if (pdfInlineWrap && pdfInlineWrap.classList.contains('is-fullscreen')) {
      exitPdfFullscreen_();
    } else {
      enterPdfFullscreen_();
    }
  });
}

if (pdfAnnoToggleBtn) {
  pdfAnnoToggleBtn.addEventListener('click', async () => {
    ensurePdfPrefs_();
    const rec = state.records[idx];

    // Behavior:
    // - If annotation is OFF -> turn ON and switch to pen tool.
    // - If annotation is ON and currently using eraser -> switch to pen (stay ON).
    // - If annotation is ON and already pen -> turn OFF (hide annotation layer).
    if (!rec.pdfAnnoMode) {
      rec.pdfAnnoMode = true;
      rec.pdfAnnoTool = 'pen';
      updatePdfInlineControls_();
      if (pdfInlineWrap && !pdfInlineWrap.classList.contains('hidden')) await refreshInlinePdfPreview();
      return;
    }

    if (rec.pdfAnnoTool === 'eraser') {
      rec.pdfAnnoTool = 'pen';
      updatePdfInlineControls_();
      // Apply tool instantly if canvases already exist (no full re-render needed)
      if (pdfInlineRender && pdfInlineRender._annoControllers && pdfInlineRender._annoControllers.length) {
        pdfInlineRender._annoControllers.forEach(o => { try { o.api && o.api.setMode('pen'); } catch (_) {} });
      } else if (pdfInlineWrap && !pdfInlineWrap.classList.contains('hidden')) {
        await refreshInlinePdfPreview();
      }
      return;
    }

    // Pen -> toggle annotation layer off
    rec.pdfAnnoMode = false;
    updatePdfInlineControls_();
    if (pdfInlineWrap && !pdfInlineWrap.classList.contains('hidden')) await refreshInlinePdfPreview();
  });
}


if (pdfAnnoEraserBtn) {
  // Prevent iPad from interpreting as scroll/gesture
  pdfAnnoEraserBtn.addEventListener('pointerdown', (e) => { e.preventDefault(); e.stopPropagation(); }, { passive: false });

  pdfAnnoEraserBtn.addEventListener('click', async (e) => {
    e.preventDefault(); e.stopPropagation();
    ensurePdfPrefs_();
    const rec = state.records[idx];

    const wasOn = !!rec.pdfAnnoMode;
    rec.pdfAnnoMode = true;
    rec.pdfAnnoTool = 'eraser';
    updatePdfInlineControls_();

    // If already rendered with annotation layer, switch tool instantly
    if (wasOn && pdfInlineRender && pdfInlineRender._annoControllers && pdfInlineRender._annoControllers.length) {
      pdfInlineRender._annoControllers.forEach(o => { try { o.api && o.api.setMode('eraser'); } catch (_) {} });
      return;
    }

    if (pdfInlineWrap && !pdfInlineWrap.classList.contains('hidden')) await refreshInlinePdfPreview();
  });
}

if (pdfAnnoClearBtn) {
  pdfAnnoClearBtn.addEventListener('click', async () => {
    ensurePdfPrefs_();
    const rec = state.records[idx];
    rec.pdfAnnoStore = {};
    if (pdfInlineWrap && !pdfInlineWrap.classList.contains('hidden')) await refreshInlinePdfPreview();
  });
}

updatePdfInlineControls_();

// ---- PDF Pen Settings (size / color) ----
function showPdfPenSettings_(focusWhich) {
  if (!pdfPenSettings) return;
  pdfPenSettings.classList.remove('hidden');

  // focus helper
  setTimeout(() => {
    try {
      if (focusWhich === 'size' && pdfPenSizeRange) pdfPenSizeRange.focus();
      if (focusWhich === 'color' && pdfPenColorPicker) pdfPenColorPicker.focus();
    } catch (_) {}
  }, 30);
}

function hidePdfPenSettings_() {
  if (!pdfPenSettings) return;
  pdfPenSettings.classList.add('hidden');
}

function clampInt_(v, min, max) {
  const n = Math.round(Number(v));
  if (!Number.isFinite(n)) return min;
  return Math.max(min, Math.min(max, n));
}

function applyPenWidth_(w) {
  ensurePdfPrefs_();
  const rec = state.records[idx];
  rec.pdfAnnoPenWidth = clampInt_(w, 1, 12);
  updatePdfInlineControls_();

  // Apply instantly if annotation controllers exist
  if (pdfInlineRender && pdfInlineRender._annoControllers && pdfInlineRender._annoControllers.length) {
    pdfInlineRender._annoControllers.forEach(o => { try { o.api && o.api.setPenWidth && o.api.setPenWidth(rec.pdfAnnoPenWidth); } catch (_) {} });
  }
}

function applyPenColor_(c) {
  ensurePdfPrefs_();
  const rec = state.records[idx];
  if (typeof c === 'string' && /^#([0-9a-fA-F]{6})$/.test(c)) rec.pdfAnnoPenColor = c;
  updatePdfInlineControls_();

  if (pdfInlineRender && pdfInlineRender._annoControllers && pdfInlineRender._annoControllers.length) {
    pdfInlineRender._annoControllers.forEach(o => { try { o.api && o.api.setPenColor && o.api.setPenColor(rec.pdfAnnoPenColor); } catch (_) {} });
  }
}

if (pdfPenSizeBtn) {
  pdfPenSizeBtn.addEventListener('click', (e) => {
    e.preventDefault(); e.stopPropagation();
    ensurePdfPrefs_();
    updatePdfInlineControls_();
    showPdfPenSettings_('size');
  });
}

if (pdfPenColorBtn) {
  pdfPenColorBtn.addEventListener('click', (e) => {
    e.preventDefault(); e.stopPropagation();
    ensurePdfPrefs_();
    updatePdfInlineControls_();
    showPdfPenSettings_('color');
    // Try to open native picker on iOS when possible
    try { if (pdfPenColorPicker) pdfPenColorPicker.click(); } catch (_) {}
  });
}

if (pdfPenSettingsClose) {
  pdfPenSettingsClose.addEventListener('click', (e) => {
    e.preventDefault(); e.stopPropagation();
    hidePdfPenSettings_();
  });
}

if (pdfPenSizeRange) {
  pdfPenSizeRange.addEventListener('input', (e) => applyPenWidth_(e.target.value));
  pdfPenSizeRange.addEventListener('change', (e) => applyPenWidth_(e.target.value));
}

if (pdfPenColorPicker) {
  pdfPenColorPicker.addEventListener('input', (e) => applyPenColor_(e.target.value));
  pdfPenColorPicker.addEventListener('change', (e) => applyPenColor_(e.target.value));
}

if (pdfPenColorSwatches && pdfPenColorSwatches.length) {
  pdfPenColorSwatches.forEach((btn) => {
    btn.addEventListener('click', (e) => {
      e.preventDefault(); e.stopPropagation();
      const c = btn.getAttribute('data-color');
      if (c) applyPenColor_(c);
    });
  });
}

// ---- Process Steps (manual) ----
        const processBtn = panel.querySelector('.processBtn');
        if (processBtn) {
          processBtn.addEventListener('click', async () => {
            if (processStepsHint) { processStepsHint.classList.remove('hidden'); processStepsHint.textContent = '載入中...'; }
            await refreshProcessSteps(true);
          });
        }

// ---- 作業工程：手動擷取（不自動） ----
        const processExtractBtn = panel.querySelector('.processExtractBtn');
        const setProcessBtnLabel_ = (open) => {
          if (!processExtractBtn) return;
          processExtractBtn.textContent = open ? '收合作業工程' : '作業工程';
        };

        const toggleProcessSteps_ = async () => {
          if (!processStepsWrap) return;
          const isOpen = !processStepsWrap.classList.contains('hidden');

          // Close
          if (isOpen) {
            processStepsWrap.classList.add('hidden');
            if (processStepsHint) processStepsHint.classList.add('hidden');
            if (processLoading) { processLoading.classList.add('hidden'); processLoading.textContent = ''; }
            // Keep table HTML in memory (no clearing) so reopening is instant if data exists
            state.records[idx].processStepsOpen = false;
            saveState();
            setProcessBtnLabel_(false);
            return;
          }

          // Open
          state.records[idx].processStepsOpen = true;
          saveState();
          setProcessBtnLabel_(true);
          await refreshProcessSteps(true);
        };

        // Init label based on persisted state
        setProcessBtnLabel_(!!rec.processStepsOpen);

        if (processExtractBtn) {
          processExtractBtn.addEventListener('click', async () => {
            await toggleProcessSteps_();
          });
        }


        // ---- Images upload ----
        imgInput && imgInput.addEventListener('change', async (e) => {
          const files = Array.from((e.target && e.target.files) ? e.target.files : []);
          if (!files.length) return;

          const imgs = [];
          for (const f of files) {
            const dataUrl = await fileToDataUrl(f);
            const size = await getImageSize(dataUrl);
            imgs.push({ name: f.name, dataUrl, width: size.width, height: size.height });
          }

          const merged = (state.records[idx].images || []).concat(imgs);
          setRecord({ images: merged });

          imgHint.textContent = `已選擇 ${merged.length} 張圖片。`;
          renderImagePreview(imgPreview, merged);

          e.target.value = '';
        });

        $('.clearImgsBtn', panel).addEventListener('click', () => {
          setRecord({ images: [] });
          imgHint.textContent = '尚未選擇圖片。';
          imgPreview.innerHTML = '';
        });

        // ---- Per-panel actions (mobile) ----
        $('.addBtn', panel).addEventListener('click', () => addForm());
        $('.dupBtn', panel).addEventListener('click', () => duplicateAt(idx));
        $('.delBtn', panel).addEventListener('click', () => removeAt(idx));

        panelsEl.appendChild(node);
      });

      setActive(Math.min(state.active, state.records.length - 1), { scrollTabIntoView: false });

      // Keep floating catalog button aligned under tab row
      schedulePositionCatalogBtn();
    }

    // ---------------- PPTX Export: match template ----------------
    // NOTE: PptxGenJS is loaded dynamically on click to avoid "button no effect" when CDN fails.

    const TPL = {
      slideW: 10,
      slideH: 7.5,

      // Master decorations (from 公版：訪廠問題表格.pptx)
      decor: {
        // two stripes at top and bottom
        x: 0.1076389,
        w: 9.8263889,
        topGreenY: 0.4947922,
        topBlueY: 0.5420770,
        bottomGreenY: 7.2582707,
        bottomBlueY: 7.3055556,
        green: '008000',
        blue:  '3366FF',
        lineW: 2
      },

      footer: {
        text: '本文件為「全家便利商店股份有限公司」所有，請勿外洩',
        x: 3.4302592,
        y: 7.2586811,
        w: 4.0104167,
        h: 0.2690967,
        font: '標楷體',
        size: 10,
        color: '000000'
      },

      impl: {
        x: 7.9074059,
        y: 0.6485466,
        w: 1.9069543,
        h: 0.4882951,
        fill: 'FFF2CC',
        line: '2D4D6A',
        font: 'Microsoft JhengHei',
        size: 18,
        color: '000000',
        text: '實施日:'
      },

      title: { x: 0.128, y: 0.014, w: 9.785, h: 0.472, text: '一、調整說明', font: 'Meiryo UI', size: 18, color: '000000' },
      bar:   { x: 0.227, y: 0.695, w: 9.587, h: 0.442, fill: '2E75B6', textColor: 'FFFF00', font: 'Microsoft JhengHei', size: 18 },

      t1: {
        x: 0.277, y: 1.183, w: 9.488, h: 3.545,
        colW: 4.744, headH: 0.748, bodyH: 2.797,
        headFill: 'DEEAF7',
        border: '4A4E52',
        sep: '414243',
        headFont: 'Microsoft JhengHei',
        headSize: 16
      },

      t2: {
        x: 0.277, y: 4.728, w: 9.488, h: 2.478,
        colW: 4.744, rowH: 0.62,
        border: '000000',
        font: 'Microsoft JhengHei',
        size: 14
      },

      photoPad: 0.15
    };

    function formatExportError(err) {
      const msg = err && err.message ? err.message : String(err);
      return `PPT 匯出失敗：\n${msg}`;
    }

    function drawTemplate(slide, rec, pptx) {
      // Background (white) — use shape for maximum compatibility
      slide.addShape(pptx.ShapeType.rect, {
        x: 0, y: 0, w: TPL.slideW, h: TPL.slideH,
        fill: { color: 'FFFFFF' },
        line: { color: 'FFFFFF', width: 0 }
      });

      
      // Master top/bottom stripes (全家公版裝飾)
      slide.addShape(pptx.ShapeType.line, {
        x: TPL.decor.x, y: TPL.decor.topGreenY, w: TPL.decor.w, h: 0,
        line: { color: TPL.decor.green, width: TPL.decor.lineW }
      });
      slide.addShape(pptx.ShapeType.line, {
        x: TPL.decor.x, y: TPL.decor.topBlueY, w: TPL.decor.w, h: 0,
        line: { color: TPL.decor.blue, width: TPL.decor.lineW }
      });
      slide.addShape(pptx.ShapeType.line, {
        x: TPL.decor.x, y: TPL.decor.bottomGreenY, w: TPL.decor.w, h: 0,
        line: { color: TPL.decor.green, width: TPL.decor.lineW }
      });
      slide.addShape(pptx.ShapeType.line, {
        x: TPL.decor.x, y: TPL.decor.bottomBlueY, w: TPL.decor.w, h: 0,
        line: { color: TPL.decor.blue, width: TPL.decor.lineW }
      });

      // Footer disclaimer text (master)
      slide.addText(TPL.footer.text, {
        x: TPL.footer.x, y: TPL.footer.y, w: TPL.footer.w, h: TPL.footer.h,
        fontFace: TPL.footer.font, fontSize: TPL.footer.size,
        color: TPL.footer.color, align: 'center', valign: 'mid'
      });

      



slide.addText(TPL.title.text, {
        x: TPL.title.x, y: TPL.title.y, w: TPL.title.w, h: TPL.title.h,
        fontFace: TPL.title.font, fontSize: TPL.title.size, color: TPL.title.color,
        valign: 'mid', align: 'left'
      });

      slide.addShape(pptx.ShapeType.rect, {
        x: TPL.bar.x, y: TPL.bar.y, w: TPL.bar.w, h: TPL.bar.h,
        fill: { color: TPL.bar.fill }, line: { color: TPL.bar.fill, width: 0 }
      });

      const typeTxt = (rec.type || '【類型】').trim();
      const nameTxt = (rec.name || '【商品名】').trim();

      // Header text: 類型 = 黃色；商品名 = 白色（避免整段都黃）
      const headerRuns = [
        { text: typeTxt, options: { color: 'FFFF00', bold: true } },
        { text: '-',      options: { color: 'FFFFFF', bold: true } },
        { text: nameTxt,  options: { color: 'FFFFFF', bold: true } },
      ];

      // PptxGenJS v3 supports rich text runs (array). If not, fall back to two text boxes.
      try {
        slide.addText(headerRuns, {
          x: TPL.bar.x, y: TPL.bar.y, w: TPL.bar.w, h: TPL.bar.h,
          fontFace: TPL.bar.font, fontSize: TPL.bar.size,
          align: 'center', valign: 'mid'
        });
      } catch (e) {
        // Fallback: approximate centering by splitting the bar into two regions
        slide.addText(typeTxt, {
          x: TPL.bar.x, y: TPL.bar.y, w: TPL.bar.w * 0.35, h: TPL.bar.h,
          fontFace: TPL.bar.font, fontSize: TPL.bar.size, bold: true,
          color: 'FFFF00', align: 'right', valign: 'mid'
        });
        slide.addText('-' + nameTxt, {
          x: TPL.bar.x + TPL.bar.w * 0.35, y: TPL.bar.y, w: TPL.bar.w * 0.65, h: TPL.bar.h,
          fontFace: TPL.bar.font, fontSize: TPL.bar.size, bold: true,
          color: 'FFFFFF', align: 'left', valign: 'mid'
        });
      }
const t1 = TPL.t1;

      slide.addShape(pptx.ShapeType.rect, {
        x: t1.x, y: t1.y, w: t1.w, h: t1.h,
        fill: { color: 'FFFFFF', transparency: 100 },
        line: { color: t1.border, width: 1 }
      });

      slide.addShape(pptx.ShapeType.rect, {
        x: t1.x, y: t1.y, w: t1.colW, h: t1.headH,
        fill: { color: t1.headFill }, line: { color: t1.border, width: 1 }
      });
      slide.addShape(pptx.ShapeType.rect, {
        x: t1.x + t1.colW, y: t1.y, w: t1.colW, h: t1.headH,
        fill: { color: t1.headFill }, line: { color: t1.border, width: 1 }
      });

      slide.addShape(pptx.ShapeType.line, {
        x: t1.x + t1.colW, y: t1.y, w: 0, h: t1.h,
        line: { color: '000000', width: 1 }
      });

      slide.addShape(pptx.ShapeType.line, {
        x: t1.x, y: t1.y + t1.headH, w: t1.w, h: 0,
        line: { color: t1.sep, width: 1 }
      });

      slide.addText('改善前', {
        x: t1.x, y: t1.y, w: t1.colW, h: t1.headH,
        fontFace: t1.headFont, fontSize: t1.headSize, bold: true,
        color: '000000', align: 'center', valign: 'mid'
      });
      slide.addText('改善後', {
        x: t1.x + t1.colW, y: t1.y, w: t1.colW, h: t1.headH,
        fontFace: t1.headFont, fontSize: t1.headSize, bold: true,
        color: '000000', align: 'center', valign: 'mid'
      });

      const t2 = TPL.t2;

      slide.addShape(pptx.ShapeType.rect, {
        x: t2.x, y: t2.y, w: t2.w, h: t2.h,
        fill: { color: 'FFFFFF', transparency: 100 },
        line: { color: t2.border, width: 1 }
      });

      slide.addShape(pptx.ShapeType.line, {
        x: t2.x + t2.colW, y: t2.y, w: 0, h: t2.h,
        line: { color: t2.border, width: 1 }
      });

      // 橫線：只畫右側 PDCA 區（左側回答框不畫橫線）
      const rightX = t2.x + t2.colW;
      const rightW = t2.w - t2.colW;
      for (let i = 1; i <= 3; i++) {
        slide.addShape(pptx.ShapeType.line, {
          x: rightX,
          y: t2.y + t2.rowH * i,
          w: rightW,
          h: 0,
          line: { color: t2.border, width: 1 }
        });
      }

      // 左上標籤：只保留「P(問題)」，並稍微下移避免貼邊
      slide.addText('P(問題)', {
        x: t2.x + 0.10,
        y: t2.y + 0.06,
        w: t2.colW - 0.20,
        h: 0.35,
        fontFace: t2.font,
        fontSize: t2.size,
        color: '000000',
        align: 'left',
        valign: 'top'
      });

      const pdca = ['P：', 'D：', 'C：', 'A：'];
      pdca.forEach((lab, i) => {
        slide.addText(lab, {
          x: t2.x + t2.colW + 0.12, y: t2.y + t2.rowH * i,
          w: t2.colW - 0.24, h: t2.rowH,
          fontFace: t2.font, fontSize: t2.size, color: '000000',
          align: 'left', valign: 'mid'
        });
      });
      const desc = (rec.desc || '').trim();
if (desc) {
        // 左側回答框：整塊空白區（無橫線），文字從標籤下方開始
        slide.addText(desc, {
          x: t2.x + 0.12,
          y: t2.y + 0.48,
          w: t2.colW - 0.24,
          h: t2.h - 0.60,
          fontFace: t2.font,
          fontSize: 12,
          color: '111111',
          align: 'left',
          valign: 'top'
        });
      }

      // 實施日（置頂顯示：確保在所有圖層最上方）
      // 實施日（表單不填寫；PPT 保留給對方填）
            slide.addShape(pptx.ShapeType.roundRect, {
              x: TPL.impl.x, y: TPL.impl.y, w: TPL.impl.w, h: TPL.impl.h,
              fill: { color: TPL.impl.fill },
              line: { color: TPL.impl.line, width: 1 }
            });
            slide.addText(TPL.impl.text, {
              x: TPL.impl.x + 0.10, y: TPL.impl.y, w: TPL.impl.w - 0.20, h: TPL.impl.h,
              fontFace: TPL.impl.font, fontSize: TPL.impl.size,
              color: TPL.impl.color, align: 'left', valign: 'mid'
            });

}


    function drawNotesSlide(slide, rec, pptx) {
      // Background
      slide.background = { color: 'FFFFFF' };

      // Decorative lines
      slide.addShape(pptx.ShapeType.line, {
        x: TPL.decor.x, y: TPL.decor.topGreenY, w: TPL.decor.w, h: 0,
        line: { color: TPL.decor.green, width: TPL.decor.lineW }
      });
      slide.addShape(pptx.ShapeType.line, {
        x: TPL.decor.x, y: TPL.decor.topBlueY, w: TPL.decor.w, h: 0,
        line: { color: TPL.decor.blue, width: TPL.decor.lineW }
      });
      slide.addShape(pptx.ShapeType.line, {
        x: TPL.decor.x, y: TPL.decor.bottomGreenY, w: TPL.decor.w, h: 0,
        line: { color: TPL.decor.green, width: TPL.decor.lineW }
      });
      slide.addShape(pptx.ShapeType.line, {
        x: TPL.decor.x, y: TPL.decor.bottomBlueY, w: TPL.decor.w, h: 0,
        line: { color: TPL.decor.blue, width: TPL.decor.lineW }
      });

      // Footer
      slide.addText(TPL.footer.text, {
        x: TPL.footer.x, y: TPL.footer.y, w: TPL.footer.w, h: TPL.footer.h,
        fontFace: TPL.footer.font, fontSize: TPL.footer.size,
        color: TPL.footer.color, align: 'center', valign: 'mid'
      });

      // Title
      slide.addText('內容記錄', {
        x: 0.128, y: 0.06, w: 9.785, h: 0.5,
        fontFace: 'Microsoft JhengHei', fontSize: 24, bold: true,
        color: '000000', align: 'left', valign: 'mid'
      });

      const text = (rec.notesText || '').trim();

      // Main notes box
      const box = { x: 0.227, y: 0.75, w: 9.587, h: 6.35 };

      // Outer border
      slide.addShape(pptx.ShapeType.rect, {
        x: box.x, y: box.y, w: box.w, h: box.h,
        fill: { color: 'FFFFFF', transparency: 100 },
        line: { color: '000000', width: 1 }
      });

      if (text) {
        slide.addText(text, {
          x: box.x + 0.12, y: box.y + 0.12, w: box.w - 0.24, h: box.h - 0.24,
          fontFace: 'Microsoft JhengHei',
          fontSize: 14,
          color: '111111',
          align: 'left',
          valign: 'top'
        });
      } else {
        slide.addText('(內容記錄)', {
          x: box.x, y: box.y + box.h / 2 - 0.25, w: box.w, h: 0.5,
          fontFace: 'Microsoft JhengHei', fontSize: 18,
          color: '555555', align: 'center', valign: 'mid'
        });
      }
    }



    function addPhotos(slide, pair) {
      if (!pair || (!pair[0] && !pair[1])) return;

      const t1 = TPL.t1;
      const bodyY = t1.y + t1.headH;
      const pad = TPL.photoPad;

      const leftBox  = { x: t1.x + pad,           y: bodyY + pad, w: t1.colW - pad * 2, h: t1.bodyH - pad * 2 };
      const rightBox = { x: t1.x + t1.colW + pad, y: bodyY + pad, w: t1.colW - pad * 2, h: t1.bodyH - pad * 2 };

      const put = (img, box) => {
        if (!img) return;
        slide.addImage({
          data: img.dataUrl,
          x: box.x, y: box.y, w: box.w, h: box.h,
          sizing: { type: 'contain', x: box.x, y: box.y, w: box.w, h: box.h }
        });
      };

      put(pair[0], leftBox);
      put(pair[1], rightBox);
    }

    async function exportPPT() {
      // Ensure library available; otherwise show actionable error
      const ok = await ensurePptxGenLoaded();
      if (!ok || !window.PptxGenJS) {
        alert('無法載入 PPT 匯出元件（PptxGenJS）。\n\n可能原因：網路環境封鎖 CDN 或離線。\n解法：\n1) 改用可連外的網路開啟此頁；或\n2) 下載 pptxgen.bundle.js 放在此 HTML 同一資料夾（離線模式）。');
        return;
      }

      if (!state.records.length) { alert('目前沒有資料可匯出。'); return; }

      const hasAny = state.records.some(r => (r.type || r.name || r.notesText || r.desc || (r.images && r.images.length)));
      if (!hasAny) { alert('資料皆為空白，請至少填寫一筆內容或上傳圖片。'); return; }

      let pptx;
      try {
        pptx = new window.PptxGenJS();
        pptx.layout = 'LAYOUT_4x3';
      } catch (e) {
        alert(formatExportError(e));
        return;
      }

      for (const rec of state.records) {
        const imgs = rec.images || [];
        const pages = imgs.length ? chunk(imgs, 2) : [ [] ];
        pages.forEach((pair) => {
          const slide = pptx.addSlide();
          drawTemplate(slide, rec, pptx);
          addPhotos(slide, pair);
        });
        // 額外：內容記錄— 若有內容，新增一張「內容記錄」投影片
        const hasNotesText = ((rec.notesText || '').trim().length > 0);
        if (hasNotesText) {
          const nslide = pptx.addSlide();
          drawNotesSlide(nslide, rec, pptx);
        }
      }const fnDate = todayISO().split('-').join('');
      const filename = `訪廠問題表格_${fnDate}.pptx`;

      try {
        await pptx.writeFile({ fileName: filename });
      } catch (err) {
        console.error(err);
        alert(formatExportError(err));
      }
    }

    // ---------------- Catalog ----------------
    function openCatalog() {
      const modal = $('#catalogModal');
      const list = $('#catalogList');
      list.innerHTML = '';

      state.records.forEach((rec, idx) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'w-full text-left rounded-xl border px-3 py-3 hover:bg-slate-50 flex items-center justify-between gap-3';
        const name = displayName(rec, idx);
        const sub = (rec.type || '').trim();
        btn.innerHTML = `
          <div class="min-w-0">
            <div class="text-sm font-semibold truncate">${name}</div>
            <div class="text-xs text-slate-500 truncate">${sub ? sub : ''}</div>
          </div>
          <div class="text-xs text-slate-400 shrink-0">第 ${idx + 1} 筆</div>
        `;
        btn.addEventListener('click', () => {
          closeCatalog();
          setActive(idx);
          window.scrollTo({ top: 0, behavior: 'smooth' });
        });
        list.appendChild(btn);
      });

      modal.classList.remove('hidden');
      document.body.classList.add('overflow-hidden');
    }

    function closeCatalog() {
      const modal = $('#catalogModal');
      modal.classList.add('hidden');
      document.body.classList.remove('overflow-hidden');
    }

    
    function positionCatalogBtn() {
      const btn = document.getElementById('catalogBtn');
      const bar = document.getElementById('tabsBar');
      const tabs = document.getElementById('tabs');
      if (!btn || !bar || !tabs) return;

      const barRect = bar.getBoundingClientRect();
      const tabsRect = tabs.getBoundingClientRect();

      // Align to the left edge of the tab strip; place just below the tabs bar
      const left = Math.max(8, Math.round(tabsRect.left));
      const top = Math.round(barRect.bottom + 8);

      btn.style.left = left + 'px';
      btn.style.top = top + 'px';
    }

    let _posRaf = 0;
    function schedulePositionCatalogBtn() {
      if (_posRaf) return;
      _posRaf = requestAnimationFrame(() => {
        _posRaf = 0;
        positionCatalogBtn();
      });
    }

    // ---------------- Init ----------------
    $('#addRowBtn').addEventListener('click', () => addForm());
    $('#exportBtn').addEventListener('click', exportPPT);

        $('#exportProcessBtn')?.addEventListener('click', exportProcessExcel);
// Drive import (Apps Script Web App)
    // Open specified Drive folder
    const openDriveFolderBtn = document.getElementById('openDriveFolderBtn');
    if (openDriveFolderBtn) {
      openDriveFolderBtn.addEventListener('click', () => {
        window.open('https://drive.google.com/drive/folders/1YAYmLy9Wm0Kj4yNv5hG5-p6VXmp-02nz', '_blank', 'noopener');
      });
    }

const driveBtn = document.getElementById('driveImportBtn');
    if (driveBtn) driveBtn.addEventListener('click', openDriveModal);

// Delegated handlers for Drive modal (bind once; avoid duplicated alerts)
    let __driveDelegatesBound = false;
    function bindDriveDelegatesOnce() {
      if (__driveDelegatesBound) return;
      __driveDelegatesBound = true;

      // 全選（只作用於目前可見清單）
      document.addEventListener('change', (e) => {
        const t = e.target;
        if (t && t.id === 'driveSelectAll') {
          setAllVisibleDriveChecks(!!t.checked);
        }
      }, true);

      // 搜尋：即時篩選
      document.addEventListener('input', (e) => {
        const t = e.target;
        if (t && t.id === 'driveSearch') {
          renderDriveList(driveCache);
          syncDriveSelectAllState();
        }
      }, true);

      // 匯入／重新載入／關閉（含點擊遮罩）
      document.addEventListener('click', (e) => {
        const t = e.target;
        const el = (t && t.nodeType === 1) ? t : (t && t.parentElement ? t.parentElement : null);
        if (!el) return;

        // 資料夾瀏覽（支援多層）
        try {
          var upBtn = (el.closest ? el.closest('[data-drive-folder-up]') : null);
          if (upBtn) {
            driveGoUp_();
            return;
          }

          var folderBtn = (el.closest ? el.closest('[data-drive-folder-id]') : null);
          if (folderBtn) {
            var fid = folderBtn.getAttribute('data-drive-folder-id') || '';
            var fname = folderBtn.getAttribute('data-drive-folder-name') || fid;
            if (fid) {
              driveEnterFolder_(fid, fname);
            }
            return;
          }
        } catch (err) {}

try {
          if (el.closest && el.closest('#driveImportSelectedBtn')) {
            importSelectedFromDrive();
            return;
          }
        } catch (err) {}

        try {
          if (el.closest && el.closest('#driveImportFoldersBtn')) {
            importSelectedFoldersFromDrive();
            return;
          }
        } catch (err) {}

        try {
          if (el.closest && el.closest('#driveRefreshBtn')) {
            reloadDriveAll();
            return;
          }
        } catch (err) {}

        try {
          if (el.closest && el.closest('#closeDriveBtn')) {
            closeDriveModal();
            return;
          }
        } catch (err) {}

        if (el.dataset && el.dataset.closeDrive === 'true') {
          closeDriveModal();
        }
      }, true);
    }

    bindDriveDelegatesOnce();


// PDF import buttons
    const pdfInputEl = document.getElementById('pdfInput');
    const hookImport = () => { if (pdfInputEl) pdfInputEl.click(); };

    const importBtnHeader = document.getElementById('importPdfBtnHeader');
    if (importBtnHeader) importBtnHeader.addEventListener('click', hookImport);


    const clearBtnHeader = document.getElementById('clearFormBtnHeader');
    if (clearBtnHeader) clearBtnHeader.addEventListener('click', async () => {
      const ok = confirm('確認清空表單？\n\n此操作會：\n- 清除所有表單內容（文字/照片/手寫）\n- 清除已匯入的排關圖清單（本機/雲端）\n- 移除排關圖畫筆/標註紀錄（本機 IndexedDB）\n\n此動作無法復原。');
      if (!ok) return;

      try { flushAllNotesInk(); } catch (e) {}

      // 清表單
      state.records = [ makeEmptyRecord() ];
      state.active = 0;

      // 清匯入來源（A模式）
      try { pdfStore.forEach(v => { if (v && v.blobUrl && String(v.blobUrl).startsWith('blob:')) { try { URL.revokeObjectURL(v.blobUrl); } catch (e) {} } }); } catch (e) {}
      try { pdfStore.clear(); } catch (e) {}
      lastImportedPdfKey = '';
      try { kpiStore.clear(); } catch (e) {}
      try { clearCurrentImportedList_(); } catch (e) {}
      try { localStorage.removeItem(DRIVE_IMPORTED_KEY); } catch (e) {}

      // 清離線快取（PDF bytes + 排關圖標註）
      try { await cacheClearAllPdfs_(); } catch (e) {}
      try { await cacheClearAllAnnos_(); } catch (e) {}

      try { clearInlinePdf(); } catch (e) {}
      try { closePdfModal(); } catch (e) {}
      try { closeDriveModal(); } catch (e) {}

      saveState();
      renderAll();
      setActive(0, { scrollTabIntoView: true });
      alert('已清空完成。');
    });

    if (pdfInputEl) {
      pdfInputEl.addEventListener('change', async (e) => {
        const files = Array.from((e.target && e.target.files) ? e.target.files : []);
        await importPdfFiles(files);
        e.target.value = '';
      });
    }

    // PDF modal close
    const closePdfBtn = document.getElementById('closePdfBtn');
    if (closePdfBtn) closePdfBtn.addEventListener('click', closePdfModal);
    const pdfModal = document.getElementById('pdfModal');
    if (pdfModal) {
      pdfModal.addEventListener('click', (e) => {
        const t = e.target;
        if (t && t.dataset && t.dataset.closePdf === 'true') closePdfModal();
      });
    }

    // Fallback: delegated close handling (works even if modal DOM is injected after scripts)
    document.addEventListener('click', (e) => {
      const target = e.target;
      if (!target) return;

      // Close button
      if (target.closest && target.closest('#closePdfBtn')) {
        closePdfModal();
        return;
      }

      // Click on backdrop
      if (target.dataset && target.dataset.closePdf === 'true') {
        closePdfModal();
        return;
      }
    });



    $('#dupActiveBtn').addEventListener('click', () => duplicateAt(state.active));
    $('#delActiveBtn').addEventListener('click', () => removeAt(state.active));

    $('#catalogBtn').addEventListener('click', openCatalog);
    $('#closeCatalogBtn').addEventListener('click', closeCatalog);
    $('#catalogModal').addEventListener('click', (e) => {
      const t = e.target;
      if (t && t.dataset && t.dataset.close === 'true') closeCatalog();
    });

    window.addEventListener('keydown', (e) => { if (e.key === 'Escape') { closeCatalog(); closePdfModal(); closeDriveModal(); } });

    // 在 iOS/行動裝置：背景/閒置時可能直接回收頁面；盡量在 pagehide/visibilitychange 前先把資料寫入 storage/IndexedDB
    async function flushAllPdfAnnos_() {
      try {
        for (let i = 0; i < (state.records || []).length; i++) {
          const rec = state.records[i];
          if (!rec || !rec.rid) continue;
          const pdfKey = rec._activePdfKey || normalizeKey((rec.name || rec.productName || '').trim());
          if (!pdfKey) continue;
          // 若這個 key 的 anno 已載入或有內容，就寫入
          if (rec.pdfAnnoStore && typeof rec.pdfAnnoStore === 'object' && Object.keys(rec.pdfAnnoStore).length) {
            await cachePutAnno_(_annoCacheId_(rec.rid, pdfKey), rec.pdfAnnoStore);
          }
        }
      } catch (e) {}
    }

    window.addEventListener('pagehide', () => {
      try { flushAllNotesInk(); } catch (e) {}
      try { saveState(); } catch (e) {}
      try { flushAllPdfAnnos_(); } catch (e) {}
    });

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        try { flushAllNotesInk(); } catch (e) {}
        try { saveState(); } catch (e) {}
        try { flushAllPdfAnnos_(); } catch (e) {}
      }
    });



    window.addEventListener('resize', schedulePositionCatalogBtn);
    window.addEventListener('scroll', schedulePositionCatalogBtn, { passive: true });
    // Start（行動裝置可能會在閒置後自動回收頁面；因此改成：能讀到就復原，讀不到才初始化）
    const ok = loadState();
    if (!ok) {
      state.records = [ makeEmptyRecord() ];
      state.active = 0;
    }
    normalizeState_();
    saveState();
    // 復原先前已匯入的雲端 PDF（metadata）；若 PDF 已被快取，可在離線狀態使用
    hydratePdfStoreFromImportedList_();

    // Fallback: localStorage 可能在 iOS 閒置回收後被清空；若匯入清單遺失，嘗試由 IndexedDB 快取重建。
    try {
      hydratePdfStoreFromCacheIndex_().then(function(added){
        if (added) {
          try { refreshAllProcessStrips(); } catch (e) {}
          try { refreshAllKpiPanels(); } catch (e) {}
        }
      }).catch(function(){});
    } catch (e) {}

    // Preload PDF.js early (avoids "PDF.js 尚未載入" on first extraction in some networks)
    try {
      ensurePdfJsLoaded().then(function(ok){ window.__pdfjsReady = !!ok; }).catch(function(){ window.__pdfjsReady = false; });
    } catch (e) {}
    renderAll();
    schedulePositionCatalogBtn();
  

/* ===== PDF Inline rendering (iPad-friendly, supports optional annotations) ===== */

// --- PDF inline helpers (iPad friendly) ---
function raf2_() {
  return new Promise((resolve) => requestAnimationFrame(() => requestAnimationFrame(resolve)));
}

/**
 * Enable simple ink annotation on a canvas (pointer events).
 * - Draws in device pixels so it stays crisp on Retina/iPad.
 * - Calls opts.onChange(dataUrl) (debounced) when ink changes.
 */
function enableInkOnCanvas_(canvas, opts = {}) {
  const ctx = canvas.getContext("2d");
  if (!ctx) return null;

  const state = {
    penColor: (opts.penColor || opts.color || "#ef4444"),
    penWidth: Number((opts.penWidth ?? opts.width ?? 4)),
    eraser: !!opts.eraser,
    eraserWidth: Number(opts.eraserWidth || 18),
    disabled: !!opts.disabled
  };

  // Prevent multi-touch (2+ fingers) from triggering ink. Pinch zoom is handled by the PDF container.
  const activeTouchIds = new Set();

  let drawing = false;
  let activePointerId = null;
  let last = null;
  let changeTimer = null;

  function isPinching_() {
    try {
      const host = canvas.closest ? canvas.closest('.pdfInlineRender') : null;
      return !!(host && host._pinching);
    } catch (_) {
      return false;
    }
  }

  function pxScale_() {
    const rect = canvas.getBoundingClientRect();
    const sx = rect.width ? (canvas.width / rect.width) : 1;
    const sy = rect.height ? (canvas.height / rect.height) : 1;
    return { sx, sy, rect };
  }

  function getPt_(ev) {
    const { sx, sy, rect } = pxScale_();
    const x = (ev.clientX - rect.left) * sx;
    const y = (ev.clientY - rect.top) * sy;
    return { x, y, sx, sy };
  }

  function applyBrush_(sx, sy) {
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    if (state.eraser) {
      ctx.globalCompositeOperation = "destination-out";
      ctx.strokeStyle = "rgba(0,0,0,1)";
      ctx.lineWidth = state.eraserWidth * Math.max(sx, sy);
    } else {
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = state.penColor;
      ctx.lineWidth = state.penWidth * Math.max(sx, sy);
    }
  }

  function scheduleChange_(force = false) {
    if (typeof opts.onChange !== "function") return;
    if (force) {
      if (changeTimer) { clearTimeout(changeTimer); changeTimer = null; }
      try { opts.onChange(canvas.toDataURL("image/png")); } catch (_) {}
      return;
    }
    if (changeTimer) return;
    changeTimer = setTimeout(() => {
      changeTimer = null;
      try { opts.onChange(canvas.toDataURL("image/png")); } catch (_) {}
    }, 250);
  }

  function onDown(ev) {
    if (state.disabled) return;
    if (isPinching_()) return;

    // If a stroke is already active, ignore additional pointers (finger/palm while using stylus).
    if (drawing) {
      if (ev.pointerType === 'touch') activeTouchIds.add(ev.pointerId);
      return;
    }

    // Multi-touch: do not start drawing. (Reserved for pinch zoom.)
    if (ev.pointerType === 'touch') {
      activeTouchIds.add(ev.pointerId);
      if (activeTouchIds.size > 1) return;
    }

    drawing = true;
    activePointerId = ev.pointerId;
    try { canvas.setPointerCapture(ev.pointerId); } catch (_) {}
    const p = getPt_(ev);
    last = { x: p.x, y: p.y };
    applyBrush_(p.sx, p.sy);
    ctx.beginPath();
    ctx.moveTo(last.x, last.y);
    ev.preventDefault();
  }

  function onMove(ev) {
    if (state.disabled) return;
    if (isPinching_()) return;
    if (!drawing || activePointerId == null || ev.pointerId !== activePointerId) return;

    const p = getPt_(ev);
    applyBrush_(p.sx, p.sy);
    ctx.lineTo(p.x, p.y);
    ctx.stroke();
    last = { x: p.x, y: p.y };
    scheduleChange_();
    ev.preventDefault();
  }

  function onUp(ev) {
    if (ev.pointerType === 'touch') activeTouchIds.delete(ev.pointerId);

    if (!drawing || activePointerId == null || ev.pointerId !== activePointerId) return;
    drawing = false;
    activePointerId = null;
    try { canvas.releasePointerCapture(ev.pointerId); } catch (_) {}
    scheduleChange_(true);
    ev.preventDefault();
  }

  // Drawing canvas: let us manage gestures. Pinch zoom is implemented on the PDF container (touch events).
  canvas.style.touchAction = "none";
  canvas.addEventListener("pointerdown", onDown, { passive: false });
  canvas.addEventListener("pointermove", onMove, { passive: false });
  canvas.addEventListener("pointerup", onUp, { passive: false });
  canvas.addEventListener("pointercancel", onUp, { passive: false });

  return {
    setMode(mode) { state.eraser = (mode === "eraser"); },
    setPenWidth(w) {
      const n = Math.round(Number(w));
      if (Number.isFinite(n)) state.penWidth = Math.max(1, Math.min(12, n));
    },
    setPenColor(c) {
      if (typeof c === "string" && /^#([0-9a-fA-F]{6})$/.test(c)) state.penColor = c;
    },
    setDisabled(v) { state.disabled = !!v; },
    clear() { ctx.clearRect(0, 0, canvas.width, canvas.height); scheduleChange_(true); },
    destroy() {
      canvas.removeEventListener("pointerdown", onDown);
      canvas.removeEventListener("pointermove", onMove);
      canvas.removeEventListener("pointerup", onUp);
      canvas.removeEventListener("pointercancel", onUp);
    }
  };
}
async function renderPdfInto(containerEl, pdfDataUrlOrBytes, opts = {}) {
  containerEl.innerHTML = '';
  // Wrapper for pages (used by iPad pinch-zoom preview).
  const pagesWrap = document.createElement('div');
  pagesWrap.className = 'pdfPagesWrap w-full';
  pagesWrap.style.transformOrigin = '0 0';
  containerEl.appendChild(pagesWrap);
  containerEl._pagesWrap = pagesWrap;

  if (!pdfDataUrlOrBytes) return;

  // Prefer fit-to-width by default; ignore any legacy tiny zoom values.
  let zoomFactor = Number(opts.zoomFactor ?? 1);
  if (!Number.isFinite(zoomFactor) || zoomFactor <= 0) zoomFactor = 1;
  if (zoomFactor < 0.5) zoomFactor = 1;

  const annotate = !!opts.annotate;
  const annoStore = (opts.annoStore && typeof opts.annoStore === 'object') ? opts.annoStore : null;

  await ensurePdfJsLoaded();
  const pdfjsLib = window.pdfjsLib || window['pdfjsLib'] || window['pdfjs-dist/build/pdf'];
  if (!pdfjsLib || !pdfjsLib.getDocument) throw new Error('PDF.js not ready');

  // Normalize input to Uint8Array
  let data;
  if (typeof pdfDataUrlOrBytes === 'string') {
    if (pdfDataUrlOrBytes.startsWith('data:application/pdf')) {
      const base64 = (pdfDataUrlOrBytes.split(',')[1] || '');
      data = toUint8_(atobSafe_(base64));
    } else if (/^[A-Za-z0-9+/=]+$/.test(pdfDataUrlOrBytes.trim())) {
      data = toUint8_(atobSafe_(pdfDataUrlOrBytes.trim()));
    } else {
      throw new Error('Unsupported PDF input string');
    }
  } else if (pdfDataUrlOrBytes instanceof ArrayBuffer) {
    data = new Uint8Array(pdfDataUrlOrBytes);
  } else if (pdfDataUrlOrBytes instanceof Uint8Array) {
    data = pdfDataUrlOrBytes;
  } else {
    throw new Error('Unsupported PDF input');
  }

  // Wait until the container has a usable width (avoid hidden elements => width 0).
  const hostW = await (async () => {
  // Panel might have just been shown; wait for layout to settle.
  try { await raf2_(); } catch (_) { await new Promise((r) => requestAnimationFrame(r)); }

  const wSelf = containerEl.getBoundingClientRect().width || containerEl.clientWidth || 0;
  const wParent = containerEl.parentElement ? (containerEl.parentElement.getBoundingClientRect().width || containerEl.parentElement.clientWidth || 0) : 0;
  const wViewport = (document.documentElement && document.documentElement.clientWidth) ? document.documentElement.clientWidth : 0;

  // Prefer the actual element width; if it's 0 due to layout, fall back to parent/viewport.
  const w = Math.max(wSelf, wParent, Math.floor(wViewport * 0.92), 320);
  return w;
})();

const targetW = Math.max(320, Math.floor(hostW - 16));
  const dpr = Math.max(1, window.devicePixelRatio || 1);

  const loadingTask = pdfjsLib.getDocument({ data });
  const pdf = await loadingTask.promise;

  const pages = [];
  if (typeof opts.page === 'number' && opts.page >= 1) pages.push(Math.floor(opts.page));
  else for (let p = 1; p <= pdf.numPages; p++) pages.push(p);

  // Store anno canvases on the container so external UI can interact if needed.
  containerEl._annoCanvases = [];
  containerEl._pdfCanvases = [];
  containerEl._annoControllers = [];

  for (const pageNum of pages) {
    const page = await pdf.getPage(pageNum);

    // Compute scale so the page fits the container width, then apply user zoom.
    const viewport1 = page.getViewport({ scale: 1 });
    const baseScale = targetW / viewport1.width;
    const scale = Math.max(0.25, Math.min(6.0, baseScale * zoomFactor));
    const viewport = page.getViewport({ scale });

    // Page wrapper fills the container width.
    const pageWrap = document.createElement('div');
    pageWrap.className = 'relative mx-auto my-3 w-full overflow-hidden rounded-lg border bg-white shadow-sm';
    pageWrap.style.maxWidth = '100%';

    const inner = document.createElement('div');
    inner.className = 'relative w-full';
    pageWrap.appendChild(inner);

    const pdfCanvas = document.createElement('canvas');
    pdfCanvas.className = 'block w-full h-auto';
    // Render at devicePixelRatio for crisp text, while CSS size stays responsive.
    pdfCanvas.width = Math.floor(viewport.width * dpr);
    pdfCanvas.height = Math.floor(viewport.height * dpr);
    pdfCanvas.style.width = '100%';
    pdfCanvas.style.height = 'auto';

    inner.appendChild(pdfCanvas);

    const ctx = pdfCanvas.getContext('2d', { alpha: false });
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    await page.render({ canvasContext: ctx, viewport }).promise;

    containerEl._pdfCanvases.push({ pageNum, canvas: pdfCanvas, viewport, dpr });

    if (annotate) {
      const annoCanvas = document.createElement('canvas');
      annoCanvas.className = 'absolute inset-0 w-full h-full';
      annoCanvas.width = pdfCanvas.width;
      annoCanvas.height = pdfCanvas.height;
      annoCanvas.style.width = '100%';
      annoCanvas.style.height = '100%';
      annoCanvas.style.touchAction = 'none';

      inner.appendChild(annoCanvas);
      containerEl._annoCanvases.push({ pageNum, canvas: annoCanvas });

      // Restore existing annotation if present.
      if (annoStore && annoStore[pageNum]) {
        drawImageToCanvas_(annoCanvas, annoStore[pageNum]);
      }

      const inkApi = enableInkOnCanvas_(annoCanvas, {
        color: opts.penColor || '#f97316',
        width: Number(opts.penWidth || 3),
        eraser: !!opts.eraser,
        onChange: (dataUrl) => {
          if (annoStore) annoStore[pageNum] = dataUrl;
          if (opts && typeof opts.onAnnoChange === 'function') { try { opts.onAnnoChange(pageNum, dataUrl, annoStore); } catch (e) {} }
        }
      });
      if (inkApi) {
        annoCanvas._inkApi = inkApi;
        if (containerEl && containerEl._annoControllers) containerEl._annoControllers.push({ pageNum, api: inkApi });
      }
}

    pagesWrap.appendChild(pageWrap);
  }
}

function attachAnnoHandlers_(canvas, pageNum, store) {
  const ctx = canvas.getContext('2d');
  const ratioX = () => canvas.width / canvas.getBoundingClientRect().width;
  const ratioY = () => canvas.height / canvas.getBoundingClientRect().height;

  // Default pen style
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.strokeStyle = '#ef4444'; // red
  ctx.lineWidth = Math.max(2, (window.devicePixelRatio || 1) * 2.5);

  let drawing = false;

  function pos(e) {
    const r = canvas.getBoundingClientRect();
    return {
      x: (e.clientX - r.left) * ratioX(),
      y: (e.clientY - r.top) * ratioY()
    };
  }

  function start(e) {
    drawing = true;
    try { canvas.setPointerCapture(e.pointerId); } catch (_) {}
    const p = pos(e);
    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    e.preventDefault();
  }

  function move(e) {
    if (!drawing) return;
    const p = pos(e);
    ctx.lineTo(p.x, p.y);
    ctx.stroke();
    e.preventDefault();
  }

  function end(e) {
    if (!drawing) return;
    drawing = false;
    try { canvas.releasePointerCapture(e.pointerId); } catch (_) {}
    // Persist as dataURL (per page)
    try { store[pageNum] = canvas.toDataURL('image/png'); } catch (_) {}
    e.preventDefault();
  }

  canvas.addEventListener('pointerdown', start, { passive: false });
  canvas.addEventListener('pointermove', move, { passive: false });
  canvas.addEventListener('pointerup', end, { passive: false });
  canvas.addEventListener('pointercancel', end, { passive: false });
}

function drawImageToCanvas_(canvas, dataUrl) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      try {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      } catch (_) {}
      resolve();
    };
    img.onerror = () => resolve();
    img.src = dataUrl;
  });
}
/* ===== End PDF Inline rendering override ===== */
</script>

  <!-- PDF modal (排關圖) -->
  <div id="pdfModal" class="fixed inset-0 z-50 hidden">
    <div class="absolute inset-0 bg-black/40" data-close-pdf="true"></div>
    <div class="absolute inset-0 flex items-center justify-center p-3">
      <div class="w-full max-w-5xl rounded-2xl bg-white shadow-xl overflow-hidden">
        <div class="flex items-center justify-between gap-3 px-4 py-3 border-b">
          <div class="min-w-0">
            <div class="text-sm font-semibold">排關圖</div>
            <div id="pdfTitle" class="text-xs text-slate-500 truncate">—</div>
          </div>
          <div class="flex items-center gap-2">
            <a id="pdfOpenBtn" class="hidden rounded-xl border px-3 py-1.5 text-xs font-semibold hover:bg-slate-50" target="_blank" rel="noopener">新視窗開啟</a>
            <button type="button" id="closePdfBtn" class="rounded-xl border px-3 py-1.5 text-xs font-semibold hover:bg-slate-50">關閉</button>
          </div>
        </div>

        <div class="p-3">
          <div id="pdfEmpty" class="hidden rounded-xl border bg-slate-50 p-4 text-sm text-slate-700">
            找不到符合「商品名」的排關圖。請先點「匯入排關圖」上傳 PDF，或確認商品名是否正確。
            <div class="mt-3 text-xs text-slate-500">
              已匯入清單：<span id="pdfListText">（無）</span>
            </div>
          </div>

          <div id="pdfRender" class="hidden w-full h-[75vh] rounded-xl border overflow-auto bg-white"></div>
          <iframe id="pdfFrame" class="hidden w-full h-[75vh] rounded-xl border" title="排關圖 PDF"></iframe>
        </div>
      </div>
    </div>
  </div>


  <!-- Drive modal (從雲端匯入排關圖) -->
  <div id="driveModal" class="fixed inset-0 z-50 hidden">
    <div class="absolute inset-0 bg-black/40" data-close-drive="true"></div>
    <div class="absolute inset-0 flex items-center justify-center p-3">
      <div class="w-full max-w-5xl rounded-2xl bg-white shadow-xl overflow-hidden">
        <div class="flex items-center justify-between gap-3 px-4 py-3 border-b">
          <div class="min-w-0">
            <div class="text-sm font-semibold">從 Google Drive 資料夾匯入排關圖</div>
            <div class="text-xs text-slate-500">
              主資料夾：<span class="font-mono" id="driveRootFolderIdText">—</span>
              <span class="mx-2">•</span>
              目前資料夾：<span class="font-mono" id="driveFolderIdText">—</span>
              <span class="mx-2">•</span>
              已載入：<span id="driveCountText">0</span> 份檔案（PDF / Excel）
            </div>
          </div>
          <button type="button" id="closeDriveBtn" class="rounded-xl border px-3 py-1.5 text-xs font-semibold hover:bg-slate-50">關閉</button>
        </div>

        <div class="p-3">
          <div class="flex flex-wrap items-center gap-2">
            <div class="relative flex-1 min-w-[220px]">
              <input id="driveSearch" class="w-full rounded-xl border px-3 py-2 text-sm focus:outline-none focus:ring" placeholder="搜尋商品名 / 檔名（輸入關鍵字）" />
            </div>
            <button id="driveRefreshBtn" class="rounded-xl border px-3 py-2 text-sm font-semibold hover:bg-slate-50">重新載入</button>
            <button type="button" id="driveImportSelectedBtn" class="rounded-xl bg-emerald-600 px-3 py-2 text-sm font-semibold text-white hover:bg-emerald-700">匯入已勾選</button>
            <button type="button" id="driveImportFoldersBtn" class="rounded-xl bg-slate-900 px-3 py-2 text-sm font-semibold text-white hover:bg-slate-800">匯入整份資料夾</button>
          </div>

          <div id="driveHint" class="mt-3 text-xs text-slate-500">
            提示：此功能需要將本頁部署為 Apps Script Web App（同部門少數人存取）。若你以本機 HTML 開啟，會無法直接連到 Drive。
            <br>資料夾清單可先勾選資料夾，再按「匯入整份資料夾」可遞迴匯入該資料夾（含子資料夾）內所有 PDF。
          </div>
          <div id="driveProgressWrap" class="mt-3 hidden">
            <div class="flex items-center justify-between text-xs text-slate-600">
              <div class="font-semibold" id="driveProgressLabel">下載中…</div>
              <div id="driveProgressPct">0%</div>
            </div>
            <div class="mt-1 h-2 w-full rounded-full bg-slate-200 overflow-hidden">
              <div id="driveProgressBar" class="h-full bg-emerald-600 w-0"></div>
            </div>
            <div id="driveProgressFile" class="mt-1 text-[11px] text-slate-500 truncate"></div>
          </div>




          <div class="mt-3 rounded-2xl border overflow-hidden">
            <div class="flex items-center justify-between bg-slate-50 px-3 py-2 text-xs font-semibold text-slate-600">
              <div>資料夾（可勾選／可進入下一層）</div>
              <div class="text-[11px] font-normal text-slate-500">共 <span id="driveFolderCountText">0</span> ・已勾選 <span id="driveFolderSelCountText">0</span></div>
            </div>
            <div id="driveFolderList" class="max-h-[22vh] overflow-auto bg-white"></div>
          </div>

          <div class="mt-3 rounded-2xl border overflow-hidden">
            <div class="grid grid-cols-12 bg-slate-50 px-3 py-2 text-xs font-semibold text-slate-600">
              <div class="col-span-1"><label class="inline-flex items-center gap-2 cursor-pointer"><input id="driveSelectAll" type="checkbox" class="rounded"> 全選</label></div>
              <div class="col-span-7">檔名 / 商品名（解析）</div>
              <div class="col-span-2">大小</div>
              <div class="col-span-2">更新時間</div>
            </div>
            <div id="driveList" class="max-h-[60vh] overflow-auto"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

</body>
</html>
